CCS PCM C Compiler, Version 4.038, 33467               21-mai-10 10:33

               Filename: C:\Users\Fabio Dela Bruna\Documents\Curso de Ciência da Computação\7º Semestre\Arquitetura de Microcontroladores - Prof. Fernando Kestering Longo\Exercícios\programas_c\lista5\exercicio1.lst

               ROM used: 330 words (4%)
                         Largest free fragment is 2048
               RAM used: 7 (2%) at main() level
                         16 (4%) worst case
               Stack:    4 locations

*
0000:  MOVLW  00
0001:  MOVWF  0A
0002:  GOTO   116
0003:  NOP
.................... #include "16F877A.h" 
.................... //////// Standard Header file for the PIC16F877A device //////////////// 
.................... #device PIC16F877A 
.................... #list 
....................  
.................... #fuses HS,PROTECT,NOLVP 
.................... #use delay(clock=20Mhz) 
001F:  MOVLW  23
0020:  MOVWF  04
0021:  BCF    03.7
0022:  MOVF   00,W
0023:  BTFSC  03.2
0024:  GOTO   032
0025:  MOVLW  06
0026:  MOVWF  78
0027:  CLRF   77
0028:  DECFSZ 77,F
0029:  GOTO   028
002A:  DECFSZ 78,F
002B:  GOTO   027
002C:  MOVLW  7B
002D:  MOVWF  77
002E:  DECFSZ 77,F
002F:  GOTO   02E
0030:  DECFSZ 00,F
0031:  GOTO   025
0032:  RETLW  00
.................... #include <lcd_4.c> 
.................... #define LCD_DB4   PIN_B4 // NIBLE de dados  
.................... #define LCD_DB5   PIN_B5  
.................... #define LCD_DB6   PIN_B6  
.................... #define LCD_DB7   PIN_B7  
.................... #define LCD_RS    PIN_B2  
.................... #define LCD_E     PIN_B3  
.................... //#define USE_LCD_RW   1  
.................... #define lcd_type 2 // 0=5x7, 1=5x10, 2=2 lines  
.................... #define lcd_line_two 0x40 // LCD RAM address for the 2nd line  
.................... int8 const LCD_INIT_STRING[4] =  
.................... {  
....................    0x20 | (lcd_type << 2), // Func set: 4-bit, 2 lines, 5x8 dots  
....................    0xc,                    // Display on  
....................    1,                      // Clear display  
....................    6                       // Increment cursor  
....................  };  
....................  
.................... void lcd_send_nibble(int8 nibble){  
....................    // Obs:  !! converte uma exprecao inteira  
....................    // para uma booleana (1 or 0).  
....................    output_bit(LCD_DB4, !!(nibble & 1));  
0033:  BTFSC  2A.0
0034:  GOTO   037
0035:  BCF    06.4
0036:  GOTO   038
0037:  BSF    06.4
0038:  BSF    03.5
0039:  BCF    06.4
....................    output_bit(LCD_DB5, !!(nibble & 2));  
003A:  BCF    03.5
003B:  BTFSC  2A.1
003C:  GOTO   03F
003D:  BCF    06.5
003E:  GOTO   040
003F:  BSF    06.5
0040:  BSF    03.5
0041:  BCF    06.5
....................    output_bit(LCD_DB6, !!(nibble & 4));  
0042:  BCF    03.5
0043:  BTFSC  2A.2
0044:  GOTO   047
0045:  BCF    06.6
0046:  GOTO   048
0047:  BSF    06.6
0048:  BSF    03.5
0049:  BCF    06.6
....................    output_bit(LCD_DB7, !!(nibble & 8));  
004A:  BCF    03.5
004B:  BTFSC  2A.3
004C:  GOTO   04F
004D:  BCF    06.7
004E:  GOTO   050
004F:  BSF    06.7
0050:  BSF    03.5
0051:  BCF    06.7
....................    delay_cycles(1);  
0052:  NOP
....................    output_high(LCD_E);  
0053:  BCF    06.3
0054:  BCF    03.5
0055:  BSF    06.3
....................    delay_us(2);  
0056:  MOVLW  03
0057:  MOVWF  77
0058:  DECFSZ 77,F
0059:  GOTO   058
....................    output_low(LCD_E);  
005A:  BSF    03.5
005B:  BCF    06.3
005C:  BCF    03.5
005D:  BCF    06.3
....................    delay_us(2);//teste  
005E:  MOVLW  03
005F:  MOVWF  77
0060:  DECFSZ 77,F
0061:  GOTO   060
.................... }  
0062:  RETLW  00
.................... // Envia um byte para o LCD.  
.................... void lcd_send_byte(int8 address, int8 n){  
....................    output_low(LCD_RS);  
0063:  BSF    03.5
0064:  BCF    06.2
0065:  BCF    03.5
0066:  BCF    06.2
....................    delay_us(60);  
0067:  MOVLW  63
0068:  MOVWF  77
0069:  DECFSZ 77,F
006A:  GOTO   069
006B:  GOTO   06C
....................    if(address)  
006C:  MOVF   27,F
006D:  BTFSC  03.2
006E:  GOTO   074
....................       output_high(LCD_RS);  
006F:  BSF    03.5
0070:  BCF    06.2
0071:  BCF    03.5
0072:  BSF    06.2
....................    else  
0073:  GOTO   078
....................       output_low(LCD_RS);  
0074:  BSF    03.5
0075:  BCF    06.2
0076:  BCF    03.5
0077:  BCF    06.2
....................    delay_cycles(1);  
0078:  NOP
....................    output_low(LCD_E);  
0079:  BSF    03.5
007A:  BCF    06.3
007B:  BCF    03.5
007C:  BCF    06.3
....................    lcd_send_nibble(n >> 4);  
007D:  SWAPF  28,W
007E:  MOVWF  29
007F:  MOVLW  0F
0080:  ANDWF  29,F
0081:  MOVF   29,W
0082:  MOVWF  2A
0083:  CALL   033
....................    delay_us(2); //teste  
0084:  MOVLW  03
0085:  MOVWF  77
0086:  DECFSZ 77,F
0087:  GOTO   086
....................    lcd_send_nibble(n & 0xf);  
0088:  MOVF   28,W
0089:  ANDLW  0F
008A:  MOVWF  29
008B:  MOVWF  2A
008C:  CALL   033
.................... }  
008D:  RETLW  00
.................... void lcd_init(void){  
....................    int8 i;  
....................    output_low(LCD_RS);  
008E:  BSF    03.5
008F:  BCF    06.2
0090:  BCF    03.5
0091:  BCF    06.2
....................    output_low(LCD_E);  
0092:  BSF    03.5
0093:  BCF    06.3
0094:  BCF    03.5
0095:  BCF    06.3
....................    delay_ms(15);  
0096:  MOVLW  0F
0097:  MOVWF  23
0098:  CALL   01F
....................    for(i=0 ;i < 3; i++){  
0099:  CLRF   21
009A:  MOVF   21,W
009B:  SUBLW  02
009C:  BTFSS  03.0
009D:  GOTO   0A6
....................       lcd_send_nibble(0x03);  
009E:  MOVLW  03
009F:  MOVWF  2A
00A0:  CALL   033
....................       delay_ms(5);  
00A1:  MOVLW  05
00A2:  MOVWF  23
00A3:  CALL   01F
....................    }  
00A4:  INCF   21,F
00A5:  GOTO   09A
....................    lcd_send_nibble(0x02);  
00A6:  MOVLW  02
00A7:  MOVWF  2A
00A8:  CALL   033
....................    for(i=0; i < sizeof(LCD_INIT_STRING); i++){  
00A9:  CLRF   21
00AA:  MOVF   21,W
00AB:  SUBLW  03
00AC:  BTFSS  03.0
00AD:  GOTO   0B7
....................       lcd_send_byte(0, LCD_INIT_STRING[i]);  
00AE:  MOVF   21,W
00AF:  CALL   004
00B0:  MOVWF  22
00B1:  CLRF   27
00B2:  MOVF   22,W
00B3:  MOVWF  28
00B4:  CALL   063
....................     }  
00B5:  INCF   21,F
00B6:  GOTO   0AA
....................    delay_ms(15);  
00B7:  MOVLW  0F
00B8:  MOVWF  23
00B9:  CALL   01F
.................... }  
00BA:  BCF    0A.3
00BB:  BCF    0A.4
00BC:  GOTO   123 (RETURN)
.................... // Posicoes válidas:  
.................... // de x=1 a x=16 y  
.................... // de y=1 a y=2  
.................... void lcd_gotoxy(int8 x, int8 y){  
....................    int8 address;  
....................    if(x > 0 && y > 0){  
00BD:  MOVF   23,F
00BE:  BTFSC  03.2
00BF:  GOTO   0D5
00C0:  MOVF   24,F
00C1:  BTFSC  03.2
00C2:  GOTO   0D5
....................       if(y > 1)  
00C3:  MOVF   24,W
00C4:  SUBLW  01
00C5:  BTFSC  03.0
00C6:  GOTO   0CA
....................          address = lcd_line_two;  
00C7:  MOVLW  40
00C8:  MOVWF  25
....................       else  
00C9:  GOTO   0CB
....................          address=0;  
00CA:  CLRF   25
....................       address += x-1;  
00CB:  MOVLW  01
00CC:  SUBWF  23,W
00CD:  ADDWF  25,F
....................       lcd_send_byte(0, 0x80 | address); // Manda cursor a la posición  
00CE:  MOVF   25,W
00CF:  IORLW  80
00D0:  MOVWF  26
00D1:  CLRF   27
00D2:  MOVF   26,W
00D3:  MOVWF  28
00D4:  CALL   063
....................    }  
.................... }  
00D5:  RETLW  00
....................  
.................... void lcd_putc(char c){  
....................     if(c>'\0'){  
00D6:  MOVF   22,F
00D7:  BTFSC  03.2
00D8:  GOTO   115
....................       switch(c){  
00D9:  MOVF   22,W
00DA:  XORLW  0C
00DB:  BTFSC  03.2
00DC:  GOTO   0E7
00DD:  XORLW  06
00DE:  BTFSC  03.2
00DF:  GOTO   0F3
00E0:  XORLW  02
00E1:  BTFSC  03.2
00E2:  GOTO   0FC
00E3:  XORLW  01
00E4:  BTFSC  03.2
00E5:  GOTO   104
00E6:  GOTO   10C
....................          case '\f':  
....................             lcd_send_byte(0,1);  
00E7:  CLRF   27
00E8:  MOVLW  01
00E9:  MOVWF  28
00EA:  CALL   063
....................             lcd_send_byte(0,2);  
00EB:  CLRF   27
00EC:  MOVLW  02
00ED:  MOVWF  28
00EE:  CALL   063
....................             delay_ms(2);  
00EF:  MOVLW  02
00F0:  MOVWF  23
00F1:  CALL   01F
....................             break;  
00F2:  GOTO   115
....................          case '\n':  
....................             lcd_gotoxy(1,2);  
00F3:  MOVLW  01
00F4:  MOVWF  23
00F5:  MOVLW  02
00F6:  MOVWF  24
00F7:  CALL   0BD
....................             delay_ms(2);  
00F8:  MOVLW  02
00F9:  MOVWF  23
00FA:  CALL   01F
....................             break;  
00FB:  GOTO   115
....................          case '\b':  
....................             lcd_send_byte(0,0x10);  
00FC:  CLRF   27
00FD:  MOVLW  10
00FE:  MOVWF  28
00FF:  CALL   063
....................             delay_ms(2);  
0100:  MOVLW  02
0101:  MOVWF  23
0102:  CALL   01F
....................             break;  
0103:  GOTO   115
....................          case '\t':  
....................             lcd_send_byte(0,0x14);  
0104:  CLRF   27
0105:  MOVLW  14
0106:  MOVWF  28
0107:  CALL   063
....................             delay_ms(2);  
0108:  MOVLW  02
0109:  MOVWF  23
010A:  CALL   01F
....................             break;  
010B:  GOTO   115
....................          default:  
....................             lcd_send_byte(1,c);  
010C:  MOVLW  01
010D:  MOVWF  27
010E:  MOVF   22,W
010F:  MOVWF  28
0110:  CALL   063
....................             delay_ms(2);  
0111:  MOVLW  02
0112:  MOVWF  23
0113:  CALL   01F
....................             break;  
0114:  GOTO   115
....................       }  
....................    }  
.................... }  
0115:  RETLW  00
....................  
....................  
.................... void lcd_setcursor(short visible, short blink) {  
....................    lcd_send_byte(0, 0xC|(visible<<1)|blink);  
.................... }  
....................  
....................  
.................... void main() { 
0116:  CLRF   04
0117:  BCF    03.7
0118:  MOVLW  1F
0119:  ANDWF  03,F
011A:  BSF    03.5
011B:  BSF    1F.0
011C:  BSF    1F.1
011D:  BSF    1F.2
011E:  BCF    1F.3
011F:  MOVLW  07
0120:  MOVWF  1C
....................  
....................    lcd_init(); 
0121:  BCF    03.5
0122:  GOTO   08E
....................    lcd_gotoxy(1,1); 
0123:  MOVLW  01
0124:  MOVWF  23
0125:  MOVWF  24
0126:  CALL   0BD
....................  
....................    while(true){ 
....................     
....................        if(input(pin_a1)){ 
0127:  BSF    03.5
0128:  BSF    05.1
0129:  BCF    03.5
012A:  BTFSS  05.1
012B:  GOTO   148
....................           output_high(pin_a0); 
012C:  BSF    03.5
012D:  BCF    05.0
012E:  BCF    03.5
012F:  BSF    05.0
....................           printf(lcd_putc, "%S", "CHAVE ATIVADA!"); 
0130:  CLRF   21
0131:  MOVF   21,W
0132:  CALL   00C
0133:  IORLW  00
0134:  BTFSC  03.2
0135:  GOTO   13A
0136:  INCF   21,F
0137:  MOVWF  22
0138:  CALL   0D6
0139:  GOTO   131
....................           delay_ms(5000); 
013A:  MOVLW  14
013B:  MOVWF  21
013C:  MOVLW  FA
013D:  MOVWF  23
013E:  CALL   01F
013F:  DECFSZ 21,F
0140:  GOTO   13C
....................           output_low(pin_a0); 
0141:  BSF    03.5
0142:  BCF    05.0
0143:  BCF    03.5
0144:  BCF    05.0
....................           lcd_putc('\f'); 
0145:  MOVLW  0C
0146:  MOVWF  22
0147:  CALL   0D6
....................        } 
....................     
....................    } 
0148:  GOTO   127
....................  
.................... } 
0149:  SLEEP

Configuration Fuses:
   Word  1: 1F72   HS NOWDT PUT PROTECT NODEBUG BROWNOUT NOLVP NOCPD NOWRT
