CCS PCM C Compiler, Version 4.038, 33467               28-mai-10 10:42

               Filename: C:\Users\Fabio Dela Bruna\Documents\Curso de Ciência da Computação\7º Semestre\Arquitetura de Microcontroladores - Prof. Fernando Kestering Longo\Exercícios\programas_c\teste_funcoes\testes.lst

               ROM used: 1587 words (19%)
                         Largest free fragment is 2048
               RAM used: 26 (7%) at main() level
                         56 (15%) worst case
               Stack:    5 locations

*
0000:  MOVLW  00
0001:  MOVWF  0A
0002:  GOTO   5BC
0003:  NOP
.................... #include "16F877A.h" 
.................... //////// Standard Header file for the PIC16F877A device //////////////// 
.................... #device PIC16F877A 
.................... #list 
....................  
.................... #fuses HS, NOLVP, PROTECT 
.................... #use DELAY(CLOCK=20MHZ) 
*
002D:  MOVLW  3B
002E:  MOVWF  04
002F:  BCF    03.7
0030:  MOVF   00,W
0031:  BTFSC  03.2
0032:  GOTO   040
0033:  MOVLW  06
0034:  MOVWF  78
0035:  CLRF   77
0036:  DECFSZ 77,F
0037:  GOTO   036
0038:  DECFSZ 78,F
0039:  GOTO   035
003A:  MOVLW  7B
003B:  MOVWF  77
003C:  DECFSZ 77,F
003D:  GOTO   03C
003E:  DECFSZ 00,F
003F:  GOTO   033
0040:  RETLW  00
.................... #include <lcd_4.c> 
.................... #define LCD_DB4   PIN_B4 // NIBLE de dados  
.................... #define LCD_DB5   PIN_B5  
.................... #define LCD_DB6   PIN_B6  
.................... #define LCD_DB7   PIN_B7  
.................... #define LCD_RS    PIN_B2  
.................... #define LCD_E     PIN_B3  
.................... //#define USE_LCD_RW   1  
.................... #define lcd_type 2 // 0=5x7, 1=5x10, 2=2 lines  
.................... #define lcd_line_two 0x40 // LCD RAM address for the 2nd line  
.................... int8 const LCD_INIT_STRING[4] =  
.................... {  
....................    0x20 | (lcd_type << 2), // Func set: 4-bit, 2 lines, 5x8 dots  
....................    0xc,                    // Display on  
....................    1,                      // Clear display  
....................    6                       // Increment cursor  
....................  };  
....................  
.................... void lcd_send_nibble(int8 nibble){  
....................    // Obs:  !! converte uma exprecao inteira  
....................    // para uma booleana (1 or 0).  
....................    output_bit(LCD_DB4, !!(nibble & 1));  
0041:  BTFSC  42.0
0042:  GOTO   045
0043:  BCF    06.4
0044:  GOTO   046
0045:  BSF    06.4
0046:  BSF    03.5
0047:  BCF    06.4
....................    output_bit(LCD_DB5, !!(nibble & 2));  
0048:  BCF    03.5
0049:  BTFSC  42.1
004A:  GOTO   04D
004B:  BCF    06.5
004C:  GOTO   04E
004D:  BSF    06.5
004E:  BSF    03.5
004F:  BCF    06.5
....................    output_bit(LCD_DB6, !!(nibble & 4));  
0050:  BCF    03.5
0051:  BTFSC  42.2
0052:  GOTO   055
0053:  BCF    06.6
0054:  GOTO   056
0055:  BSF    06.6
0056:  BSF    03.5
0057:  BCF    06.6
....................    output_bit(LCD_DB7, !!(nibble & 8));  
0058:  BCF    03.5
0059:  BTFSC  42.3
005A:  GOTO   05D
005B:  BCF    06.7
005C:  GOTO   05E
005D:  BSF    06.7
005E:  BSF    03.5
005F:  BCF    06.7
....................    delay_cycles(1);  
0060:  NOP
....................    output_high(LCD_E);  
0061:  BCF    06.3
0062:  BCF    03.5
0063:  BSF    06.3
....................    delay_us(2);  
0064:  MOVLW  03
0065:  MOVWF  77
0066:  DECFSZ 77,F
0067:  GOTO   066
....................    output_low(LCD_E);  
0068:  BSF    03.5
0069:  BCF    06.3
006A:  BCF    03.5
006B:  BCF    06.3
....................    delay_us(2);//teste  
006C:  MOVLW  03
006D:  MOVWF  77
006E:  DECFSZ 77,F
006F:  GOTO   06E
.................... }  
0070:  RETLW  00
.................... // Envia um byte para o LCD.  
.................... void lcd_send_byte(int8 address, int8 n){  
....................    output_low(LCD_RS);  
0071:  BSF    03.5
0072:  BCF    06.2
0073:  BCF    03.5
0074:  BCF    06.2
....................    delay_us(60);  
0075:  MOVLW  63
0076:  MOVWF  77
0077:  DECFSZ 77,F
0078:  GOTO   077
0079:  GOTO   07A
....................    if(address)  
007A:  MOVF   3F,F
007B:  BTFSC  03.2
007C:  GOTO   082
....................       output_high(LCD_RS);  
007D:  BSF    03.5
007E:  BCF    06.2
007F:  BCF    03.5
0080:  BSF    06.2
....................    else  
0081:  GOTO   086
....................       output_low(LCD_RS);  
0082:  BSF    03.5
0083:  BCF    06.2
0084:  BCF    03.5
0085:  BCF    06.2
....................    delay_cycles(1);  
0086:  NOP
....................    output_low(LCD_E);  
0087:  BSF    03.5
0088:  BCF    06.3
0089:  BCF    03.5
008A:  BCF    06.3
....................    lcd_send_nibble(n >> 4);  
008B:  SWAPF  40,W
008C:  MOVWF  41
008D:  MOVLW  0F
008E:  ANDWF  41,F
008F:  MOVF   41,W
0090:  MOVWF  42
0091:  CALL   041
....................    delay_us(2); //teste  
0092:  MOVLW  03
0093:  MOVWF  77
0094:  DECFSZ 77,F
0095:  GOTO   094
....................    lcd_send_nibble(n & 0xf);  
0096:  MOVF   40,W
0097:  ANDLW  0F
0098:  MOVWF  41
0099:  MOVWF  42
009A:  CALL   041
.................... }  
009B:  RETLW  00
.................... void lcd_init(void){  
....................    int8 i;  
....................    output_low(LCD_RS);  
009C:  BSF    03.5
009D:  BCF    06.2
009E:  BCF    03.5
009F:  BCF    06.2
....................    output_low(LCD_E);  
00A0:  BSF    03.5
00A1:  BCF    06.3
00A2:  BCF    03.5
00A3:  BCF    06.3
....................    delay_ms(15);  
00A4:  MOVLW  0F
00A5:  MOVWF  3B
00A6:  CALL   02D
....................    for(i=0 ;i < 3; i++){  
00A7:  CLRF   30
00A8:  MOVF   30,W
00A9:  SUBLW  02
00AA:  BTFSS  03.0
00AB:  GOTO   0B4
....................       lcd_send_nibble(0x03);  
00AC:  MOVLW  03
00AD:  MOVWF  42
00AE:  CALL   041
....................       delay_ms(5);  
00AF:  MOVLW  05
00B0:  MOVWF  3B
00B1:  CALL   02D
....................    }  
00B2:  INCF   30,F
00B3:  GOTO   0A8
....................    lcd_send_nibble(0x02);  
00B4:  MOVLW  02
00B5:  MOVWF  42
00B6:  CALL   041
....................    for(i=0; i < sizeof(LCD_INIT_STRING); i++){  
00B7:  CLRF   30
00B8:  MOVF   30,W
00B9:  SUBLW  03
00BA:  BTFSS  03.0
00BB:  GOTO   0C5
....................       lcd_send_byte(0, LCD_INIT_STRING[i]);  
00BC:  MOVF   30,W
00BD:  CALL   004
00BE:  MOVWF  31
00BF:  CLRF   3F
00C0:  MOVF   31,W
00C1:  MOVWF  40
00C2:  CALL   071
....................     }  
00C3:  INCF   30,F
00C4:  GOTO   0B8
....................    delay_ms(15);  
00C5:  MOVLW  0F
00C6:  MOVWF  3B
00C7:  CALL   02D
.................... }  
00C8:  BCF    0A.3
00C9:  BCF    0A.4
00CA:  GOTO   5CF (RETURN)
.................... // Posicoes válidas:  
.................... // de x=1 a x=16 y  
.................... // de y=1 a y=2  
.................... void lcd_gotoxy(int8 x, int8 y){  
....................    int8 address;  
....................    if(x > 0 && y > 0){  
*
01DE:  MOVF   3B,F
01DF:  BTFSC  03.2
01E0:  GOTO   1F6
01E1:  MOVF   3C,F
01E2:  BTFSC  03.2
01E3:  GOTO   1F6
....................       if(y > 1)  
01E4:  MOVF   3C,W
01E5:  SUBLW  01
01E6:  BTFSC  03.0
01E7:  GOTO   1EB
....................          address = lcd_line_two;  
01E8:  MOVLW  40
01E9:  MOVWF  3D
....................       else  
01EA:  GOTO   1EC
....................          address=0;  
01EB:  CLRF   3D
....................       address += x-1;  
01EC:  MOVLW  01
01ED:  SUBWF  3B,W
01EE:  ADDWF  3D,F
....................       lcd_send_byte(0, 0x80 | address); // Manda cursor a la posición  
01EF:  MOVF   3D,W
01F0:  IORLW  80
01F1:  MOVWF  3E
01F2:  CLRF   3F
01F3:  MOVF   3E,W
01F4:  MOVWF  40
01F5:  CALL   071
....................    }  
.................... }  
01F6:  RETLW  00
....................  
.................... void lcd_putc(char c){  
....................     if(c>'\0'){  
01F7:  MOVF   3A,F
01F8:  BTFSC  03.2
01F9:  GOTO   236
....................       switch(c){  
01FA:  MOVF   3A,W
01FB:  XORLW  0C
01FC:  BTFSC  03.2
01FD:  GOTO   208
01FE:  XORLW  06
01FF:  BTFSC  03.2
0200:  GOTO   214
0201:  XORLW  02
0202:  BTFSC  03.2
0203:  GOTO   21D
0204:  XORLW  01
0205:  BTFSC  03.2
0206:  GOTO   225
0207:  GOTO   22D
....................          case '\f':  
....................             lcd_send_byte(0,1);  
0208:  CLRF   3F
0209:  MOVLW  01
020A:  MOVWF  40
020B:  CALL   071
....................             lcd_send_byte(0,2);  
020C:  CLRF   3F
020D:  MOVLW  02
020E:  MOVWF  40
020F:  CALL   071
....................             delay_ms(2);  
0210:  MOVLW  02
0211:  MOVWF  3B
0212:  CALL   02D
....................             break;  
0213:  GOTO   236
....................          case '\n':  
....................             lcd_gotoxy(1,2);  
0214:  MOVLW  01
0215:  MOVWF  3B
0216:  MOVLW  02
0217:  MOVWF  3C
0218:  CALL   1DE
....................             delay_ms(2);  
0219:  MOVLW  02
021A:  MOVWF  3B
021B:  CALL   02D
....................             break;  
021C:  GOTO   236
....................          case '\b':  
....................             lcd_send_byte(0,0x10);  
021D:  CLRF   3F
021E:  MOVLW  10
021F:  MOVWF  40
0220:  CALL   071
....................             delay_ms(2);  
0221:  MOVLW  02
0222:  MOVWF  3B
0223:  CALL   02D
....................             break;  
0224:  GOTO   236
....................          case '\t':  
....................             lcd_send_byte(0,0x14);  
0225:  CLRF   3F
0226:  MOVLW  14
0227:  MOVWF  40
0228:  CALL   071
....................             delay_ms(2);  
0229:  MOVLW  02
022A:  MOVWF  3B
022B:  CALL   02D
....................             break;  
022C:  GOTO   236
....................          default:  
....................             lcd_send_byte(1,c);  
022D:  MOVLW  01
022E:  MOVWF  3F
022F:  MOVF   3A,W
0230:  MOVWF  40
0231:  CALL   071
....................             delay_ms(2);  
0232:  MOVLW  02
0233:  MOVWF  3B
0234:  CALL   02D
....................             break;  
0235:  GOTO   236
....................       }  
....................    }  
.................... }  
0236:  RETLW  00
....................  
....................  
.................... void lcd_setcursor(short visible, short blink) {  
....................    lcd_send_byte(0, 0xC|(visible<<1)|blink);  
.................... }  
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(int *)==1 
.................... #define ptrdiff_t int 
.................... #else 
.................... #define ptrdiff_t long 
.................... #endif 
....................  
.................... #define size_t int 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: float atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float atof(char * s); 
....................  
.................... /* Standard template: float atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... float atoe(char * s); 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int32 atoi32(char *s); 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, int8 base, char * s); 
....................  
.................... /* Standard template: signed long  atol(char * s) 
....................  * converts the initial portion of the string s to a signed long 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: float strtol(char * s,char *endptr) 
....................  * converts the initial portion of the string s to a float 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... float strtod(char *s,char *endptr); 
....................  
.................... /* Standard template: long strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr,signed int base); 
....................  
.................... /* Standard template: long strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... long strtoul(char *s,char *endptr,signed int base); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... long rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer,signed int denom); 
.................... ldiv_t ldiv(signed long numer,signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(int *)==1 
.................... #define ptrdiff_t int 
.................... #else 
.................... #define ptrdiff_t long 
.................... #endif 
....................  
.................... #define size_t int 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(int *)==1 
.................... #define ptrdiff_t int 
.................... #else 
.................... #define ptrdiff_t long 
.................... #endif 
....................  
.................... #define size_t int 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
....................      *s = *s2; 
....................   } 
....................   *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   int n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,int c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, int c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... int *strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, int c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... int *strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
05C7:  BCF    03.5
05C8:  CLRF   20
05C9:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(int errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... int *strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer,signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer,signed long denom) 
.................... { 
....................    ldiv_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... float atof(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int sign = 0; 
....................    char c; 
....................    int ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int sign = 0; 
....................    int expsign = 0; 
....................    char c; 
....................    int ptr = 0; 
....................    int i; 
....................    float exp = 1.0; 
....................    int expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
00CB:  CLRF   36
....................    sign = 0; 
00CC:  CLRF   34
....................    base = 10; 
00CD:  MOVLW  0A
00CE:  MOVWF  35
....................    result = 0; 
00CF:  CLRF   33
00D0:  CLRF   32
....................  
....................    if (!s) 
00D1:  MOVF   30,W
00D2:  IORWF  31,W
00D3:  BTFSS  03.2
00D4:  GOTO   0D9
....................       return 0; 
00D5:  MOVLW  00
00D6:  MOVWF  78
00D7:  MOVWF  79
00D8:  GOTO   1DD
....................    c = s[index++]; 
00D9:  MOVF   36,W
00DA:  INCF   36,F
00DB:  ADDWF  30,W
00DC:  MOVWF  04
00DD:  BCF    03.7
00DE:  BTFSC  31.0
00DF:  BSF    03.7
00E0:  MOVF   00,W
00E1:  MOVWF  37
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
00E2:  MOVF   37,W
00E3:  SUBLW  2D
00E4:  BTFSS  03.2
00E5:  GOTO   0F2
....................    { 
....................       sign = 1;         // Set the sign to negative 
00E6:  MOVLW  01
00E7:  MOVWF  34
....................       c = s[index++]; 
00E8:  MOVF   36,W
00E9:  INCF   36,F
00EA:  ADDWF  30,W
00EB:  MOVWF  04
00EC:  BCF    03.7
00ED:  BTFSC  31.0
00EE:  BSF    03.7
00EF:  MOVF   00,W
00F0:  MOVWF  37
....................    } 
....................    else if (c == '+') 
00F1:  GOTO   0FF
00F2:  MOVF   37,W
00F3:  SUBLW  2B
00F4:  BTFSS  03.2
00F5:  GOTO   0FF
....................    { 
....................       c = s[index++]; 
00F6:  MOVF   36,W
00F7:  INCF   36,F
00F8:  ADDWF  30,W
00F9:  MOVWF  04
00FA:  BCF    03.7
00FB:  BTFSC  31.0
00FC:  BSF    03.7
00FD:  MOVF   00,W
00FE:  MOVWF  37
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
00FF:  MOVF   37,W
0100:  SUBLW  2F
0101:  BTFSC  03.0
0102:  GOTO   1CE
0103:  MOVF   37,W
0104:  SUBLW  39
0105:  BTFSS  03.0
0106:  GOTO   1CE
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
0107:  MOVF   37,W
0108:  SUBLW  30
0109:  BTFSS  03.2
010A:  GOTO   12B
010B:  MOVF   36,W
010C:  ADDWF  30,W
010D:  MOVWF  04
010E:  BCF    03.7
010F:  BTFSC  31.0
0110:  BSF    03.7
0111:  MOVF   00,W
0112:  SUBLW  78
0113:  BTFSC  03.2
0114:  GOTO   11F
0115:  MOVF   36,W
0116:  ADDWF  30,W
0117:  MOVWF  04
0118:  BCF    03.7
0119:  BTFSC  31.0
011A:  BSF    03.7
011B:  MOVF   00,W
011C:  SUBLW  58
011D:  BTFSS  03.2
011E:  GOTO   12B
....................       { 
....................          base = 16; 
011F:  MOVLW  10
0120:  MOVWF  35
....................          index++; 
0121:  INCF   36,F
....................          c = s[index++]; 
0122:  MOVF   36,W
0123:  INCF   36,F
0124:  ADDWF  30,W
0125:  MOVWF  04
0126:  BCF    03.7
0127:  BTFSC  31.0
0128:  BSF    03.7
0129:  MOVF   00,W
012A:  MOVWF  37
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
012B:  MOVF   35,W
012C:  SUBLW  0A
012D:  BTFSS  03.2
012E:  GOTO   165
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
012F:  MOVF   37,W
0130:  SUBLW  2F
0131:  BTFSC  03.0
0132:  GOTO   164
0133:  MOVF   37,W
0134:  SUBLW  39
0135:  BTFSS  03.0
0136:  GOTO   164
....................             result = 10*result + (c - '0'); 
0137:  CLRF   39
0138:  MOVLW  0A
0139:  MOVWF  38
013A:  MOVF   33,W
013B:  MOVWF  3B
013C:  MOVF   32,W
013D:  MOVWF  3A
*
0152:  MOVLW  30
0153:  SUBWF  37,W
0154:  ADDWF  78,W
0155:  MOVWF  32
0156:  MOVF   79,W
0157:  MOVWF  33
0158:  BTFSC  03.0
0159:  INCF   33,F
....................             c = s[index++]; 
015A:  MOVF   36,W
015B:  INCF   36,F
015C:  ADDWF  30,W
015D:  MOVWF  04
015E:  BCF    03.7
015F:  BTFSC  31.0
0160:  BSF    03.7
0161:  MOVF   00,W
0162:  MOVWF  37
....................          } 
0163:  GOTO   12F
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
0164:  GOTO   1CE
0165:  MOVF   35,W
0166:  SUBLW  10
0167:  BTFSS  03.2
0168:  GOTO   1CE
....................       { 
....................          c = toupper(c); 
0169:  MOVF   37,W
016A:  SUBLW  60
016B:  BTFSC  03.0
016C:  GOTO   174
016D:  MOVF   37,W
016E:  SUBLW  7A
016F:  BTFSS  03.0
0170:  GOTO   174
0171:  MOVF   37,W
0172:  ANDLW  DF
0173:  GOTO   175
0174:  MOVF   37,W
0175:  MOVWF  37
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
0176:  MOVF   37,W
0177:  SUBLW  2F
0178:  BTFSC  03.0
0179:  GOTO   17E
017A:  MOVF   37,W
017B:  SUBLW  39
017C:  BTFSC  03.0
017D:  GOTO   186
017E:  MOVF   37,W
017F:  SUBLW  40
0180:  BTFSC  03.0
0181:  GOTO   1CE
0182:  MOVF   37,W
0183:  SUBLW  46
0184:  BTFSS  03.0
0185:  GOTO   1CE
....................             if (c >= '0' && c <= '9') 
0186:  MOVF   37,W
0187:  SUBLW  2F
0188:  BTFSC  03.0
0189:  GOTO   1A3
018A:  MOVF   37,W
018B:  SUBLW  39
018C:  BTFSS  03.0
018D:  GOTO   1A3
....................                result = (result << 4) + (c - '0'); 
018E:  RLF    32,W
018F:  MOVWF  38
0190:  RLF    33,W
0191:  MOVWF  39
0192:  RLF    38,F
0193:  RLF    39,F
0194:  RLF    38,F
0195:  RLF    39,F
0196:  RLF    38,F
0197:  RLF    39,F
0198:  MOVLW  F0
0199:  ANDWF  38,F
019A:  MOVLW  30
019B:  SUBWF  37,W
019C:  ADDWF  38,W
019D:  MOVWF  32
019E:  MOVF   39,W
019F:  MOVWF  33
01A0:  BTFSC  03.0
01A1:  INCF   33,F
....................             else 
01A2:  GOTO   1B8
....................                result = (result << 4) + (c - 'A' + 10); 
01A3:  RLF    32,W
01A4:  MOVWF  38
01A5:  RLF    33,W
01A6:  MOVWF  39
01A7:  RLF    38,F
01A8:  RLF    39,F
01A9:  RLF    38,F
01AA:  RLF    39,F
01AB:  RLF    38,F
01AC:  RLF    39,F
01AD:  MOVLW  F0
01AE:  ANDWF  38,F
01AF:  MOVLW  41
01B0:  SUBWF  37,W
01B1:  ADDLW  0A
01B2:  ADDWF  38,W
01B3:  MOVWF  32
01B4:  MOVF   39,W
01B5:  MOVWF  33
01B6:  BTFSC  03.0
01B7:  INCF   33,F
....................  
....................             c = s[index++];c = toupper(c); 
01B8:  MOVF   36,W
01B9:  INCF   36,F
01BA:  ADDWF  30,W
01BB:  MOVWF  04
01BC:  BCF    03.7
01BD:  BTFSC  31.0
01BE:  BSF    03.7
01BF:  MOVF   00,W
01C0:  MOVWF  37
01C1:  SUBLW  60
01C2:  BTFSC  03.0
01C3:  GOTO   1CB
01C4:  MOVF   37,W
01C5:  SUBLW  7A
01C6:  BTFSS  03.0
01C7:  GOTO   1CB
01C8:  MOVF   37,W
01C9:  ANDLW  DF
01CA:  GOTO   1CC
01CB:  MOVF   37,W
01CC:  MOVWF  37
....................          } 
01CD:  GOTO   176
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
01CE:  MOVF   35,W
01CF:  SUBLW  0A
01D0:  BTFSS  03.2
01D1:  GOTO   1D9
01D2:  DECFSZ 34,W
01D3:  GOTO   1D9
....................       result = -result; 
01D4:  COMF   32,F
01D5:  COMF   33,F
01D6:  INCF   32,F
01D7:  BTFSC  03.2
01D8:  INCF   33,F
....................  
....................    return(result); 
01D9:  MOVF   32,W
01DA:  MOVWF  78
01DB:  MOVF   33,W
01DC:  MOVWF  79
.................... } 
01DD:  RETLW  00
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... char * itoa(signed int32 num, int8 base, char *s) 
.................... { 
....................      int32 temp=1; 
....................      int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtod(char *s,char *endptr) { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int sign = 0, point = 0; 
....................    char c; 
....................    int ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... long strtoul(char *s,char *endptr,signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr,signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... long rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned long)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... typedef signed int (*_Cmpfun)(char * p1,char * p2); 
....................  
.................... void qsort(char * qdata, int qitems, int qsize, _Cmpfun cmp) { 
....................    int m,j,i,l; 
....................    short done; 
....................    BYTE t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=TRUE; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = FALSE; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.141592654 
....................  
....................  
.................... #define SQRT2  1.41421356 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float CEIL_FLOOR(float x, int n) 
.................... { 
....................    float y, res; 
....................    long l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float)(long)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (long)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float)l); 
....................   res = 32768.0*(float)l; 
....................   res += (float)(long)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float)(long)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float floor(float x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float ceil(float x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float x,float y) 
.................... { 
....................    float i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
....................  
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
....................  
.................... #define LN2 0.6931471806 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... float exp(float x) 
.................... { 
....................    float y, res, r; 
....................    signed int n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed long)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................    *((int8 *)(&res)) = n + 0x7F; 
....................  
....................    y = y/LN2 - (float)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... /************************************************************/ 
....................  
.................... float const pl[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float const ql[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float log(float x) 
.................... { 
....................    float y, res, r, y2; 
....................  
....................    signed n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................      *((int8 *)(&y)) = 0x7E;  
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
....................  
....................       n = *((int8 *)(&x)) - 0x7E; 
....................  
....................       if (n<0) 
....................          r = -(float)-n; 
....................       else 
....................          r = (float)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... #define LN10 2.30258509 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float log10(float x) 
.................... { 
....................    float r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float modf(float value,float *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // 
.................... float pwr(float x,float y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
....................  
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // 
.................... float pow(float x,float y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float sqrt(float x) 
.................... { 
....................    float y, res; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
*
0300:  MOVF   37,W
0301:  MOVWF  45
0302:  MOVF   36,W
0303:  MOVWF  44
0304:  MOVF   35,W
0305:  MOVWF  43
0306:  MOVF   34,W
0307:  MOVWF  42
0308:  CLRF   49
0309:  CLRF   48
030A:  CLRF   47
030B:  CLRF   46
030C:  CALL   2C1
030D:  BTFSC  03.0
030E:  GOTO   311
030F:  BTFSS  03.2
0310:  GOTO   316
....................       return(0.0); 
0311:  CLRF   77
0312:  CLRF   78
0313:  CLRF   79
0314:  CLRF   7A
0315:  GOTO   598
....................  
....................    y=x; 
0316:  MOVF   37,W
0317:  MOVWF  3B
0318:  MOVF   36,W
0319:  MOVWF  3A
031A:  MOVF   35,W
031B:  MOVWF  39
031C:  MOVF   34,W
031D:  MOVWF  38
....................    p=&y; 
031E:  CLRF   41
031F:  MOVLW  38
0320:  MOVWF  40
....................    (*p)=(BYTE)((((int16)(*p)) + 127) >> 1); 
0321:  MOVF   40,W
0322:  MOVWF  04
0323:  BCF    03.7
0324:  BTFSC  41.0
0325:  BSF    03.7
0326:  MOVF   00,W
0327:  CLRF   45
0328:  MOVWF  44
0329:  MOVLW  7F
032A:  ADDWF  44,W
032B:  MOVWF  46
032C:  MOVF   45,W
032D:  MOVWF  47
032E:  BTFSC  03.0
032F:  INCF   47,F
0330:  BCF    03.0
0331:  RRF    47,W
0332:  MOVWF  7A
0333:  RRF    46,W
0334:  MOVWF  79
0335:  MOVWF  48
0336:  MOVF   40,W
0337:  MOVWF  04
0338:  BCF    03.7
0339:  BTFSC  41.0
033A:  BSF    03.7
033B:  MOVF   48,W
033C:  MOVWF  00
....................  
....................    do { 
....................       res=y; 
033D:  MOVF   3B,W
033E:  MOVWF  3F
033F:  MOVF   3A,W
0340:  MOVWF  3E
0341:  MOVF   39,W
0342:  MOVWF  3D
0343:  MOVF   38,W
0344:  MOVWF  3C
....................       y+=(x/y); 
0345:  MOVF   37,W
0346:  MOVWF  45
0347:  MOVF   36,W
0348:  MOVWF  44
0349:  MOVF   35,W
034A:  MOVWF  43
034B:  MOVF   34,W
034C:  MOVWF  42
034D:  MOVF   3B,W
034E:  MOVWF  49
034F:  MOVF   3A,W
0350:  MOVWF  48
0351:  MOVF   39,W
0352:  MOVWF  47
0353:  MOVF   38,W
0354:  MOVWF  46
*
041E:  BCF    03.1
041F:  MOVF   3B,W
0420:  MOVWF  45
0421:  MOVF   3A,W
0422:  MOVWF  44
0423:  MOVF   39,W
0424:  MOVWF  43
0425:  MOVF   38,W
0426:  MOVWF  42
0427:  MOVF   7A,W
0428:  MOVWF  49
0429:  MOVF   79,W
042A:  MOVWF  48
042B:  MOVF   78,W
042C:  MOVWF  47
042D:  MOVF   77,W
042E:  MOVWF  46
*
056F:  MOVF   7A,W
0570:  MOVWF  3B
0571:  MOVF   79,W
0572:  MOVWF  3A
0573:  MOVF   78,W
0574:  MOVWF  39
0575:  MOVF   77,W
0576:  MOVWF  38
....................       (*p)--; 
0577:  MOVF   40,W
0578:  MOVWF  04
0579:  BCF    03.7
057A:  BTFSC  41.0
057B:  BSF    03.7
057C:  DECF   00,F
....................    } while(res != y); 
057D:  MOVF   3F,W
057E:  MOVWF  45
057F:  MOVF   3E,W
0580:  MOVWF  44
0581:  MOVF   3D,W
0582:  MOVWF  43
0583:  MOVF   3C,W
0584:  MOVWF  42
0585:  MOVF   3B,W
0586:  MOVWF  49
0587:  MOVF   3A,W
0588:  MOVWF  48
0589:  MOVF   39,W
058A:  MOVWF  47
058B:  MOVF   38,W
058C:  MOVWF  46
058D:  CALL   2C1
058E:  BTFSS  03.2
058F:  GOTO   33D
....................  
....................    return(res); 
0590:  MOVF   3C,W
0591:  MOVWF  77
0592:  MOVF   3D,W
0593:  MOVWF  78
0594:  MOVF   3E,W
0595:  MOVWF  79
0596:  MOVF   3F,W
0597:  MOVWF  7A
.................... } 
0598:  BCF    0A.3
0599:  BCF    0A.4
059A:  GOTO   60D (RETURN)
....................  
....................  
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.570796326794896 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #define TWOBYPI          0.6366197724 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float cos(float x) 
.................... { 
....................    float y, t, t2 = 1.0; 
....................    int quad, i; 
....................    float frac; 
....................    float p[4] = { 
....................       -0.499999993585, 
....................        0.041666636258, 
....................       -0.0013888361399, 
....................        0.00002476016134 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (int)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 3; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float sin(float x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float tan(float x) 
.................... { 
....................    float c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
....................  
....................  
.................... float const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float ASIN_COS(float x, int n) 
.................... { 
....................    float y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float asin(float x) 
.................... { 
....................    float r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float acos(float x) 
.................... { 
....................    float r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... float const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float atan(float x) 
.................... { 
....................    float y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
....................  
.................... float atan2(float y,float x) 
.................... { 
....................    float z; 
....................    int1 sign; 
....................    int quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float cosh(float x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float sinh(float x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float tanh(float x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
....................  
....................  
.................... #define LOG2 .30102999566398119521 
.................... float frexp(float x, signed int *exp) 
.................... { 
....................    float res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float ldexp(float value, signed int exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
....................  
.................... void main() { 
*
05BC:  CLRF   04
05BD:  BCF    03.7
05BE:  MOVLW  1F
05BF:  ANDWF  03,F
05C0:  BSF    03.5
05C1:  BSF    1F.0
05C2:  BSF    1F.1
05C3:  BSF    1F.2
05C4:  BCF    1F.3
05C5:  MOVLW  07
05C6:  MOVWF  1C
....................  
....................    char v[6]; 
....................    int16 t=0; 
*
05CA:  CLRF   2C
05CB:  CLRF   2D
....................    int16 r=0; 
05CC:  CLRF   2E
05CD:  CLRF   2F
....................     
....................    lcd_init(); 
05CE:  GOTO   09C
....................     
....................    v[0]='1'; 
05CF:  MOVLW  31
05D0:  MOVWF  26
....................    v[1]='2'; 
05D1:  MOVLW  32
05D2:  MOVWF  27
....................    v[2]='1'; 
05D3:  MOVLW  31
05D4:  MOVWF  28
....................    v[3]='\0'; 
05D5:  CLRF   29
....................     
....................    while(true){ 
....................     
....................       t = atol(v); 
05D6:  CLRF   31
05D7:  MOVLW  26
05D8:  MOVWF  30
05D9:  CALL   0CB
05DA:  MOVF   79,W
05DB:  MOVWF  2D
05DC:  MOVF   78,W
05DD:  MOVWF  2C
....................       lcd_gotoxy(1,1); 
05DE:  MOVLW  01
05DF:  MOVWF  3B
05E0:  MOVWF  3C
05E1:  CALL   1DE
....................       printf(lcd_putc, "Convercao: %lu", t); 
05E2:  CLRF   30
05E3:  MOVF   30,W
05E4:  CALL   00C
05E5:  INCF   30,F
05E6:  MOVWF  77
05E7:  MOVWF  3A
05E8:  CALL   1F7
05E9:  MOVLW  0B
05EA:  SUBWF  30,W
05EB:  BTFSS  03.2
05EC:  GOTO   5E3
05ED:  MOVLW  10
05EE:  MOVWF  04
05EF:  MOVF   2D,W
05F0:  MOVWF  32
05F1:  MOVF   2C,W
05F2:  MOVWF  31
05F3:  CALL   237
....................        
....................       r = sqrt(atol(v)); 
05F4:  CLRF   31
05F5:  MOVLW  26
05F6:  MOVWF  30
05F7:  CALL   0CB
05F8:  MOVF   79,W
05F9:  MOVWF  31
05FA:  MOVF   78,W
05FB:  MOVWF  30
05FC:  GOTO   29A
05FD:  MOVF   77,W
05FE:  MOVWF  30
05FF:  MOVF   78,W
0600:  MOVWF  31
0601:  MOVF   79,W
0602:  MOVWF  32
0603:  MOVF   7A,W
0604:  MOVWF  33
0605:  MOVWF  37
0606:  MOVF   79,W
0607:  MOVWF  36
0608:  MOVF   78,W
0609:  MOVWF  35
060A:  MOVF   77,W
060B:  MOVWF  34
060C:  GOTO   300
060D:  MOVF   7A,W
060E:  MOVWF  34
060F:  MOVF   79,W
0610:  MOVWF  33
0611:  MOVF   78,W
0612:  MOVWF  32
0613:  MOVF   77,W
0614:  MOVWF  31
0615:  GOTO   59B
0616:  MOVF   79,W
0617:  MOVWF  2F
0618:  MOVF   78,W
0619:  MOVWF  2E
....................       lcd_gotoxy(1,2); 
061A:  MOVLW  01
061B:  MOVWF  3B
061C:  MOVLW  02
061D:  MOVWF  3C
061E:  CALL   1DE
....................       printf(lcd_putc, "Raiz: %lu", r); 
061F:  CLRF   30
0620:  MOVF   30,W
0621:  CALL   01F
0622:  INCF   30,F
0623:  MOVWF  77
0624:  MOVWF  3A
0625:  CALL   1F7
0626:  MOVLW  06
0627:  SUBWF  30,W
0628:  BTFSS  03.2
0629:  GOTO   620
062A:  MOVLW  10
062B:  MOVWF  04
062C:  MOVF   2F,W
062D:  MOVWF  32
062E:  MOVF   2E,W
062F:  MOVWF  31
0630:  CALL   237
....................     
....................    } 
0631:  GOTO   5D6
....................  
.................... } 
0632:  SLEEP

Configuration Fuses:
   Word  1: 1F72   HS NOWDT PUT PROTECT NODEBUG BROWNOUT NOLVP NOCPD NOWRT
