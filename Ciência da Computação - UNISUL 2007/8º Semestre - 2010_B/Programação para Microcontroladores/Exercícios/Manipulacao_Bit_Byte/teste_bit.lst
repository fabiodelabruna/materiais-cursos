CCS PCM C Compiler, Version 4.038, 33467               28-out-10 09:08

               Filename: C:\Users\Fabio Dela Bruna\Documents\Curso de Ciência da Computação\8º Semestre\Programação para Microcontroladores - Prof. Fernando Kestering Longo\Exercícios\Manipulacao_Bit_Byte\teste_bit.lst

               ROM used: 770 words (9%)
                         Largest free fragment is 2048
               RAM used: 18 (5%) at main() level
                         26 (7%) worst case
               Stack:    2 locations

*
0000:  MOVLW  00
0001:  MOVWF  0A
0002:  GOTO   1CA
0003:  NOP
.................... #include <16F877A.h> 
.................... //////// Standard Header file for the PIC16F877A device //////////////// 
.................... #device PIC16F877A 
.................... #list 
....................  
.................... #fuses XT, PROTECT 
.................... #use delay(clock=4MHz) 
.................... #use rs232(baud=9600,xmit=pin_c6,rcv=pin_c7) 
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(int *)==1 
.................... #define ptrdiff_t int 
.................... #else 
.................... #define ptrdiff_t long 
.................... #endif 
....................  
.................... #define size_t int 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: float atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float atof(char * s); 
....................  
.................... /* Standard template: float atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... float atoe(char * s); 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int32 atoi32(char *s); 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, int8 base, char * s); 
....................  
.................... /* Standard template: signed long  atol(char * s) 
....................  * converts the initial portion of the string s to a signed long 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: float strtol(char * s,char *endptr) 
....................  * converts the initial portion of the string s to a float 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... float strtod(char *s,char *endptr); 
....................  
.................... /* Standard template: long strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr,signed int base); 
....................  
.................... /* Standard template: long strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... long strtoul(char *s,char *endptr,signed int base); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... long rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer,signed int denom); 
.................... ldiv_t ldiv(signed long numer,signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(int *)==1 
.................... #define ptrdiff_t int 
.................... #else 
.................... #define ptrdiff_t long 
.................... #endif 
....................  
.................... #define size_t int 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(int *)==1 
.................... #define ptrdiff_t int 
.................... #else 
.................... #define ptrdiff_t long 
.................... #endif 
....................  
.................... #define size_t int 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
....................      *s = *s2; 
....................   } 
....................   *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   int n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,int c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, int c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... int *strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, int c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... int *strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
01DD:  BCF    03.5
01DE:  CLRF   20
01DF:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(int errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... int *strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer,signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer,signed long denom) 
.................... { 
....................    ldiv_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... float atof(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int sign = 0; 
....................    char c; 
....................    int ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int sign = 0; 
....................    int expsign = 0; 
....................    char c; 
....................    int ptr = 0; 
....................    int i; 
....................    float exp = 1.0; 
....................    int expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
007F:  CLRF   30
....................    sign = 0; 
0080:  CLRF   2E
....................    base = 10; 
0081:  MOVLW  0A
0082:  MOVWF  2F
....................    result = 0; 
0083:  CLRF   2D
....................  
....................    if (!s) 
0084:  MOVF   2B,W
0085:  IORWF  2C,W
0086:  BTFSS  03.2
0087:  GOTO   08B
....................       return 0; 
0088:  MOVLW  00
0089:  MOVWF  78
008A:  GOTO   17C
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
008B:  MOVF   30,W
008C:  INCF   30,F
008D:  ADDWF  2B,W
008E:  MOVWF  04
008F:  BCF    03.7
0090:  BTFSC  2C.0
0091:  BSF    03.7
0092:  MOVF   00,W
0093:  MOVWF  31
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
0094:  MOVF   31,W
0095:  SUBLW  2D
0096:  BTFSS  03.2
0097:  GOTO   0A4
....................    { 
....................       sign = 1;         // Set the sign to negative 
0098:  MOVLW  01
0099:  MOVWF  2E
....................       c = s[index++]; 
009A:  MOVF   30,W
009B:  INCF   30,F
009C:  ADDWF  2B,W
009D:  MOVWF  04
009E:  BCF    03.7
009F:  BTFSC  2C.0
00A0:  BSF    03.7
00A1:  MOVF   00,W
00A2:  MOVWF  31
....................    } 
....................    else if (c == '+') 
00A3:  GOTO   0B1
00A4:  MOVF   31,W
00A5:  SUBLW  2B
00A6:  BTFSS  03.2
00A7:  GOTO   0B1
....................    { 
....................       c = s[index++]; 
00A8:  MOVF   30,W
00A9:  INCF   30,F
00AA:  ADDWF  2B,W
00AB:  MOVWF  04
00AC:  BCF    03.7
00AD:  BTFSC  2C.0
00AE:  BSF    03.7
00AF:  MOVF   00,W
00B0:  MOVWF  31
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
00B1:  MOVF   31,W
00B2:  SUBLW  2F
00B3:  BTFSC  03.0
00B4:  GOTO   172
00B5:  MOVF   31,W
00B6:  SUBLW  39
00B7:  BTFSS  03.0
00B8:  GOTO   172
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
00B9:  MOVF   31,W
00BA:  SUBLW  30
00BB:  BTFSS  03.2
00BC:  GOTO   0DD
00BD:  MOVF   30,W
00BE:  ADDWF  2B,W
00BF:  MOVWF  04
00C0:  BCF    03.7
00C1:  BTFSC  2C.0
00C2:  BSF    03.7
00C3:  MOVF   00,W
00C4:  SUBLW  78
00C5:  BTFSC  03.2
00C6:  GOTO   0D1
00C7:  MOVF   30,W
00C8:  ADDWF  2B,W
00C9:  MOVWF  04
00CA:  BCF    03.7
00CB:  BTFSC  2C.0
00CC:  BSF    03.7
00CD:  MOVF   00,W
00CE:  SUBLW  58
00CF:  BTFSS  03.2
00D0:  GOTO   0DD
....................       { 
....................          base = 16; 
00D1:  MOVLW  10
00D2:  MOVWF  2F
....................          index++; 
00D3:  INCF   30,F
....................          c = s[index++]; 
00D4:  MOVF   30,W
00D5:  INCF   30,F
00D6:  ADDWF  2B,W
00D7:  MOVWF  04
00D8:  BCF    03.7
00D9:  BTFSC  2C.0
00DA:  BSF    03.7
00DB:  MOVF   00,W
00DC:  MOVWF  31
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
00DD:  MOVF   2F,W
00DE:  SUBLW  0A
00DF:  BTFSS  03.2
00E0:  GOTO   120
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
00E1:  MOVF   31,W
00E2:  SUBLW  2F
00E3:  BTFSC  03.0
00E4:  GOTO   11F
00E5:  MOVF   31,W
00E6:  SUBLW  39
00E7:  BTFSS  03.0
00E8:  GOTO   11F
....................             result = 10*result + (c - '0'); 
00E9:  MOVLW  0A
00EA:  MOVWF  32
00EB:  MOVF   2D,W
00EC:  MOVWF  33
*
0111:  MOVLW  30
0112:  SUBWF  31,W
0113:  ADDWF  78,W
0114:  MOVWF  2D
....................             c = s[index++]; 
0115:  MOVF   30,W
0116:  INCF   30,F
0117:  ADDWF  2B,W
0118:  MOVWF  04
0119:  BCF    03.7
011A:  BTFSC  2C.0
011B:  BSF    03.7
011C:  MOVF   00,W
011D:  MOVWF  31
....................          } 
011E:  GOTO   0E1
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
011F:  GOTO   172
0120:  MOVF   2F,W
0121:  SUBLW  10
0122:  BTFSS  03.2
0123:  GOTO   172
....................       { 
....................          c = toupper(c); 
0124:  MOVF   31,W
0125:  SUBLW  60
0126:  BTFSC  03.0
0127:  GOTO   12F
0128:  MOVF   31,W
0129:  SUBLW  7A
012A:  BTFSS  03.0
012B:  GOTO   12F
012C:  MOVF   31,W
012D:  ANDLW  DF
012E:  GOTO   130
012F:  MOVF   31,W
0130:  MOVWF  31
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
0131:  MOVF   31,W
0132:  SUBLW  2F
0133:  BTFSC  03.0
0134:  GOTO   139
0135:  MOVF   31,W
0136:  SUBLW  39
0137:  BTFSC  03.0
0138:  GOTO   141
0139:  MOVF   31,W
013A:  SUBLW  40
013B:  BTFSC  03.0
013C:  GOTO   172
013D:  MOVF   31,W
013E:  SUBLW  46
013F:  BTFSS  03.0
0140:  GOTO   172
....................             if (c >= '0' && c <= '9') 
0141:  MOVF   31,W
0142:  SUBLW  2F
0143:  BTFSC  03.0
0144:  GOTO   152
0145:  MOVF   31,W
0146:  SUBLW  39
0147:  BTFSS  03.0
0148:  GOTO   152
....................                result = (result << 4) + (c - '0'); 
0149:  SWAPF  2D,W
014A:  MOVWF  32
014B:  MOVLW  F0
014C:  ANDWF  32,F
014D:  MOVLW  30
014E:  SUBWF  31,W
014F:  ADDWF  32,W
0150:  MOVWF  2D
....................             else 
0151:  GOTO   15B
....................                result = (result << 4) + (c - 'A' + 10); 
0152:  SWAPF  2D,W
0153:  MOVWF  32
0154:  MOVLW  F0
0155:  ANDWF  32,F
0156:  MOVLW  41
0157:  SUBWF  31,W
0158:  ADDLW  0A
0159:  ADDWF  32,W
015A:  MOVWF  2D
....................  
....................             c = s[index++]; 
015B:  MOVF   30,W
015C:  INCF   30,F
015D:  ADDWF  2B,W
015E:  MOVWF  04
015F:  BCF    03.7
0160:  BTFSC  2C.0
0161:  BSF    03.7
0162:  MOVF   00,W
0163:  MOVWF  31
....................             c = toupper(c); 
0164:  MOVF   31,W
0165:  SUBLW  60
0166:  BTFSC  03.0
0167:  GOTO   16F
0168:  MOVF   31,W
0169:  SUBLW  7A
016A:  BTFSS  03.0
016B:  GOTO   16F
016C:  MOVF   31,W
016D:  ANDLW  DF
016E:  GOTO   170
016F:  MOVF   31,W
0170:  MOVWF  31
....................          } 
0171:  GOTO   131
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
0172:  DECFSZ 2E,W
0173:  GOTO   17A
0174:  MOVF   2F,W
0175:  SUBLW  0A
0176:  BTFSS  03.2
0177:  GOTO   17A
....................        result = -result; 
0178:  COMF   2D,F
0179:  INCF   2D,F
....................  
....................    return(result); 
017A:  MOVF   2D,W
017B:  MOVWF  78
.................... } 
017C:  RETLW  00
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... char * itoa(signed int32 num, int8 base, char *s) 
.................... { 
....................      int32 temp=1; 
....................      int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtod(char *s,char *endptr) { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int sign = 0, point = 0; 
....................    char c; 
....................    int ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... long strtoul(char *s,char *endptr,signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr,signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... long rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned long)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... typedef signed int (*_Cmpfun)(char * p1,char * p2); 
....................  
.................... void qsort(char * qdata, int qitems, int qsize, _Cmpfun cmp) { 
....................    int m,j,i,l; 
....................    short done; 
....................    BYTE t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=TRUE; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = FALSE; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... void main() { 
*
01CA:  CLRF   04
01CB:  BCF    03.7
01CC:  MOVLW  1F
01CD:  ANDWF  03,F
01CE:  MOVLW  19
01CF:  BSF    03.5
01D0:  MOVWF  19
01D1:  MOVLW  A6
01D2:  MOVWF  18
01D3:  MOVLW  90
01D4:  BCF    03.5
01D5:  MOVWF  18
01D6:  BSF    03.5
01D7:  BSF    1F.0
01D8:  BSF    1F.1
01D9:  BSF    1F.2
01DA:  BCF    1F.3
01DB:  MOVLW  07
01DC:  MOVWF  1C
....................  
....................    byte var = 0b00000101; 
*
01E0:  MOVLW  05
01E1:  MOVWF  26
....................    char comando = ' '; 
01E2:  MOVLW  20
01E3:  MOVWF  27
....................    char c[2]; 
....................    int i = 0; 
01E4:  CLRF   2A
....................     
....................     
....................    while (true) { 
....................     
....................      comando = getc(); 
01E5:  BTFSS  0C.5
01E6:  GOTO   1E5
01E7:  MOVF   1A,W
01E8:  MOVWF  27
....................      if(comando == 's') { 
01E9:  MOVF   27,W
01EA:  SUBLW  73
01EB:  BTFSS  03.2
01EC:  GOTO   24E
....................         printf("Bit Set:\r\n"); 
01ED:  CLRF   2B
01EE:  MOVF   2B,W
01EF:  CALL   004
01F0:  INCF   2B,F
01F1:  MOVWF  77
01F2:  MOVF   77,W
01F3:  BTFSS  0C.4
01F4:  GOTO   1F3
01F5:  MOVWF  19
01F6:  MOVLW  0A
01F7:  SUBWF  2B,W
01F8:  BTFSS  03.2
01F9:  GOTO   1EE
....................         gets(c); 
01FA:  MOVLW  28
01FB:  MOVWF  04
01FC:  BCF    03.7
01FD:  DECF   04,F
01FE:  INCF   04,F
01FF:  BTFSS  0C.5
0200:  GOTO   1FF
0201:  MOVF   1A,W
0202:  MOVWF  00
0203:  MOVLW  0D
0204:  SUBWF  00,W
0205:  BTFSS  03.2
0206:  GOTO   1FE
0207:  CLRF   00
....................         i=atoi(c); 
0208:  CLRF   2C
0209:  MOVLW  28
020A:  MOVWF  2B
020B:  CALL   07F
020C:  MOVF   78,W
020D:  MOVWF  2A
....................         printf("Valor antigo: %u\r\n", var); 
020E:  CLRF   2B
020F:  MOVF   2B,W
0210:  CALL   013
0211:  INCF   2B,F
0212:  MOVWF  77
0213:  MOVF   77,W
0214:  BTFSS  0C.4
0215:  GOTO   214
0216:  MOVWF  19
0217:  MOVLW  0E
0218:  SUBWF  2B,W
0219:  BTFSS  03.2
021A:  GOTO   20F
021B:  MOVF   26,W
021C:  MOVWF  2C
021D:  MOVLW  1B
021E:  MOVWF  2D
021F:  CALL   192
0220:  MOVLW  0D
0221:  BTFSS  0C.4
0222:  GOTO   221
0223:  MOVWF  19
0224:  MOVLW  0A
0225:  BTFSS  0C.4
0226:  GOTO   225
0227:  MOVWF  19
....................         bit_set(var,i); // bit_set(var, x) - seta o valor do bit para 1 (true) 
0228:  MOVLW  01
0229:  MOVWF  77
022A:  MOVF   2A,W
022B:  MOVWF  78
022C:  BTFSC  03.2
022D:  GOTO   232
022E:  BCF    03.0
022F:  RLF    77,F
0230:  DECFSZ 78,F
0231:  GOTO   22E
0232:  MOVF   77,W
0233:  IORWF  26,F
....................         printf("Novo valor: %u\r\n", var);  
0234:  CLRF   2B
0235:  MOVF   2B,W
0236:  CALL   02A
0237:  INCF   2B,F
0238:  MOVWF  77
0239:  MOVF   77,W
023A:  BTFSS  0C.4
023B:  GOTO   23A
023C:  MOVWF  19
023D:  MOVLW  0C
023E:  SUBWF  2B,W
023F:  BTFSS  03.2
0240:  GOTO   235
0241:  MOVF   26,W
0242:  MOVWF  2C
0243:  MOVLW  1B
0244:  MOVWF  2D
0245:  CALL   192
0246:  MOVLW  0D
0247:  BTFSS  0C.4
0248:  GOTO   247
0249:  MOVWF  19
024A:  MOVLW  0A
024B:  BTFSS  0C.4
024C:  GOTO   24B
024D:  MOVWF  19
....................      } 
....................      if(comando == 'c') { 
024E:  MOVF   27,W
024F:  SUBLW  63
0250:  BTFSS  03.2
0251:  GOTO   2B4
....................         printf("Set Clear:\r\n"); 
0252:  CLRF   2B
0253:  MOVF   2B,W
0254:  CALL   03F
0255:  INCF   2B,F
0256:  MOVWF  77
0257:  MOVF   77,W
0258:  BTFSS  0C.4
0259:  GOTO   258
025A:  MOVWF  19
025B:  MOVLW  0C
025C:  SUBWF  2B,W
025D:  BTFSS  03.2
025E:  GOTO   253
....................         gets(c); 
025F:  MOVLW  28
0260:  MOVWF  04
0261:  BCF    03.7
0262:  DECF   04,F
0263:  INCF   04,F
0264:  BTFSS  0C.5
0265:  GOTO   264
0266:  MOVF   1A,W
0267:  MOVWF  00
0268:  MOVLW  0D
0269:  SUBWF  00,W
026A:  BTFSS  03.2
026B:  GOTO   263
026C:  CLRF   00
....................         i=atoi(c); 
026D:  CLRF   2C
026E:  MOVLW  28
026F:  MOVWF  2B
0270:  CALL   07F
0271:  MOVF   78,W
0272:  MOVWF  2A
....................         printf("Valor antigo: %u\r\n", var); 
0273:  CLRF   2B
0274:  MOVF   2B,W
0275:  CALL   013
0276:  INCF   2B,F
0277:  MOVWF  77
0278:  MOVF   77,W
0279:  BTFSS  0C.4
027A:  GOTO   279
027B:  MOVWF  19
027C:  MOVLW  0E
027D:  SUBWF  2B,W
027E:  BTFSS  03.2
027F:  GOTO   274
0280:  MOVF   26,W
0281:  MOVWF  2C
0282:  MOVLW  1B
0283:  MOVWF  2D
0284:  CALL   192
0285:  MOVLW  0D
0286:  BTFSS  0C.4
0287:  GOTO   286
0288:  MOVWF  19
0289:  MOVLW  0A
028A:  BTFSS  0C.4
028B:  GOTO   28A
028C:  MOVWF  19
....................         bit_clear(var,i); // bit_clear(var, x) - seta o valor do bit para 0 (false) 
028D:  MOVLW  01
028E:  MOVWF  77
028F:  MOVF   2A,W
0290:  MOVWF  78
0291:  BTFSC  03.2
0292:  GOTO   297
0293:  BCF    03.0
0294:  RLF    77,F
0295:  DECFSZ 78,F
0296:  GOTO   293
0297:  MOVF   77,W
0298:  XORLW  FF
0299:  ANDWF  26,F
....................         printf("Novo valor: %u\r\n", var);  
029A:  CLRF   2B
029B:  MOVF   2B,W
029C:  CALL   02A
029D:  INCF   2B,F
029E:  MOVWF  77
029F:  MOVF   77,W
02A0:  BTFSS  0C.4
02A1:  GOTO   2A0
02A2:  MOVWF  19
02A3:  MOVLW  0C
02A4:  SUBWF  2B,W
02A5:  BTFSS  03.2
02A6:  GOTO   29B
02A7:  MOVF   26,W
02A8:  MOVWF  2C
02A9:  MOVLW  1B
02AA:  MOVWF  2D
02AB:  CALL   192
02AC:  MOVLW  0D
02AD:  BTFSS  0C.4
02AE:  GOTO   2AD
02AF:  MOVWF  19
02B0:  MOVLW  0A
02B1:  BTFSS  0C.4
02B2:  GOTO   2B1
02B3:  MOVWF  19
....................      } 
....................      if(comando == 't') { 
02B4:  MOVF   27,W
02B5:  SUBLW  74
02B6:  BTFSS  03.2
02B7:  GOTO   300
....................         printf("Bit Test:\r\n"); 
02B8:  CLRF   2B
02B9:  MOVF   2B,W
02BA:  CALL   050
02BB:  INCF   2B,F
02BC:  MOVWF  77
02BD:  MOVF   77,W
02BE:  BTFSS  0C.4
02BF:  GOTO   2BE
02C0:  MOVWF  19
02C1:  MOVLW  0B
02C2:  SUBWF  2B,W
02C3:  BTFSS  03.2
02C4:  GOTO   2B9
....................         gets(c); 
02C5:  MOVLW  28
02C6:  MOVWF  04
02C7:  BCF    03.7
02C8:  DECF   04,F
02C9:  INCF   04,F
02CA:  BTFSS  0C.5
02CB:  GOTO   2CA
02CC:  MOVF   1A,W
02CD:  MOVWF  00
02CE:  MOVLW  0D
02CF:  SUBWF  00,W
02D0:  BTFSS  03.2
02D1:  GOTO   2C9
02D2:  CLRF   00
....................         i=atoi(c); 
02D3:  CLRF   2C
02D4:  MOVLW  28
02D5:  MOVWF  2B
02D6:  CALL   07F
02D7:  MOVF   78,W
02D8:  MOVWF  2A
....................         if(bit_test(var,i)) { // bit_teste(var, x) - faz o teste de um bit específico - verifica se é true ou false 
02D9:  MOVF   26,W
02DA:  MOVWF  77
02DB:  MOVF   2A,W
02DC:  MOVWF  78
02DD:  BTFSC  03.2
02DE:  GOTO   2E3
02DF:  BCF    03.0
02E0:  RRF    77,F
02E1:  DECFSZ 78,F
02E2:  GOTO   2DF
02E3:  BTFSS  77.0
02E4:  GOTO   2F3
....................            printf("Bit TRUE\r\n"); 
02E5:  CLRF   2B
02E6:  MOVF   2B,W
02E7:  CALL   060
02E8:  INCF   2B,F
02E9:  MOVWF  77
02EA:  MOVF   77,W
02EB:  BTFSS  0C.4
02EC:  GOTO   2EB
02ED:  MOVWF  19
02EE:  MOVLW  0A
02EF:  SUBWF  2B,W
02F0:  BTFSS  03.2
02F1:  GOTO   2E6
....................         } else { 
02F2:  GOTO   300
....................            printf("Bit FALSE\r\n"); 
02F3:  CLRF   2B
02F4:  MOVF   2B,W
02F5:  CALL   06F
02F6:  INCF   2B,F
02F7:  MOVWF  77
02F8:  MOVF   77,W
02F9:  BTFSS  0C.4
02FA:  GOTO   2F9
02FB:  MOVWF  19
02FC:  MOVLW  0B
02FD:  SUBWF  2B,W
02FE:  BTFSS  03.2
02FF:  GOTO   2F4
....................         } 
....................      } 
....................        
....................    } 
0300:  GOTO   1E5
....................  
.................... } 
0301:  SLEEP

Configuration Fuses:
   Word  1: 1F71   XT NOWDT PUT PROTECT NODEBUG BROWNOUT NOLVP NOCPD NOWRT
