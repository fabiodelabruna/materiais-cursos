CCS PCM C Compiler, Version 4.093, 5065               14-Eki-10 10:05

               Filename: C:\PIC C Compiler PCWHD_4.093\PIC\Exercícios\Manipulacao_String\teste1.lst

               ROM used: 352 words (4%)
                         Largest free fragment is 2048
               RAM used: 25 (7%) at main() level
                         27 (7%) worst case
               Stack:    2 locations

*
0000:  MOVLW  00
0001:  MOVWF  0A
0002:  GOTO   09D
0003:  NOP
.................... #include <16F877A.h> 
.................... //////// Standard Header file for the PIC16F877A device //////////////// 
.................... #device PIC16F877A 
.................... #list 
....................  
.................... #fuses XT, PROTECT 
.................... #use delay(clock=4MHz) 
0051:  MOVLW  2F
0052:  MOVWF  04
0053:  BCF    03.7
0054:  MOVF   00,W
0055:  BTFSC  03.2
0056:  GOTO   065
0057:  MOVLW  01
0058:  MOVWF  78
0059:  CLRF   77
005A:  DECFSZ 77,F
005B:  GOTO   05A
005C:  DECFSZ 78,F
005D:  GOTO   059
005E:  MOVLW  4A
005F:  MOVWF  77
0060:  DECFSZ 77,F
0061:  GOTO   060
0062:  GOTO   063
0063:  DECFSZ 00,F
0064:  GOTO   057
0065:  RETLW  00
.................... #use rs232(baud=9600,xmit=pin_c6,rcv=pin_c7) 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
....................      *s = *s2; 
....................   } 
....................   *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8 *strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8 *strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
00B0:  BCF    03.5
00B1:  CLRF   20
00B2:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 *strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
*
0066:  MOVF   2F,W
0067:  MOVWF  31
0068:  MOVF   2E,W
0069:  MOVWF  30
006A:  MOVF   31,W
006B:  MOVWF  7A
006C:  MOVF   30,W
006D:  MOVWF  04
006E:  BCF    03.7
006F:  BTFSC  7A.0
0070:  BSF    03.7
0071:  MOVF   00,F
0072:  BTFSC  03.2
0073:  GOTO   096
....................       if (*p >= 'A' && *p <='Z') 
0074:  MOVF   31,W
0075:  MOVWF  7A
0076:  MOVF   30,W
0077:  MOVWF  04
0078:  BCF    03.7
0079:  BTFSC  7A.0
007A:  BSF    03.7
007B:  MOVF   00,W
007C:  SUBLW  40
007D:  BTFSC  03.0
007E:  GOTO   092
007F:  MOVF   31,W
0080:  MOVWF  7A
0081:  MOVF   30,W
0082:  MOVWF  04
0083:  BCF    03.7
0084:  BTFSC  7A.0
0085:  BSF    03.7
0086:  MOVF   00,W
0087:  SUBLW  5A
0088:  BTFSS  03.0
0089:  GOTO   092
....................          *p += 'a' - 'A'; 
008A:  MOVF   30,W
008B:  MOVWF  04
008C:  BCF    03.7
008D:  BTFSC  31.0
008E:  BSF    03.7
008F:  MOVLW  20
0090:  ADDWF  00,W
0091:  MOVWF  00
0092:  INCF   30,F
0093:  BTFSC  03.2
0094:  INCF   31,F
0095:  GOTO   06A
....................    return(s); 
0096:  MOVF   2E,W
0097:  MOVWF  78
0098:  MOVF   2F,W
0099:  MOVWF  79
.................... } 
009A:  BCF    0A.3
009B:  BCF    0A.4
009C:  GOTO   0FF (RETURN)
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #byte RCSTA=0x18 // #byte significa que vai mexer em um endereço na memória RAM 
....................  
....................  
.................... void main() { 
009D:  CLRF   04
009E:  BCF    03.7
009F:  MOVLW  1F
00A0:  ANDWF  03,F
00A1:  MOVLW  19
00A2:  BSF    03.5
00A3:  MOVWF  19
00A4:  MOVLW  A6
00A5:  MOVWF  18
00A6:  MOVLW  90
00A7:  BCF    03.5
00A8:  MOVWF  18
00A9:  BSF    03.5
00AA:  BSF    1F.0
00AB:  BSF    1F.1
00AC:  BSF    1F.2
00AD:  BCF    1F.3
00AE:  MOVLW  07
00AF:  MOVWF  1C
....................     
....................    char c[10], *ptr; // é preciso declarar um ponteiro, pois em c, não é possível atribuir a modificação de uma string a ela mesma 
....................     
....................    while(true) { 
....................       printf("%u\r\n", RCSTA); //mostra o valor do endereço de memoria 0x18 
*
00B3:  MOVF   18,W
00B4:  MOVWF  2E
00B5:  MOVLW  1B
00B6:  MOVWF  2F
00B7:  CALL   019
00B8:  MOVLW  0D
00B9:  BTFSS  0C.4
00BA:  GOTO   0B9
00BB:  MOVWF  19
00BC:  MOVLW  0A
00BD:  BTFSS  0C.4
00BE:  GOTO   0BD
00BF:  MOVWF  19
....................       // para indicar que o programa está rodando 
....................       output_bit(pin_b0,1); 
00C0:  BSF    06.0
00C1:  BSF    03.5
00C2:  BCF    06.0
....................       delay_ms(1000); 
00C3:  MOVLW  04
00C4:  BCF    03.5
00C5:  MOVWF  2E
00C6:  MOVLW  FA
00C7:  MOVWF  2F
00C8:  CALL   051
00C9:  DECFSZ 2E,F
00CA:  GOTO   0C6
....................       output_bit(pin_b0,0); 
00CB:  BCF    06.0
00CC:  BSF    03.5
00CD:  BCF    06.0
....................       delay_ms(1000); 
00CE:  MOVLW  04
00CF:  BCF    03.5
00D0:  MOVWF  2E
00D1:  MOVLW  FA
00D2:  MOVWF  2F
00D3:  CALL   051
00D4:  DECFSZ 2E,F
00D5:  GOTO   0D1
....................     
....................       if(kbhit()) { 
00D6:  BTFSS  0C.5
00D7:  GOTO   14A
....................          // CONVERTE UM CARACTER PARA CAIXA ALTA  
....................          // (O MESMO PODE SER FEITO PARA CAIXA BAIXA USANDO A FUNÇÃO tolower()) 
....................          /*c = getc(); 
....................          putc(c); 
....................          putc(0xD0); // valor hexadecimal do [\n] 
....................          putc(0x10); // valor hexadecimal do [\r] 
....................          c = toupper(c); 
....................          putc(c); 
....................          putc(0xD0); // valor hexadecimal do [\n] 
....................          putc(0x10); // valor hexadecimal do [\r] 
....................          */ 
....................           
....................          // CONVERTE UMA STRING PARA CAIXA BAIXA 
....................          // (TAMBÉM PODE-SE CONVERTER PARA CAIXA ALTA USANDO A FUNÇÃO str) 
....................          gets(c); 
00D8:  MOVLW  22
00D9:  MOVWF  04
00DA:  BCF    03.7
00DB:  DECF   04,F
00DC:  INCF   04,F
00DD:  BTFSS  0C.5
00DE:  GOTO   0DD
00DF:  MOVF   1A,W
00E0:  MOVWF  00
00E1:  MOVLW  0D
00E2:  SUBWF  00,W
00E3:  BTFSS  03.2
00E4:  GOTO   0DC
00E5:  CLRF   00
....................          puts(c); 
00E6:  MOVLW  22
00E7:  MOVWF  04
00E8:  BCF    03.7
00E9:  MOVLW  00
00EA:  IORWF  00,W
00EB:  BTFSC  03.2
00EC:  GOTO   0F3
00ED:  MOVF   00,W
00EE:  BTFSS  0C.4
00EF:  GOTO   0EE
00F0:  MOVWF  19
00F1:  INCF   04,F
00F2:  GOTO   0E9
00F3:  MOVLW  0D
00F4:  BTFSS  0C.4
00F5:  GOTO   0F4
00F6:  MOVWF  19
00F7:  MOVLW  0A
00F8:  BTFSS  0C.4
00F9:  GOTO   0F8
00FA:  MOVWF  19
....................          ptr = strlwr(c); // converte uma string por inteiro para caixa baixa 
00FB:  CLRF   2F
00FC:  MOVLW  22
00FD:  MOVWF  2E
00FE:  GOTO   066
00FF:  MOVF   79,W
0100:  MOVWF  2D
0101:  MOVF   78,W
0102:  MOVWF  2C
....................          puts(ptr); 
0103:  MOVF   2C,W
0104:  MOVWF  04
0105:  BCF    03.7
0106:  BTFSC  2D.0
0107:  BSF    03.7
0108:  MOVLW  00
0109:  IORWF  00,W
010A:  BTFSC  03.2
010B:  GOTO   112
010C:  MOVF   00,W
010D:  BTFSS  0C.4
010E:  GOTO   10D
010F:  MOVWF  19
0110:  INCF   04,F
0111:  GOTO   108
0112:  MOVLW  0D
0113:  BTFSS  0C.4
0114:  GOTO   113
0115:  MOVWF  19
0116:  MOVLW  0A
0117:  BTFSS  0C.4
0118:  GOTO   117
0119:  MOVWF  19
....................          strcpy(c, ptr); // copia o conteúdo de um ponteiro para o vetor de caracteres 
011A:  MOVF   2D,W
011B:  MOVWF  31
011C:  MOVF   2C,W
011D:  MOVWF  30
011E:  CLRF   2F
011F:  MOVLW  22
0120:  MOVWF  2E
0121:  MOVF   30,W
0122:  MOVWF  04
0123:  BCF    03.7
0124:  BTFSC  31.0
0125:  BSF    03.7
0126:  MOVF   00,W
0127:  MOVWF  32
0128:  MOVF   2E,W
0129:  MOVWF  04
012A:  BCF    03.7
012B:  BTFSC  2F.0
012C:  BSF    03.7
012D:  MOVF   32,W
012E:  MOVWF  00
012F:  MOVF   00,F
0130:  BTFSC  03.2
0131:  GOTO   135
0132:  INCF   2E,F
0133:  INCF   30,F
0134:  GOTO   121
....................          puts(c); 
0135:  MOVLW  22
0136:  MOVWF  04
0137:  BCF    03.7
0138:  MOVLW  00
0139:  IORWF  00,W
013A:  BTFSC  03.2
013B:  GOTO   142
013C:  MOVF   00,W
013D:  BTFSS  0C.4
013E:  GOTO   13D
013F:  MOVWF  19
0140:  INCF   04,F
0141:  GOTO   138
0142:  MOVLW  0D
0143:  BTFSS  0C.4
0144:  GOTO   143
0145:  MOVWF  19
0146:  MOVLW  0A
0147:  BTFSS  0C.4
0148:  GOTO   147
0149:  MOVWF  19
....................       } 
....................        
....................       printf("%u\r\n", RCSTA); 
014A:  MOVF   18,W
014B:  MOVWF  2E
014C:  MOVLW  1B
014D:  MOVWF  2F
014E:  CALL   019
014F:  MOVLW  0D
0150:  BTFSS  0C.4
0151:  GOTO   150
0152:  MOVWF  19
0153:  MOVLW  0A
0154:  BTFSS  0C.4
0155:  GOTO   154
0156:  MOVWF  19
....................        
....................       // para resetar 
....................       if(input(pin_b1)) { 
0157:  BSF    03.5
0158:  BSF    06.1
0159:  BCF    03.5
015A:  BTFSS  06.1
015B:  GOTO   15E
....................          RCSTA &= 0xEf; //operação binária 'E' bit a bit 
015C:  BCF    18.4
....................          RCSTA |= 0x10; //operação binária 'OU' bit a bit 
015D:  BSF    18.4
....................       } 
....................        
....................    } 
015E:  GOTO   0B3
....................    
.................... } 
....................  
....................  
015F:  SLEEP

Configuration Fuses:
   Word  1: 1F71   XT NOWDT PUT PROTECT NODEBUG BROWNOUT NOLVP NOCPD NOWRT
