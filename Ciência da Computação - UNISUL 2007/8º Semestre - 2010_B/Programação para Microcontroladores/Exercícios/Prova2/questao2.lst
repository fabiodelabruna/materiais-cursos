CCS PCM C Compiler, Version 4.038, 33467               11-nov-10 11:03

               Filename: C:\Users\Fabio Dela Bruna\Documents\Curso de Ciência da Computação\8º Semestre\Programação para Microcontroladores - Prof. Fernando Kestering Longo\Exercícios\Prova2\questao2.lst

               ROM used: 1247 words (15%)
                         Largest free fragment is 2048
               RAM used: 20 (5%) at main() level
                         32 (9%) worst case
               Stack:    3 locations

*
0000:  MOVLW  00
0001:  MOVWF  0A
0002:  GOTO   432
0003:  NOP
.................... #include <16F877A.h> 
.................... //////// Standard Header file for the PIC16F877A device //////////////// 
.................... #device PIC16F877A 
.................... #list 
....................  
.................... #fuses XT,PROTECT,BROWNOUT,NOWDT 
.................... #use delay(clock=4Mhz) 
*
041D:  MOVLW  2E
041E:  MOVWF  04
041F:  BCF    03.7
0420:  MOVF   00,W
0421:  BTFSC  03.2
0422:  GOTO   431
0423:  MOVLW  01
0424:  MOVWF  78
0425:  CLRF   77
0426:  DECFSZ 77,F
0427:  GOTO   426
0428:  DECFSZ 78,F
0429:  GOTO   425
042A:  MOVLW  4A
042B:  MOVWF  77
042C:  DECFSZ 77,F
042D:  GOTO   42C
042E:  GOTO   42F
042F:  DECFSZ 00,F
0430:  GOTO   423
0431:  RETLW  00
.................... #use rs232(baud=9600,xmit=pin_c6,rcv=pin_c7) 
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(int *)==1 
.................... #define ptrdiff_t int 
.................... #else 
.................... #define ptrdiff_t long 
.................... #endif 
....................  
.................... #define size_t int 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: float atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float atof(char * s); 
....................  
.................... /* Standard template: float atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... float atoe(char * s); 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int32 atoi32(char *s); 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, int8 base, char * s); 
....................  
.................... /* Standard template: signed long  atol(char * s) 
....................  * converts the initial portion of the string s to a signed long 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: float strtol(char * s,char *endptr) 
....................  * converts the initial portion of the string s to a float 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... float strtod(char *s,char *endptr); 
....................  
.................... /* Standard template: long strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr,signed int base); 
....................  
.................... /* Standard template: long strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... long strtoul(char *s,char *endptr,signed int base); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... long rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer,signed int denom); 
.................... ldiv_t ldiv(signed long numer,signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(int *)==1 
.................... #define ptrdiff_t int 
.................... #else 
.................... #define ptrdiff_t long 
.................... #endif 
....................  
.................... #define size_t int 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(int *)==1 
.................... #define ptrdiff_t int 
.................... #else 
.................... #define ptrdiff_t long 
.................... #endif 
....................  
.................... #define size_t int 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
....................      *s = *s2; 
....................   } 
....................   *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   int n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,int c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, int c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... int *strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, int c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... int *strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
0445:  BCF    03.5
0446:  CLRF   20
0447:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(int errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... int *strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer,signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer,signed long denom) 
.................... { 
....................    ldiv_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... float atof(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int sign = 0; 
....................    char c; 
....................    int ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int sign = 0; 
....................    int expsign = 0; 
....................    char c; 
....................    int ptr = 0; 
....................    int i; 
....................    float exp = 1.0; 
....................    int expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
02B0:  CLRF   33
....................    sign = 0; 
02B1:  CLRF   31
....................    base = 10; 
02B2:  MOVLW  0A
02B3:  MOVWF  32
....................    result = 0; 
02B4:  CLRF   30
02B5:  CLRF   2F
....................  
....................    if (!s) 
02B6:  MOVF   2D,W
02B7:  IORWF  2E,W
02B8:  BTFSS  03.2
02B9:  GOTO   2BE
....................       return 0; 
02BA:  MOVLW  00
02BB:  MOVWF  78
02BC:  MOVWF  79
02BD:  GOTO   3C2
....................    c = s[index++]; 
02BE:  MOVF   33,W
02BF:  INCF   33,F
02C0:  ADDWF  2D,W
02C1:  MOVWF  04
02C2:  BCF    03.7
02C3:  BTFSC  2E.0
02C4:  BSF    03.7
02C5:  MOVF   00,W
02C6:  MOVWF  34
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
02C7:  MOVF   34,W
02C8:  SUBLW  2D
02C9:  BTFSS  03.2
02CA:  GOTO   2D7
....................    { 
....................       sign = 1;         // Set the sign to negative 
02CB:  MOVLW  01
02CC:  MOVWF  31
....................       c = s[index++]; 
02CD:  MOVF   33,W
02CE:  INCF   33,F
02CF:  ADDWF  2D,W
02D0:  MOVWF  04
02D1:  BCF    03.7
02D2:  BTFSC  2E.0
02D3:  BSF    03.7
02D4:  MOVF   00,W
02D5:  MOVWF  34
....................    } 
....................    else if (c == '+') 
02D6:  GOTO   2E4
02D7:  MOVF   34,W
02D8:  SUBLW  2B
02D9:  BTFSS  03.2
02DA:  GOTO   2E4
....................    { 
....................       c = s[index++]; 
02DB:  MOVF   33,W
02DC:  INCF   33,F
02DD:  ADDWF  2D,W
02DE:  MOVWF  04
02DF:  BCF    03.7
02E0:  BTFSC  2E.0
02E1:  BSF    03.7
02E2:  MOVF   00,W
02E3:  MOVWF  34
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
02E4:  MOVF   34,W
02E5:  SUBLW  2F
02E6:  BTFSC  03.0
02E7:  GOTO   3B3
02E8:  MOVF   34,W
02E9:  SUBLW  39
02EA:  BTFSS  03.0
02EB:  GOTO   3B3
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
02EC:  MOVF   34,W
02ED:  SUBLW  30
02EE:  BTFSS  03.2
02EF:  GOTO   310
02F0:  MOVF   33,W
02F1:  ADDWF  2D,W
02F2:  MOVWF  04
02F3:  BCF    03.7
02F4:  BTFSC  2E.0
02F5:  BSF    03.7
02F6:  MOVF   00,W
02F7:  SUBLW  78
02F8:  BTFSC  03.2
02F9:  GOTO   304
02FA:  MOVF   33,W
02FB:  ADDWF  2D,W
02FC:  MOVWF  04
02FD:  BCF    03.7
02FE:  BTFSC  2E.0
02FF:  BSF    03.7
0300:  MOVF   00,W
0301:  SUBLW  58
0302:  BTFSS  03.2
0303:  GOTO   310
....................       { 
....................          base = 16; 
0304:  MOVLW  10
0305:  MOVWF  32
....................          index++; 
0306:  INCF   33,F
....................          c = s[index++]; 
0307:  MOVF   33,W
0308:  INCF   33,F
0309:  ADDWF  2D,W
030A:  MOVWF  04
030B:  BCF    03.7
030C:  BTFSC  2E.0
030D:  BSF    03.7
030E:  MOVF   00,W
030F:  MOVWF  34
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
0310:  MOVF   32,W
0311:  SUBLW  0A
0312:  BTFSS  03.2
0313:  GOTO   34A
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
0314:  MOVF   34,W
0315:  SUBLW  2F
0316:  BTFSC  03.0
0317:  GOTO   349
0318:  MOVF   34,W
0319:  SUBLW  39
031A:  BTFSS  03.0
031B:  GOTO   349
....................             result = 10*result + (c - '0'); 
031C:  CLRF   36
031D:  MOVLW  0A
031E:  MOVWF  35
031F:  MOVF   30,W
0320:  MOVWF  38
0321:  MOVF   2F,W
0322:  MOVWF  37
*
0337:  MOVLW  30
0338:  SUBWF  34,W
0339:  ADDWF  78,W
033A:  MOVWF  2F
033B:  MOVF   79,W
033C:  MOVWF  30
033D:  BTFSC  03.0
033E:  INCF   30,F
....................             c = s[index++]; 
033F:  MOVF   33,W
0340:  INCF   33,F
0341:  ADDWF  2D,W
0342:  MOVWF  04
0343:  BCF    03.7
0344:  BTFSC  2E.0
0345:  BSF    03.7
0346:  MOVF   00,W
0347:  MOVWF  34
....................          } 
0348:  GOTO   314
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
0349:  GOTO   3B3
034A:  MOVF   32,W
034B:  SUBLW  10
034C:  BTFSS  03.2
034D:  GOTO   3B3
....................       { 
....................          c = toupper(c); 
034E:  MOVF   34,W
034F:  SUBLW  60
0350:  BTFSC  03.0
0351:  GOTO   359
0352:  MOVF   34,W
0353:  SUBLW  7A
0354:  BTFSS  03.0
0355:  GOTO   359
0356:  MOVF   34,W
0357:  ANDLW  DF
0358:  GOTO   35A
0359:  MOVF   34,W
035A:  MOVWF  34
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
035B:  MOVF   34,W
035C:  SUBLW  2F
035D:  BTFSC  03.0
035E:  GOTO   363
035F:  MOVF   34,W
0360:  SUBLW  39
0361:  BTFSC  03.0
0362:  GOTO   36B
0363:  MOVF   34,W
0364:  SUBLW  40
0365:  BTFSC  03.0
0366:  GOTO   3B3
0367:  MOVF   34,W
0368:  SUBLW  46
0369:  BTFSS  03.0
036A:  GOTO   3B3
....................             if (c >= '0' && c <= '9') 
036B:  MOVF   34,W
036C:  SUBLW  2F
036D:  BTFSC  03.0
036E:  GOTO   388
036F:  MOVF   34,W
0370:  SUBLW  39
0371:  BTFSS  03.0
0372:  GOTO   388
....................                result = (result << 4) + (c - '0'); 
0373:  RLF    2F,W
0374:  MOVWF  35
0375:  RLF    30,W
0376:  MOVWF  36
0377:  RLF    35,F
0378:  RLF    36,F
0379:  RLF    35,F
037A:  RLF    36,F
037B:  RLF    35,F
037C:  RLF    36,F
037D:  MOVLW  F0
037E:  ANDWF  35,F
037F:  MOVLW  30
0380:  SUBWF  34,W
0381:  ADDWF  35,W
0382:  MOVWF  2F
0383:  MOVF   36,W
0384:  MOVWF  30
0385:  BTFSC  03.0
0386:  INCF   30,F
....................             else 
0387:  GOTO   39D
....................                result = (result << 4) + (c - 'A' + 10); 
0388:  RLF    2F,W
0389:  MOVWF  35
038A:  RLF    30,W
038B:  MOVWF  36
038C:  RLF    35,F
038D:  RLF    36,F
038E:  RLF    35,F
038F:  RLF    36,F
0390:  RLF    35,F
0391:  RLF    36,F
0392:  MOVLW  F0
0393:  ANDWF  35,F
0394:  MOVLW  41
0395:  SUBWF  34,W
0396:  ADDLW  0A
0397:  ADDWF  35,W
0398:  MOVWF  2F
0399:  MOVF   36,W
039A:  MOVWF  30
039B:  BTFSC  03.0
039C:  INCF   30,F
....................  
....................             c = s[index++];c = toupper(c); 
039D:  MOVF   33,W
039E:  INCF   33,F
039F:  ADDWF  2D,W
03A0:  MOVWF  04
03A1:  BCF    03.7
03A2:  BTFSC  2E.0
03A3:  BSF    03.7
03A4:  MOVF   00,W
03A5:  MOVWF  34
03A6:  SUBLW  60
03A7:  BTFSC  03.0
03A8:  GOTO   3B0
03A9:  MOVF   34,W
03AA:  SUBLW  7A
03AB:  BTFSS  03.0
03AC:  GOTO   3B0
03AD:  MOVF   34,W
03AE:  ANDLW  DF
03AF:  GOTO   3B1
03B0:  MOVF   34,W
03B1:  MOVWF  34
....................          } 
03B2:  GOTO   35B
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
03B3:  MOVF   32,W
03B4:  SUBLW  0A
03B5:  BTFSS  03.2
03B6:  GOTO   3BE
03B7:  DECFSZ 31,W
03B8:  GOTO   3BE
....................       result = -result; 
03B9:  COMF   2F,F
03BA:  COMF   30,F
03BB:  INCF   2F,F
03BC:  BTFSC  03.2
03BD:  INCF   30,F
....................  
....................    return(result); 
03BE:  MOVF   2F,W
03BF:  MOVWF  78
03C0:  MOVF   30,W
03C1:  MOVWF  79
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... char * itoa(signed int32 num, int8 base, char *s) 
.................... { 
....................      int32 temp=1; 
....................      int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtod(char *s,char *endptr) { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int sign = 0, point = 0; 
....................    char c; 
....................    int ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... long strtoul(char *s,char *endptr,signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr,signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... long rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned long)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... typedef signed int (*_Cmpfun)(char * p1,char * p2); 
....................  
.................... void qsort(char * qdata, int qitems, int qsize, _Cmpfun cmp) { 
....................    int m,j,i,l; 
....................    short done; 
....................    BYTE t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=TRUE; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = FALSE; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... void setarBits(); 
.................... void setarRolagem(); 
....................  
.................... char bit = ' '; 
*
0448:  MOVLW  20
0449:  MOVWF  26
.................... char rolar = ' '; 
044A:  MOVWF  27
.................... byte valor = 0b00000000; 
044B:  CLRF   28
.................... long i = 0; 
044C:  CLRF   29
044D:  CLRF   2A
....................  
.................... void main(){ 
*
0432:  CLRF   04
0433:  BCF    03.7
0434:  MOVLW  1F
0435:  ANDWF  03,F
0436:  MOVLW  19
0437:  BSF    03.5
0438:  MOVWF  19
0439:  MOVLW  A6
043A:  MOVWF  18
043B:  MOVLW  90
043C:  BCF    03.5
043D:  MOVWF  18
043E:  BSF    03.5
043F:  BSF    1F.0
0440:  BSF    1F.1
0441:  BSF    1F.2
0442:  BCF    1F.3
0443:  MOVLW  07
0444:  MOVWF  1C
....................  
....................    byte valorAnt = 0b00000000; 
*
044E:  CLRF   2B
....................    char opcao = 'S'; 
044F:  MOVLW  53
0450:  MOVWF  2C
....................  
....................    while(true){ 
....................       if(opcao == 'S'){ 
0451:  MOVF   2C,W
0452:  SUBLW  53
0453:  BTFSS  03.2
0454:  GOTO   46F
....................          output_b(0x00); 
0455:  BSF    03.5
0456:  CLRF   06
0457:  BCF    03.5
0458:  CLRF   06
....................          valor = 0b00000000; 
0459:  CLRF   28
....................          printf("\r\n\r\nValor inicial da porta: %d", valor); 
045A:  CLRF   2D
045B:  MOVF   2D,W
045C:  CALL   004
045D:  INCF   2D,F
045E:  MOVWF  77
045F:  MOVF   77,W
0460:  BTFSS  0C.4
0461:  GOTO   460
0462:  MOVWF  19
0463:  MOVLW  1C
0464:  SUBWF  2D,W
0465:  BTFSS  03.2
0466:  GOTO   45B
0467:  MOVF   28,W
0468:  MOVWF  2E
0469:  MOVLW  1F
046A:  MOVWF  2F
046B:  GOTO   1C3
....................          setarBits(); 
046C:  GOTO   266
....................          setarRolagem();    
046D:  CALL   3EC
....................       } else { 
046E:  GOTO   470
....................          setarRolagem(); 
046F:  CALL   3EC
....................       } 
....................        
....................        
....................       if(rolar == 'E'){            
0470:  MOVF   27,W
0471:  SUBLW  45
0472:  BTFSS  03.2
0473:  GOTO   49A
....................          valorAnt = valor; 
0474:  MOVF   28,W
0475:  MOVWF  2B
....................          do{ 
....................             rotate_left(&valor, 1); 
0476:  RLF    28,W
0477:  RLF    28,F
....................             printf("\r\nRolando Bit para Esquerda: %u", valor); 
0478:  CLRF   2D
0479:  MOVF   2D,W
047A:  CALL   027
047B:  INCF   2D,F
047C:  MOVWF  77
047D:  MOVF   77,W
047E:  BTFSS  0C.4
047F:  GOTO   47E
0480:  MOVWF  19
0481:  MOVLW  1D
0482:  SUBWF  2D,W
0483:  BTFSS  03.2
0484:  GOTO   479
0485:  MOVF   28,W
0486:  MOVWF  2E
0487:  MOVLW  1B
0488:  MOVWF  2F
0489:  CALL   22E
....................             output_b(valor); 
048A:  BSF    03.5
048B:  CLRF   06
048C:  BCF    03.5
048D:  MOVF   28,W
048E:  MOVWF  06
....................             delay_ms(1000); 
048F:  MOVLW  04
0490:  MOVWF  2D
0491:  MOVLW  FA
0492:  MOVWF  2E
0493:  CALL   41D
0494:  DECFSZ 2D,F
0495:  GOTO   491
....................          }while(valorAnt != valor); 
0496:  MOVF   28,W
0497:  SUBWF  2B,W
0498:  BTFSS  03.2
0499:  GOTO   476
....................       }  
....................       if (rolar == 'D'){ 
049A:  MOVF   27,W
049B:  SUBLW  44
049C:  BTFSS  03.2
049D:  GOTO   4C4
....................          valorAnt = valor; 
049E:  MOVF   28,W
049F:  MOVWF  2B
....................          do{ 
....................             rotate_right(&valor, 1); 
04A0:  RRF    28,W
04A1:  RRF    28,F
....................             printf("\r\nRolando Bit para Direita: %u", valor); 
04A2:  CLRF   2D
04A3:  MOVF   2D,W
04A4:  CALL   04B
04A5:  INCF   2D,F
04A6:  MOVWF  77
04A7:  MOVF   77,W
04A8:  BTFSS  0C.4
04A9:  GOTO   4A8
04AA:  MOVWF  19
04AB:  MOVLW  1C
04AC:  SUBWF  2D,W
04AD:  BTFSS  03.2
04AE:  GOTO   4A3
04AF:  MOVF   28,W
04B0:  MOVWF  2E
04B1:  MOVLW  1B
04B2:  MOVWF  2F
04B3:  CALL   22E
....................             output_b(valor); 
04B4:  BSF    03.5
04B5:  CLRF   06
04B6:  BCF    03.5
04B7:  MOVF   28,W
04B8:  MOVWF  06
....................             delay_ms(1000); 
04B9:  MOVLW  04
04BA:  MOVWF  2D
04BB:  MOVLW  FA
04BC:  MOVWF  2E
04BD:  CALL   41D
04BE:  DECFSZ 2D,F
04BF:  GOTO   4BB
....................          }while(valorAnt != valor); 
04C0:  MOVF   28,W
04C1:  SUBWF  2B,W
04C2:  BTFSS  03.2
04C3:  GOTO   4A0
....................       } 
....................  
....................       do{ 
....................          printf("\r\nDeseja modificar os valores atuais? Sim [S] / Nao [N]"); 
04C4:  CLRF   2D
04C5:  MOVF   2D,W
04C6:  CALL   06E
04C7:  INCF   2D,F
04C8:  MOVWF  77
04C9:  MOVF   77,W
04CA:  BTFSS  0C.4
04CB:  GOTO   4CA
04CC:  MOVWF  19
04CD:  MOVLW  37
04CE:  SUBWF  2D,W
04CF:  BTFSS  03.2
04D0:  GOTO   4C5
....................          opcao = getc(); 
04D1:  BTFSS  0C.5
04D2:  GOTO   4D1
04D3:  MOVF   1A,W
04D4:  MOVWF  2C
....................       }while(opcao != 'N' && opcao != 'S')   ; 
04D5:  MOVF   2C,W
04D6:  SUBLW  4E
04D7:  BTFSC  03.2
04D8:  GOTO   4DD
04D9:  MOVF   2C,W
04DA:  SUBLW  53
04DB:  BTFSS  03.2
04DC:  GOTO   4C4
....................  
....................    } 
04DD:  GOTO   451
.................... } 
....................  
.................... void setarBits(){ 
....................       printf("\r\nDigite o numero do bit a ser setado pra true: "); 
*
0266:  CLRF   2D
0267:  MOVF   2D,W
0268:  CALL   0AA
0269:  INCF   2D,F
026A:  MOVWF  77
026B:  MOVF   77,W
026C:  BTFSS  0C.4
026D:  GOTO   26C
026E:  MOVWF  19
026F:  MOVLW  30
0270:  SUBWF  2D,W
0271:  BTFSS  03.2
0272:  GOTO   267
*
04DE:  SLEEP
....................       gets(bit); 
*
0273:  MOVF   26,W
0274:  MOVWF  04
0275:  BCF    03.7
0276:  BTFSC  27.0
0277:  BSF    03.7
0278:  DECF   04,F
0279:  INCF   04,F
027A:  BTFSS  0C.5
027B:  GOTO   27A
027C:  MOVF   1A,W
027D:  MOVWF  00
027E:  MOVLW  0D
027F:  SUBWF  00,W
0280:  BTFSS  03.2
0281:  GOTO   279
0282:  CLRF   00
....................       printf("\r\nSetado pino %s para true!", bit); 
0283:  CLRF   2D
0284:  MOVF   2D,W
0285:  CALL   0DF
0286:  INCF   2D,F
0287:  MOVWF  77
0288:  MOVF   77,W
0289:  BTFSS  0C.4
028A:  GOTO   289
028B:  MOVWF  19
028C:  MOVLW  0E
028D:  SUBWF  2D,W
028E:  BTFSS  03.2
028F:  GOTO   284
0290:  MOVF   26,W
0291:  MOVWF  04
0292:  BCF    03.7
0293:  BTFSC  27.0
0294:  BSF    03.7
0295:  MOVLW  00
0296:  IORWF  00,W
0297:  BTFSC  03.2
0298:  GOTO   29F
0299:  MOVF   00,W
029A:  BTFSS  0C.4
029B:  GOTO   29A
029C:  MOVWF  19
029D:  INCF   04,F
029E:  GOTO   295
029F:  MOVLW  10
02A0:  MOVWF  30
02A1:  MOVF   30,W
02A2:  CALL   0DF
02A3:  INCF   30,F
02A4:  MOVWF  77
02A5:  MOVF   77,W
02A6:  BTFSS  0C.4
02A7:  GOTO   2A6
02A8:  MOVWF  19
02A9:  MOVLW  1B
02AA:  SUBWF  30,W
02AB:  BTFSS  03.2
02AC:  GOTO   2A1
....................       i=atol(bit); 
02AD:  CLRF   2E
02AE:  MOVF   26,W
02AF:  MOVWF  2D
*
03C2:  MOVF   79,W
03C3:  MOVWF  2A
03C4:  MOVF   78,W
03C5:  MOVWF  29
....................       bit_set(valor, i); 
03C6:  MOVLW  01
03C7:  MOVWF  77
03C8:  MOVF   29,W
03C9:  MOVWF  78
03CA:  BTFSC  03.2
03CB:  GOTO   3D0
03CC:  BCF    03.0
03CD:  RLF    77,F
03CE:  DECFSZ 78,F
03CF:  GOTO   3CC
03D0:  MOVF   77,W
03D1:  IORWF  28,F
....................       printf("\r\nValor atual da porta: %u", valor); 
03D2:  CLRF   2D
03D3:  MOVF   2D,W
03D4:  CALL   0FF
03D5:  INCF   2D,F
03D6:  MOVWF  77
03D7:  MOVF   77,W
03D8:  BTFSS  0C.4
03D9:  GOTO   3D8
03DA:  MOVWF  19
03DB:  MOVLW  18
03DC:  SUBWF  2D,W
03DD:  BTFSS  03.2
03DE:  GOTO   3D3
03DF:  MOVF   28,W
03E0:  MOVWF  2E
03E1:  MOVLW  1B
03E2:  MOVWF  2F
03E3:  CALL   22E
....................       output_b(valor); 
03E4:  BSF    03.5
03E5:  CLRF   06
03E6:  BCF    03.5
03E7:  MOVF   28,W
03E8:  MOVWF  06
.................... } 
03E9:  BCF    0A.3
03EA:  BCF    0A.4
03EB:  GOTO   46D (RETURN)
....................  
.................... void setarRolagem(){ 
....................       printf("\r\nDeseja rolar o bit para direita [D] ou para esquerda [E]? "); 
03EC:  CLRF   2D
03ED:  MOVF   2D,W
03EE:  CALL   11E
03EF:  INCF   2D,F
03F0:  MOVWF  77
03F1:  MOVF   77,W
03F2:  BTFSS  0C.4
03F3:  GOTO   3F2
03F4:  MOVWF  19
03F5:  MOVLW  3C
03F6:  SUBWF  2D,W
03F7:  BTFSS  03.2
03F8:  GOTO   3ED
....................       rolar = getc(); 
03F9:  BTFSS  0C.5
03FA:  GOTO   3F9
03FB:  MOVF   1A,W
03FC:  MOVWF  27
....................       if(rolar == 'E') 
03FD:  MOVF   27,W
03FE:  SUBLW  45
03FF:  BTFSS  03.2
0400:  GOTO   40F
....................          printf("\r\nSetado rolagem para Esquerda [E]!"); 
0401:  CLRF   2D
0402:  MOVF   2D,W
0403:  CALL   15F
0404:  INCF   2D,F
0405:  MOVWF  77
0406:  MOVF   77,W
0407:  BTFSS  0C.4
0408:  GOTO   407
0409:  MOVWF  19
040A:  MOVLW  23
040B:  SUBWF  2D,W
040C:  BTFSS  03.2
040D:  GOTO   402
....................       else  
040E:  GOTO   41C
....................          printf("\r\nSetado rolagem para Direita [D]!");  
040F:  CLRF   2D
0410:  MOVF   2D,W
0411:  CALL   187
0412:  INCF   2D,F
0413:  MOVWF  77
0414:  MOVF   77,W
0415:  BTFSS  0C.4
0416:  GOTO   415
0417:  MOVWF  19
0418:  MOVLW  22
0419:  SUBWF  2D,W
041A:  BTFSS  03.2
041B:  GOTO   410
....................        
.................... } 
041C:  RETLW  00
....................  

Configuration Fuses:
   Word  1: 1F71   XT NOWDT PUT PROTECT NODEBUG BROWNOUT NOLVP NOCPD NOWRT
