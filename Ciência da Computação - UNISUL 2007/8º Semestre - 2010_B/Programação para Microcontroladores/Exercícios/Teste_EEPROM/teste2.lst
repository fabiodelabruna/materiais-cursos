CCS PCM C Compiler, Version 4.093, 5065               26-Aðu-10 12:20

               Filename: C:\PIC C Compiler PCWHD_4.093\PIC\Exercícios\Teste_EEPROM\teste2.lst

               ROM used: 302 words (4%)
                         Largest free fragment is 2048
               RAM used: 10 (3%) at main() level
                         19 (5%) worst case
               Stack:    1 locations

*
0000:  MOVLW  00
0001:  MOVWF  0A
0002:  GOTO   0D3
0003:  NOP
.................... #include <16f877a.h> 
.................... //////// Standard Header file for the PIC16F877A device //////////////// 
.................... #device PIC16F877A 
.................... #list 
....................  
.................... #fuses HS, PROTECT, BROWNOUT 
.................... #use delay(clock=4Mhz) 
.................... #use rs232(baud=9600, xmit=pin_c6, rcv=pin_c7) 
.................... #include <internal_eeprom.c> 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... ////                          internal_eeprom.c                             //// 
.................... ////                                                                        //// 
.................... ////       Utilities to write various data types to internal eeprom         //// 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                        //// 
.................... ////   void write_int1_eeprom(address, int8 bitPosition, int1 data)         //// 
.................... ////     Call to write one bit of data                                      //// 
.................... ////                                                                        //// 
.................... ////   int1 read_int1_eeprom(address, int8 bitPosition)                     //// 
.................... ////     Call to read one bit of data                                       //// 
.................... ////                                                                        //// 
.................... ////                                                                        //// 
.................... ////   void write_int16_eeprom(address, int16 data)                         //// 
.................... ////     Call to write a 16 bit integer                                     //// 
.................... ////                                                                        //// 
.................... ////   void write_int16_eeprom(address, int16 data)                         //// 
.................... ////     Call to read a 16 bit integer                                      //// 
.................... ////                                                                        //// 
.................... ////                                                                        //// 
.................... ////   void write_int32_eeprom(address, int32 data)                         //// 
.................... ////     Call to write a 32 bit integer                                     //// 
.................... ////                                                                        //// 
.................... ////   int16 read_int32_eeprom(address)                                     //// 
.................... ////     Call to read a 32 bit integer                                      //// 
.................... ////                                                                        //// 
.................... ////                                                                        //// 
.................... ////   void write_float_eeprom(address, float data)                         //// 
.................... ////     Call to write a floating point number                              //// 
.................... ////                                                                        //// 
.................... ////   float read_float_eeprom(address)                                     //// 
.................... ////     Call to read a floating point number                               //// 
.................... ////                                                                        //// 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2004 Custom Computer Services               //// 
.................... //// This source code may only be used by licensed users of the CCS C       //// 
.................... //// compiler.  This source code may only be distributed to other licensed  //// 
.................... //// users of the CCS C compiler.  No other use, reproduction or            //// 
.................... //// distribution is permitted without written permission. Derivative       //// 
.................... //// programs created using this software in object code form are not       //// 
.................... //// restricted in any way.                                                 //// 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef INTERNAL_EEPROM_UTILITIES 
.................... #define INTERNAL_EEPROM_UTILITIES 
....................  
.................... // Used to adjust the address range 
.................... #ifndef INT_EEPROM_ADDRESS 
.................... #define INT_EEPROM_ADDRESS  int8 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... //// Internal EEPROM Functions 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... // Purpose:    Write one bit to internal eeprom 
.................... // Inputs:     1) An eeprom address 
.................... //             2) The bit position (LSB == 0) 
.................... //             3) The bit to write 
.................... // Outputs:    None 
.................... void write_int1_eeprom(INT_EEPROM_ADDRESS address, int8 bitPosition, int1 data) 
.................... { 
....................    int8 stored_data; 
....................  
....................    stored_data = read_eeprom(address); 
....................  
....................    if(data) 
....................    { 
....................       bit_set(stored_data, bitPosition); 
....................    } 
....................    else 
....................    { 
....................       bit_clear(stored_data, bitPosition); 
....................    } 
....................  
....................    write_eeprom(address, stored_data); 
.................... } 
....................  
....................  
.................... // Purpose:    Read one bit from internal eeprom 
.................... // Inputs:     1) An eeprom address 
.................... //             2) The bit position (LSB == 0) 
.................... // Outputs:    The bit read from internal eeprom 
.................... int1 read_int1_eeprom(INT_EEPROM_ADDRESS address, int8 bitPosition) 
.................... { 
....................    return bit_test(read_eeprom(address), bitPosition); 
.................... } 
....................  
....................  
.................... // Purpose:    Write a 16 bit number to internal eeprom 
.................... // Inputs:     1) An eeprom address 
.................... //             2) The 16 bit number to write to internal eeprom 
.................... // Outputs:    None 
.................... void write_int16_eeprom(INT_EEPROM_ADDRESS address, int16 data) 
.................... { 
....................    int8 i; 
....................  
....................    for(i = 0; i < 2; ++i) 
*
0013:  CLRF   26
0014:  MOVF   26,W
0015:  SUBLW  01
0016:  BTFSS  03.0
0017:  GOTO   04B
....................    { 
....................      write_eeprom(address + i, *((int8 *)(&data) + i)); 
0018:  MOVF   26,W
0019:  ADDWF  23,W
001A:  MOVWF  27
001B:  CLRF   29
001C:  MOVLW  24
001D:  MOVWF  28
001E:  MOVF   26,W
001F:  ADDWF  28,W
0020:  MOVWF  78
0021:  MOVF   29,W
0022:  MOVWF  7A
0023:  BTFSC  03.0
0024:  INCF   7A,F
0025:  MOVF   78,W
0026:  MOVWF  04
0027:  BCF    03.7
0028:  BTFSC  7A.0
0029:  BSF    03.7
002A:  MOVF   00,W
002B:  MOVWF  28
002C:  MOVF   27,W
002D:  BSF    03.6
002E:  MOVWF  0D
002F:  BCF    03.6
0030:  MOVF   28,W
0031:  BSF    03.6
0032:  MOVWF  0C
0033:  BSF    03.5
0034:  BCF    0C.7
0035:  BSF    0C.2
0036:  BCF    03.5
0037:  BCF    03.6
0038:  MOVF   0B,W
0039:  MOVWF  77
003A:  BCF    0B.7
003B:  BSF    03.5
003C:  BSF    03.6
003D:  MOVLW  55
003E:  MOVWF  0D
003F:  MOVLW  AA
0040:  MOVWF  0D
0041:  BSF    0C.1
0042:  BTFSC  0C.1
0043:  GOTO   042
0044:  BCF    0C.2
0045:  MOVF   77,W
0046:  BCF    03.5
0047:  BCF    03.6
0048:  IORWF  0B,F
....................    } 
0049:  INCF   26,F
004A:  GOTO   014
.................... } 
004B:  BCF    0A.3
004C:  BCF    0A.4
004D:  GOTO   0FD (RETURN)
....................  
....................  
.................... // Purpose:    Read a 16 bit number from internal eeprom 
.................... // Inputs:     An eeprom address 
.................... // Outputs:    The 16 bit number read from internal eeprom 
.................... int16 read_int16_eeprom(INT_EEPROM_ADDRESS address) 
.................... { 
....................    int8  i; 
....................    int16 data; 
....................  
....................    for(i = 0; i < 2; ++i) 
004E:  CLRF   24
004F:  MOVF   24,W
0050:  SUBLW  01
0051:  BTFSS  03.0
0052:  GOTO   071
....................    { 
....................      *((int8 *)(&data) + i) = read_eeprom(address + i); 
0053:  CLRF   28
0054:  MOVLW  25
0055:  MOVWF  27
0056:  MOVF   24,W
0057:  ADDWF  27,W
0058:  MOVWF  78
0059:  MOVF   28,W
005A:  MOVWF  7A
005B:  BTFSC  03.0
005C:  INCF   7A,F
005D:  MOVF   78,W
005E:  MOVWF  04
005F:  BCF    03.7
0060:  BTFSC  7A.0
0061:  BSF    03.7
0062:  MOVF   24,W
0063:  ADDWF  23,W
0064:  MOVWF  29
0065:  MOVF   29,W
0066:  BSF    03.6
0067:  MOVWF  0D
0068:  BSF    03.5
0069:  BCF    0C.7
006A:  BSF    0C.0
006B:  BCF    03.5
006C:  MOVF   0C,W
006D:  MOVWF  00
....................    } 
006E:  BCF    03.6
006F:  INCF   24,F
0070:  GOTO   04F
....................  
....................    return(data); 
0071:  MOVF   25,W
0072:  MOVWF  78
0073:  MOVF   26,W
0074:  MOVWF  79
.................... } 
0075:  BCF    0A.3
0076:  BCF    0A.4
0077:  GOTO   116 (RETURN)
....................  
....................  
.................... // Purpose:    Write a 32 bit integer to internal eeprom 
.................... // Inputs:     1) An eeprom address 
.................... //             2) The 32 bit number to write to internal eeprom 
.................... // Outputs:    None 
.................... void write_int32_eeprom(INT_EEPROM_ADDRESS address, int32 data) 
.................... { 
....................    int8 i; 
....................  
....................    for(i = 0; i < 4; ++i) 
....................    { 
....................      write_eeprom(address + i, *((int8 *)(&data) + i)); 
....................    } 
.................... } 
....................  
....................  
.................... // Purpose:    Read a 32 bit integer from internal eeprom 
.................... // Inputs:     An eeprom address 
.................... // Outputs:    The 32 bit integer read from internal eeprom 
.................... int32 read_int32_eeprom(INT_EEPROM_ADDRESS address) 
.................... { 
....................    int8  i; 
....................    int32 data; 
....................  
....................    for(i = 0; i < 4; ++i) 
....................    { 
....................      *((int8 *)(&data) + i) = read_eeprom(address + i); 
....................    } 
....................  
....................    return data; 
.................... } 
....................  
....................  
.................... // Purpose:    Write a floating point number to internal eeprom 
.................... // Inputs:     1) An eeprom address. Four eeprom locations will be used. 
.................... //             2) The floating point number to write to internal eeprom 
.................... // Outputs:    None 
.................... void write_float_eeprom(INT_EEPROM_ADDRESS address, float data) 
.................... { 
....................    int8 i; 
....................  
....................    for(i = 0; i < 4; ++i) 
....................    { 
....................      write_eeprom(address + i, *((int8 *)(&data) + i)); 
....................    } 
.................... } 
....................  
....................  
.................... // Purpose:    Read a floating point number from internal eeprom 
.................... // Inputs:     An eeprom address 
.................... // Outputs:    The floating point number read from the internal eeprom 
.................... float read_float_eeprom(INT_EEPROM_ADDRESS address) 
.................... { 
....................    int8 i; 
....................    float data; 
....................  
....................    for(i = 0; i < 4; ++i) 
....................    { 
....................      *((int8 *)(&data) + i) = read_eeprom(address + i); 
....................    } 
....................  
....................    return data; 
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... void main() { 
*
00D3:  CLRF   04
00D4:  BCF    03.7
00D5:  MOVLW  1F
00D6:  ANDWF  03,F
00D7:  MOVLW  19
00D8:  BSF    03.5
00D9:  MOVWF  19
00DA:  MOVLW  A6
00DB:  MOVWF  18
00DC:  MOVLW  90
00DD:  BCF    03.5
00DE:  MOVWF  18
00DF:  BSF    03.5
00E0:  BSF    1F.0
00E1:  BSF    1F.1
00E2:  BSF    1F.2
00E3:  BCF    1F.3
00E4:  MOVLW  07
00E5:  MOVWF  1C
....................    char c[]; 
....................     
....................    while(true) { 
....................     
....................       if(kbhit()) { 
00E6:  BCF    03.5
00E7:  BTFSS  0C.5
00E8:  GOTO   0F0
....................          c=getc(); 
00E9:  BTFSS  0C.5
00EA:  GOTO   0E9
00EB:  MOVF   1A,W
00EC:  CLRF   7A
00ED:  MOVWF  21
00EE:  MOVF   7A,W
00EF:  MOVWF  22
....................       } 
....................        
....................       if(c == 'e') { // escrever 
00F0:  MOVF   21,W
00F1:  SUBLW  65
00F2:  BTFSS  03.2
00F3:  GOTO   10D
00F4:  MOVF   22,F
00F5:  BTFSS  03.2
00F6:  GOTO   10D
....................          write_int16_eeprom(0, 300); 
00F7:  CLRF   23
00F8:  MOVLW  01
00F9:  MOVWF  25
00FA:  MOVLW  2C
00FB:  MOVWF  24
00FC:  GOTO   013
....................          printf("Escreveu\r\n"); 
00FD:  CLRF   23
00FE:  MOVF   23,W
00FF:  CALL   004
0100:  INCF   23,F
0101:  MOVWF  77
0102:  MOVF   77,W
0103:  BTFSS  0C.4
0104:  GOTO   103
0105:  MOVWF  19
0106:  MOVLW  0A
0107:  SUBWF  23,W
0108:  BTFSS  03.2
0109:  GOTO   0FE
....................          c=' '; 
010A:  CLRF   22
010B:  MOVLW  20
010C:  MOVWF  21
....................       } 
....................        
....................       if(c == 'l') { //ler 
010D:  MOVF   21,W
010E:  SUBLW  6C
010F:  BTFSS  03.2
0110:  GOTO   12C
0111:  MOVF   22,F
0112:  BTFSS  03.2
0113:  GOTO   12C
....................          printf("%lu\r\n", read_int16_eeprom(0)); 
0114:  CLRF   23
0115:  GOTO   04E
0116:  MOVF   79,W
0117:  MOVWF  24
0118:  MOVF   78,W
0119:  MOVWF  23
011A:  MOVLW  10
011B:  MOVWF  04
011C:  MOVF   79,W
011D:  MOVWF  26
011E:  MOVF   78,W
011F:  MOVWF  25
0120:  GOTO   078
0121:  MOVLW  0D
0122:  BTFSS  0C.4
0123:  GOTO   122
0124:  MOVWF  19
0125:  MOVLW  0A
0126:  BTFSS  0C.4
0127:  GOTO   126
0128:  MOVWF  19
....................          c=' '; 
0129:  CLRF   22
012A:  MOVLW  20
012B:  MOVWF  21
....................       } 
....................    }   
012C:  GOTO   0E7
.................... } 
012D:  SLEEP

Configuration Fuses:
   Word  1: 1F72   HS NOWDT PUT PROTECT NODEBUG BROWNOUT NOLVP NOCPD NOWRT
