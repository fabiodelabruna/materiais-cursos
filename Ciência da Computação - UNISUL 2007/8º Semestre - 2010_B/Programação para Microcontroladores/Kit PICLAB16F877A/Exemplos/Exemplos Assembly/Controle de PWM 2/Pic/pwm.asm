;*	*	*	*	*	*	*	*	*	*
;*			  Programação em Assembly			*
;*	       EXEMPLO11: SISTEMA DE CONTROLE DE TEMPERATURA		*
;*		     APOSTILA MÓDULO B  -  PIC16F877A			*
;*		      CERNE TECNOLOGIA E TREINAMENTO			*
;*	    VERSÃO 1.0				DATA:14/05/2005		*
;*									*
;*	*	*	*	*	*	*	*	*	*

;*	*	*	*	*	*	*	*	*	*
;*			 OBJETIVO DO ARQUIVO FONTE			*
;*									*
;*  CONTROLAR A ROTAÇÃO DO VENTILADOR EXTERNO E DO RESITOR DE POTÊNCIA	*
;*  A PARTIR DO CONTROLE QUE SERÁ FEITO NO TECLADO MATRICIAL. O VALOR   *
;*    AJUSTADO SERÁ APRESENTADO NO DISPLAY E AJUSTADO NO MÓDULO CCP	*
;*									*
;*	*	*	*	*	*	*	*	*	*

 #INCLUDE <P16F877.INC> 	;ARQUIVO PADRÃO PARA PIC16F877A
 __CONFIG _CP_OFF & _XT_OSC & _PWRTE_ON & _LVP_OFF & _WDT_ON & _BODEN_OFF & _CPD_OFF & _DEBUG_OFF
 	
 	;NESTE PONTO É INFORMADO A CONFIGURAÇÃO DA MÁQUINA, OU SEJA, SE TERÁ
 	;CÓDIGO DE PROTEÇÃO OU O TIPO DE CRISTAL QUE SERÁ UTILIZADO	

 	;CONFIGURAÇÃO DA MÁQUINA
 	; CODE PROTECT		        -> DESLIGADO
 	; OSCILADOR    		        -> CRISTAL OU RESSONADOR
 	; POWER-UP     		        -> LIGADO
 	; DEBUF 		        -> DESLIGADO		
 	; PROGRAMAÇÃO EM BAIXA VOLTAGEM -> DESLIGADO
	; WATCH DOG			-> LIGADO
	; BROWN-OUT RESET		-> DESLIGADO
	; PROTEÇÃO DE EEPROM		-> DESLIGADO
	 	
;*	*	*	*	*	*	*	*	*	*
;*			   PAGINAÇÃO DE MEMÓRIA				*
;*	*	*	*	*	*	*	*	*	*

; AQUI CRIAREMOS UM PSEUDÔNIMO PARA UM COMANDO. POR EXEMPLO, O COMANDO
; "BCF STATUS,RP0" PODE SER SUBSTITUÍDO SEM PROBLEMAS POR "BANK0". O 
; COMPILADOR IRÁ SUBSTITUIR INTERNAMENTE "BANK0" POR "BCF STATUS,RP0".
; ESTA APLICAÇÃO É VÁLIDA PARA OUTROS TIPOS DE COMANDOS

#DEFINE	BANK0	BCF	STATUS,RP0	; ESCOLHE BANCO DE MEMÓRIA 0
#DEFINE	BANK1	BSF	STATUS,RP0	; ESCOLHE BANCO DE MEMÓRIA 1

;*	*	*	*	*	*	*	*	*	*
;*			     DEFINIÇÃO DE RAM				*
;*	*	*	*	*	*	*	*	*	*

; AQUI IREMOS CRIAR AS VARIÁVEIS DO NOSSO SISTEMA

	CBLOCK 0x20	 	; INÍCIO DO BLOCO DE RAM(GPR)
		TEMPO1  	; VARIÁVEL DA ROTINA DE TEMPO		
		TEMPO2   	; VARIÁVEL DA ROTINA DE TEMPO				
		TECLADO1 	; VARIÁVEL PARA MARCAR AS TECLAS  
		TECLADO2 	; VARIÁVEL PARA MARCAR AS TECLAS
		INDICE	 	; VARIÁVEL DE ÍNDICE
		TEMP	 	; VARIÁVEL TEMPORÁRIA		
		ARG0	 	; PARÂMETRO DE ENTRADA PARA ROTINA DE
		ARG1	 	; MULTIPLICAÇÃO E DIVISÃO
		ARG2
		MUL1		; REGISTRADOR AUXILIAR PARA
		MUL0		; A ROTINA DE MULTIPLICAÇÃO/DIVISÃO
		VEZES_TIMER2	; VARIÁVEL AUXILIAR PARA INTERRUPÇÃO DE TIMER2
		FLAGS		; VARIÁVEL PARA DECLARAÇÃO DE FLAGS
		CONTADOR_LSB	; VARIÁVEL PARA ARMAZENAR 
		CONTADOR_MSB	; A CONTAGEM DO RX DE IR	
		CONVERSAO_4	; RETORNA DA CONVERSÃO DE BINÁRIO PARA DECIMAL
		CONVERSAO_3
		CONVERSAO_2
		CONVERSAO_1
		CONVERSAO_0
		MSB		; PARÂMETRO DE ENTRADA PARA ROTINA
		LSB		; DE CONVERSÃO BINÁRIO PARA DECIMAL  		
	ENDC		 	; FIM DO BLOCO DE RAM(GPR)
	
	CBLOCK 0x70
		W_TEMP	 ; VARIÁVEIS TEMPORÁRIAS
		STATUS_TEMP	
		FSR_TEMP
		PCLATH_TEMP
	ENDC
		
;*	*	*	*	*	*	*	*	*	*
;*		          DEFINIÇÃO DE FLAGS				*
;*	*	*	*	*	*	*	*	*	*

; AQUI SÃO DEFINIDOS OS FLAGS QUE SERÃO UTILIZADOS PELO SISTEMA

#DEFINE  TECLA_0	TECLADO1,0  ; TECLA 0 DO TECLADO MATRICIAL
#DEFINE  TECLA_1	TECLADO1,1  ; TECLA 1 DO TECLADO MATRICIAL	
#DEFINE  TECLA_2	TECLADO1,2  ; TECLA 2 DO TECLADO MATRICIAL	
#DEFINE  TECLA_3	TECLADO1,3  ; TECLA 3 DO TECLADO MATRICIAL
#DEFINE  TECLA_4	TECLADO1,4  ; TECLA 4 DO TECLADO MATRICIAL
#DEFINE  TECLA_5	TECLADO1,5  ; TECLA 5 DO TECLADO MATRICIAL
#DEFINE  TECLA_6	TECLADO1,6  ; TECLA 6 DO TECLADO MATRICIAL
#DEFINE  TECLA_7	TECLADO1,7  ; TECLA 7 DO TECLADO MATRICIAL
#DEFINE  TECLA_8	TECLADO2,0  ; TECLA 8 DO TECLADO MATRICIAL
#DEFINE  TECLA_9	TECLADO2,1  ; TECLA 9 DO TECLADO MATRICIAL
#DEFINE  TECLA_C	TECLADO2,2  ; TECLA CORRIGE DO TECLADO MATRICIAL
#DEFINE  TECLA_E	TECLADO2,3  ; TECLA ENTER DO TECLADO MATRICIAL

#DEFINE	MOSTRA_RPS_RPM  FLAGS,0     ; 1-> ATUALIZA O DISPLAY			
	
;*	*	*	*	*	*	*	*	*	*
;*		        DEFINIÇÃO DE CONSTANTES				*
;*	*	*	*	*	*	*	*	*	*

; AQUI SÃO DEFINIDOS AS CONSTANTES QUE SERÃO UTILIZADOS PELO SISTEMA

#DEFINE LINHA_SUP	0x80	; CONSTANTE PARA LINHA SUPERIOR
#DEFINE LINHA_INF	0xC0	; CONSTANTE PARA LINHA INFERIOR

#DEFINE SEL_LINHA1	B'00001110'  ; SELECIONA LINHA 1	
#DEFINE SEL_LINHA2	B'00001101'  ; SELECIONA LINHA 2		
#DEFINE SEL_LINHA3	B'00001011'  ; SELECIONA LINHA 3		
#DEFINE SEL_LINHA4	B'00000111'  ; SELECIONA LINHA 4	

;*	*	*	*	*	*	*	*	*	*
;*			  ENTRADAS DO SISTEMA				*
;*	*	*	*	*	*	*	*	*	*

#DEFINE COL1		PORTA,4	     ; PINO DE ENTRADA DA COLUNA1	
#DEFINE COL2		PORTA,5	     ; PINO DE ENTRADA DA COLUNA2		
#DEFINE COL3		PORTE,0	     ; PINO DE ENTRADA DA COLUNA3		

;*	*	*	*	*	*	*	*	*	*
;*			  SAÍDAS DO SISTEMA				*
;*	*	*	*	*	*	*	*	*	*

; AQUI SÃO DEFINIDAS AS SAÍDAS QUE SERÃO UTILIZADOS PELO SISTEMA

#DEFINE BUS		PORTD	; DEFINE O BARRAMENTO COMO O PORTD 
#DEFINE RS		PORTE,1	; RS DO DISPLAY
#DEFINE EN		PORTE,2 ; EN DO DISPLAY

;*	*	*	*	*	*	*	*	*	*
;*			    VETOR DE RESET				*
;*	*	*	*	*	*	*	*	*	*

	ORG 	0x0000		; ENDEREÇO INICIAL DA MÁQUINA
	GOTO	CONFIG_		; SALTA PARA CONFIGURAR A MÁQUINA

;*	*	*	*	*	*	*	*	*	*
;*		         VETOR DE INTERRUPÇÃO				*
;*	*	*	*	*	*	*	*	*	*

	ORG 	0x0004		; ENDEREÇO INICIAL DO VETOR DE INTERRUPÇÃO
SALVA_CONTEXTO
	MOVWF	W_TEMP		; SALVA W
	SWAPF	STATUS,W	
	MOVWF	STATUS_TEMP	; SALVA STATUS
	MOVF	FSR,W
	MOVWF	FSR_TEMP	; SALVA FSR	
	MOVF	PCLATH,W	
	MOVWF	PCLATH_TEMP	; SALVA PCLATH
	
	CLRF	STATUS		; GARANTE BANCO 0
	CLRF	PCLATH		; GARANTE PÁGINA 0
	
	BTFSC	INTCON,T0IF	; INTERRUPÇÃO DE TIMER0?
	GOTO	TRATA_TIMER0	; SIM, ENTÃO TRATA
	
	BTFSC	PIR1,TMR2IF	; INTERRUPÇÃO DE TIMER2?
	GOTO	TRATA_TIMER2	; SIM, ENTÃO TRATA
		
SAI_INTERRUPCAO	
	MOVF	FSR_TEMP,W
	MOVWF	FSR		; RECUPERA FSR
	MOVF	PCLATH_TEMP,W	
	MOVWF	PCLATH		; RECUPERA PCLATH
	SWAPF	STATUS_TEMP,W
	MOVWF	STATUS		; RECUPERA STATUS
	SWAPF	W_TEMP,F
	SWAPF	W_TEMP,W	; RECUPERA W
	RETFIE			; RETORNA DA INTERRUPÇÃO

;*	*	*	*	*	*	*	*	*	*
;*     	            TRATATAMENTO DE INTERRUPÇÃO DE TIMER0		*
;*	*	*	*	*	*	*	*	*	*

TRATA_TIMER0
	
	BCF	INTCON,T0IF	 ; LIMPA FLAG DE INTERRUPÇÃO
	INCF	INDICE		 ; INCREMENTA INDICE 
	MOVLW	B'00000011'	 
	ANDWF	INDICE,W	 ; MASCARA OS BITS SUPERIORES	
	ADDWF	PCL,F	 	 ; SOMA CONTEÚDO COM PCL	
	GOTO	VERIFICA_LINHA1	 ; SALTA PARA TRATAR A LINHA 1
	GOTO	VERIFICA_LINHA2	 ; SALTA PARA TRATAR A LINHA 2
	GOTO	VERIFICA_LINHA3	 ; SALTA PARA TRATAR A LINHA 3
	GOTO	VERIFICA_LINHA4	 ; SALTA PARA TRATAR A LINHA 4
	

VERIFICA_LINHA1
	
	MOVLW	SEL_LINHA1	
	MOVWF	BUS		; SELECIONA A LINHA 1	
	
	BCF	TECLA_1		; LIMPA FLAG DA TECLA 1 PRESSIONADA
	BCF	TECLA_2		; LIMPA FLAG DA TECLA 2 PRESSIONADA
	BCF	TECLA_3		; LIMPA FLAG DA TECLA 3 PRESSIONADA
		
	BTFSS	COL1		; COLUNA1 ESTÁ PRESSIONADA?
	BSF	TECLA_1		; SIM, ENTÃO SETA TECLA_1
	
	BTFSS	COL2		; COLUNA2 ESTÁ PRESSIONADA?
	BSF	TECLA_2		; SIM, ENTÃO SETA TECLA_2
	
	BTFSS	COL3		; COLUNA3 ESTÁ PRESSIONADA?
	BSF	TECLA_3		; SIM, ENTÃO SETA TECLA_3
	
	GOTO	SAI_INTERRUPCAO	; SAI DA INTERRUPÇÃO
	
VERIFICA_LINHA2
	
	MOVLW	SEL_LINHA2
	MOVWF	BUS		; SELECIONA A LINHA 2	
	
	BCF	TECLA_4		; LIMPA FLAG DA TECLA 4 PRESSIONADA
	BCF	TECLA_5		; LIMPA FLAG DA TECLA 5 PRESSIONADA
	BCF	TECLA_6		; LIMPA FLAG DA TECLA 6 PRESSIONADA
		
	BTFSS	COL1		; COLUNA1 ESTÁ PRESSIONADA?
	BSF	TECLA_4		; SIM, ENTÃO SETA TECLA_4
	
	BTFSS	COL2		; COLUNA2 ESTÁ PRESSIONADA?
	BSF	TECLA_5		; SIM, ENTÃO SETA TECLA_5
	
	BTFSS	COL3		; COLUNA3 ESTÁ PRESSIONADA?
	BSF	TECLA_6		; SIM, ENTÃO SETA TECLA_6
	
	GOTO	SAI_INTERRUPCAO	; SAI DA INTERRUPÇÃO

VERIFICA_LINHA3
	
	MOVLW	SEL_LINHA3
	MOVWF	BUS		; SELECIONA A LINHA 3	
	
	BCF	TECLA_7		; LIMPA FLAG DA TECLA 7 PRESSIONADA
	BCF	TECLA_8		; LIMPA FLAG DA TECLA 8 PRESSIONADA
	BCF	TECLA_9		; LIMPA FLAG DA TECLA 9 PRESSIONADA
		
	BTFSS	COL1		; COLUNA1 ESTÁ PRESSIONADA?
	BSF	TECLA_7		; SIM, ENTÃO SETA TECLA_7
	
	BTFSS	COL2		; COLUNA2 ESTÁ PRESSIONADA?
	BSF	TECLA_8		; SIM, ENTÃO SETA TECLA_8
	
	BTFSS	COL3		; COLUNA3 ESTÁ PRESSIONADA?
	BSF	TECLA_9		; SIM, ENTÃO SETA TECLA_9
	
	GOTO	SAI_INTERRUPCAO	; SAI DA INTERRUPÇÃO

VERIFICA_LINHA4
	
	MOVLW	SEL_LINHA4	
	MOVWF	BUS		; SELECIONA A LINHA 4	
	
	BCF	TECLA_E		; LIMPA FLAG DA TECLA ENTER PRESSIONADA
	BCF	TECLA_C		; LIMPA FLAG DA TECLA CORRIGE PRESSIONADA
	BCF	TECLA_0		; LIMPA FLAG DA TECLA 0 PRESSIONADA
		
	BTFSS	COL1		; COLUNA1 ESTÁ PRESSIONADA?
	BSF	TECLA_C		; SIM, ENTÃO SETA TECLA_C
	
	BTFSS	COL2		; COLUNA2 ESTÁ PRESSIONADA?
	BSF	TECLA_0		; SIM, ENTÃO SETA TECLA_0
	
	BTFSS	COL3		; COLUNA3 ESTÁ PRESSIONADA?
	BSF	TECLA_E		; SIM, ENTÃO SETA TECLA_E
	
	GOTO	SAI_INTERRUPCAO	; SAI DA INTERRUPÇÃO

;*	*	*	*	*	*	*	*	*	*
;*     	            TRATATAMENTO DA INTERRUPÇÃO DE TIMER2		*
;*	*	*	*	*	*	*	*	*	*

TRATA_TIMER2

	BCF	PIR1,TMR2IF
	
	DECFSZ	VEZES_TIMER2,F	; DECREMENTA VEZES_TIMER2, ACABOU?
	GOTO	SAI_INTERRUPCAO	; NÃO, ENTÃO SAI DA INTERRUPÇÃO
	
	MOVLW	.100
	MOVWF	VEZES_TIMER2	; RECARREGA VEZES_TIMER2
	
	BCF	T1CON,TMR1ON	; DESLIGA TIMER1
	
	MOVF	TMR1L,W
	MOVWF	CONTADOR_LSB
	MOVF	TMR1H,W
	MOVWF	CONTADOR_MSB	; SALVA VALOR DA CONTAGEM
	
	CLRF	TMR1L		; LIMPA VARIÁVEIS DE CONTAGEM
	CLRF	TMR1H
	
	BSF	MOSTRA_RPS_RPM	; SETA FLAG PARA MOSTRAR RPS E RPM
	
	BSF	T1CON,TMR1ON	; LIGA O TIMER 1
	
	GOTO	SAI_INTERRUPCAO	; SAI DA INTERRUPÇÃO

;*	*	*	*	*	*	*	*	*	*
;*	              ROTINA DE MULTIPLICACÃO 8x8			*
;*			  ENTRADAS: ARG1:ARG0				*	
;*			   SAÍDA: ARG1:ARG0				*
;*		    VARIÁVEIS AUXILIARES: MUL1:MUL0			*
;*	*	*	*	*	*	*	*	*	*

MULTIPLICACAO

	MOVF	ARG0,F		; VERIFICA SE ALGUMA DAS VARIÁVEIS
	BTFSC	STATUS,Z	; É NULA	
	GOTO	SAI_EM_0
	
	MOVF	ARG1,F
	BTFSC	STATUS,Z
	GOTO	SAI_EM_0
	
	CLRF	MUL1
	CLRF	MUL0
	
MULT
	MOVF	ARG0,W		; FAZ A SOMA SUCESSIVA, OU SEJA
	ADDWF	MUL0,F		; A MULTIPLICAÇÃO
	BTFSC	STATUS,C
	INCF	MUL1,F
	
	DECFSZ	ARG1,F
	GOTO	MULT

SAI_COM_DADO
	
	MOVF	MUL1,W		; RETORNA O VALOR DA MULTIPLICAÇÃO
	MOVWF	ARG1
	MOVF	MUL0,W
	MOVWF	ARG0
	RETURN
		
SAI_EM_0
	
	CLRF	ARG0
	CLRF	ARG1
	RETURN	

;*	*	*	*	*	*	*	*	*	*
;*                      ROTINA DE DIVISÃO DE 16 BITS			*
;*		ENTRADAS: DIVIDENDO(ARG1:ARG0) DIVISOR(ARG2) 		*
;*			    SAÍDA: ARG1:ARG0				*
;*	       	     VARIÁVEIS AUXILIARES: MUL1:MUL0			*
;*	*	*	*	*	*	*	*	*	*

DIVIDE
	CLRF	MUL1		; INICIALIZA REGISTRADORES AUXILIARES
	CLRF	MUL0
	
	MOVF	ARG2,F		; VERIFICA SE O DIVISOR É IGUAL A 0
	BTFSC	STATUS,Z
	GOTO	SAI_EM_0	; CASO SEJA, RETORNA EM 0
	
	MOVF	ARG0,F		; VERIFICA SE O DIVIDENDO É ZERO
	BTFSS	STATUS,Z
	GOTO	DIVIDE_A
	
	MOVF	ARG1,F
	BTFSC	STATUS,Z
	GOTO	SAI_EM_0	; CASO SEJA, RETORNA EM 0
	
DIVIDE_A

	MOVF	ARG2,W		; FAZ A SUBTRAÇÃO SUCESSIVA, OU SEJA, 
	SUBWF	ARG0,F		; A DIVISÃO	
	BTFSS	STATUS,C
	GOTO	DIVIDE_B

DIVIDE_C

	INCF	MUL0,F
	BTFSC	STATUS,Z
	INCF	MUL1,F
	GOTO	DIVIDE_A

DIVIDE_B

	MOVF	ARG1,F
	BTFSC	STATUS,Z
	GOTO	SAI_COM_DADO	; RETORNA COMO O VALOR DA DIVISÃO
	DECF	ARG1,F
	GOTO	DIVIDE_C
	
;*	*	*	*	*	*	*	*	*	*
;*	              ROTINA DE DELAY DE 1ms A 256ms			*
;*	*	*	*	*	*	*	*	*	*

DELAY_MS
	
	CLRWDT
	
	MOVWF	TEMPO2		; SALVA O VALOR MULTIPLICADOR
	CLRF	TEMPO1		; LIMPA REGISTRADOR

DELAY_A
	
	NOP			; PERDE 1 CICLO DE MÁQUINA
	DECFSZ	TEMPO1,F	; DECREMENTA REGISTRADOR, ACABOU?
	GOTO	$-2		; NÃO, ENTÃO RETORNA DUAS POSIÇÕES 
	DECFSZ	TEMPO2,F
	GOTO	DELAY_A
	
	RETURN			; RETORNA DA INTERRUPÇÃO

;*	*	*	*	*	*	*	*	*	*
;*	          ROTINA PARA ESCREVER DADOS NO DISPLAY			*
;*	*	*	*	*	*	*	*	*	*

ENVIA_COMANDO
	
	BCF	RS		; PÕE EM MODO DE COMANDO
	
ENVIA_DADO
	
	BCF	INTCON,GIE	; DESLIGA A INTERRUPÇÃO
	
	MOVWF	BUS		; MOVE DADO PARA O PORTD
		
	GOTO	$+1		; DEÇAY PARA ACOMODAÇÃO
	GOTO	$+1		
	
	BSF	EN		; GERA PULSO DE CLOCK
	GOTO	$+1
	BCF	EN
	
	BSF	RS		; VOLTA PARA O MODO DADOS
	MOVLW	.1
	CALL	DELAY_MS
	BSF	INTCON,GIE	; LIGA A INTERRUPÇÃO
	RETURN			; RETORNA DA INTERRUPÇÃO

;*	*	*	*	*	*	*	*	*	*
;*		     ROTINA DE ATUALIZAÇÃO DA TELA DO LCD 		*
;*	*	*	*	*	*	*	*	*	*

ATUALIZA_TELA
	
	
	MOVLW	0x80
	CALL	ENVIA_COMANDO	; COMANDO PARA POSICIONAR O DISPLAY
	
	MOVLW	'V'
	CALL	ENVIA_DADO	; ENVIA CARACTER ASCII	
	
	MOVLW	't'
	CALL	ENVIA_DADO	; ENVIA CARACTER ASCII	
	
	MOVLW	':'
	CALL	ENVIA_DADO	; ENVIA CARACTER ASCII	
	
	MOVLW	' '
	CALL	ENVIA_DADO	; ENVIA CARACTER ASCII	
	
	MOVLW	'0'
	CALL	ENVIA_DADO	; ENVIA CARACTER ASCII	
	
	MOVLW	' '
	CALL	ENVIA_DADO	; ENVIA CARACTER ASCII	
		
	MOVLW	'%'
	CALL	ENVIA_DADO	; ENVIA CARACTER ASCII	
	
	MOVLW	' '
	CALL	ENVIA_DADO	; ENVIA CARACTER ASCII	
	
	MOVLW	'R'
	CALL	ENVIA_DADO	; ENVIA CARACTER ASCII	
	
	MOVLW	'e'
	CALL	ENVIA_DADO	; ENVIA CARACTER ASCII	
	
	MOVLW	's'
	CALL	ENVIA_DADO	; ENVIA CARACTER ASCII	
	
	MOVLW	':'
	CALL	ENVIA_DADO	; ENVIA CARACTER ASCII	
	
	MOVLW	' '
	CALL	ENVIA_DADO	; ENVIA CARACTER ASCII	
		
	MOVLW	'0'
	CALL	ENVIA_DADO	; ENVIA CARACTER ASCII	
	
	MOVLW	' '
	CALL	ENVIA_DADO	; ENVIA CARACTER ASCII	
	
	MOVLW	'%'
	CALL	ENVIA_DADO	; ENVIA CARACTER ASCII	
	
	MOVLW	0xC0
	CALL	ENVIA_COMANDO
	
	MOVLW	' '
	CALL	ENVIA_DADO	; ENVIA CARACTER ASCII	
		
	MOVLW	'0'
	CALL	ENVIA_DADO	; ENVIA CARACTER ASCII	
	
	MOVLW	' '
	CALL	ENVIA_DADO	; ENVIA CARACTER ASCII	
	
	MOVLW	'H'
	CALL	ENVIA_DADO	; ENVIA CARACTER ASCII	
	
	MOVLW	'z'
	CALL	ENVIA_DADO	; ENVIA CARACTER ASCII	
	
	
	MOVLW	' '
	CALL	ENVIA_DADO	; ENVIA CARACTER ASCII	
		
	MOVLW	' '
	CALL	ENVIA_DADO	; ENVIA CARACTER ASCII	
	
	MOVLW	' '
	CALL	ENVIA_DADO	; ENVIA CARACTER ASCII	
	
	MOVLW	'0'
	CALL	ENVIA_DADO	; ENVIA CARACTER ASCII	
	
	MOVLW	' '
	CALL	ENVIA_DADO	; ENVIA CARACTER ASCII	
	
	MOVLW	'R'
	CALL	ENVIA_DADO	; ENVIA CARACTER ASCII	
	
	MOVLW	'M'
	CALL	ENVIA_DADO	; ENVIA CARACTER ASCII	
	
	MOVLW	' '
	CALL	ENVIA_DADO
	
	MOVLW	' '
	CALL	ENVIA_DADO
	
	MOVLW	' '
	CALL	ENVIA_DADO
	
	MOVLW	'C'
	CALL	ENVIA_DADO
	
	RETURN			; RETORNA DA ROTINA	

;*	*	*	*	*	*	*	*	*	*
;*	            ROTINA PARA ATUALIZAR A FAIXA DE 0%	 		*
;*	*	*	*	*	*	*	*	*	*

ATUALIZA_0
	
	MOVWF	TEMP
	
	XORLW	0x83		; VERIFICA SE É PARA ATUALIZAR
	MOVLW	.0		; O CCP1 OU O CCP2
	BTFSS	STATUS,Z
	MOVWF	CCPR2L
	BTFSC	STATUS,Z
	MOVWF	CCPR1L
	
	MOVF	TEMP,W		; POSICIONA LINHA DO DISPLAY
	CALL	ENVIA_COMANDO	; CHAMA ROTINA PARA ENVIAR COMANDO
	
	MOVLW	' '
	CALL	ENVIA_DADO	; ENVIA CARACTER ASCII	
	
	MOVLW	'0'
	CALL	ENVIA_DADO	; ENVIA CARACTER ASCII	
	
	MOVLW	' '
	CALL	ENVIA_DADO	; ENVIA CARACTER ASCII	
	
	RETURN			; RETORNA DA ROTINA	


;*	*	*	*	*	*	*	*	*	*
;*	            ROTINA PARA ATUALIZAR A FAIXA DE 20%		*
;*	*	*	*	*	*	*	*	*	*

ATUALIZA_20
	
	MOVWF	TEMP
	
	XORLW	0x83		; VERIFICA SE É PARA ATUALIZAR
	MOVLW	.50		; O CCP1 OU O CCP2
	BTFSS	STATUS,Z
	MOVWF	CCPR2L
	BTFSC	STATUS,Z
	MOVWF	CCPR1L

	MOVF	TEMP,W
	CALL	ENVIA_COMANDO	; CHAMA ROTINA PARA ENVIAR COMANDO
	
	MOVLW	' '
	CALL	ENVIA_DADO	; ENVIA CARACTER ASCII	
	
	MOVLW	'2'
	CALL	ENVIA_DADO	; ENVIA CARACTER ASCII	
	
	MOVLW	'0'
	CALL	ENVIA_DADO	; ENVIA CARACTER ASCII	
	
	RETURN			; RETORNA DA ROTINA	

;*	*	*	*	*	*	*	*	*	*
;*	            ROTINA PARA ATUALIZAR A FAIXA DE 40%		*
;*	*	*	*	*	*	*	*	*	*

ATUALIZA_40
	
	MOVWF	TEMP
	
	XORLW	0x83		; VERIFICA SE É PARA ATUALIZAR
	MOVLW	.101		; O CCP1 OU O CCP2
	BTFSS	STATUS,Z
	MOVWF	CCPR2L
	BTFSC	STATUS,Z
	MOVWF	CCPR1L

	MOVF	TEMP,W
	CALL	ENVIA_COMANDO	; CHAMA ROTINA PARA ENVIAR COMANDO
	
	MOVLW	' '
	CALL	ENVIA_DADO	; ENVIA CARACTER ASCII	
	
	MOVLW	'4'
	CALL	ENVIA_DADO	; ENVIA CARACTER ASCII	
	
	MOVLW	'0'
	CALL	ENVIA_DADO	; ENVIA CARACTER ASCII	
	
	RETURN			; RETORNA DA ROTINA	

;*	*	*	*	*	*	*	*	*	*
;*	            ROTINA PARA ATUALIZAR A FAIXA DE 60%		*
;*	*	*	*	*	*	*	*	*	*

ATUALIZA_60
	
	MOVWF	TEMP
	
	XORLW	0x83		; VERIFICA SE É PARA ATUALIZAR
	MOVLW	.152		; O CCP1 OU O CCP2
	BTFSS	STATUS,Z
	MOVWF	CCPR2L
	BTFSC	STATUS,Z
	MOVWF	CCPR1L

	MOVF	TEMP,W
	CALL	ENVIA_COMANDO	; CHAMA ROTINA PARA ENVIAR COMANDO
	
	MOVLW	' '
	CALL	ENVIA_DADO	; ENVIA CARACTER ASCII	
	
	MOVLW	'6'
	CALL	ENVIA_DADO	; ENVIA CARACTER ASCII	
	
	MOVLW	'0'
	CALL	ENVIA_DADO	; ENVIA CARACTER ASCII	
	
	RETURN			; RETORNA DA ROTINA	

;*	*	*	*	*	*	*	*	*	*
;*	            ROTINA PARA ATUALIZAR A FAIXA DE 80%		*
;*	*	*	*	*	*	*	*	*	*

ATUALIZA_80
	
	MOVWF	TEMP
	
	XORLW	0x83		; VERIFICA SE É PARA ATUALIZAR
	MOVLW	.203		; O CCP1 OU O CCP2
	BTFSS	STATUS,Z
	MOVWF	CCPR2L
	BTFSC	STATUS,Z
	MOVWF	CCPR1L

	MOVF	TEMP,W
	CALL	ENVIA_COMANDO	; CHAMA ROTINA PARA ENVIAR COMANDO
	
	MOVLW	' '
	CALL	ENVIA_DADO	; ENVIA CARACTER ASCII	
	
	MOVLW	'8'
	CALL	ENVIA_DADO	; ENVIA CARACTER ASCII	
	
	MOVLW	'0'
	CALL	ENVIA_DADO	; ENVIA CARACTER ASCII	
	
	RETURN			; RETORNA DA ROTINA	

;*	*	*	*	*	*	*	*	*	*
;*	            ROTINA PARA ATUALIZAR A FAIXA DE 100%		*
;*	*	*	*	*	*	*	*	*	*

ATUALIZA_100
	
	MOVWF	TEMP
	
	XORLW	0x83		; VERIFICA SE É PARA ATUALIZAR
	MOVLW	.255		; O CCP1 OU O CCP2
	BTFSS	STATUS,Z
	MOVWF	CCPR2L
	BTFSC	STATUS,Z
	MOVWF	CCPR1L

	MOVF	TEMP,W
	CALL	ENVIA_COMANDO	; CHAMA ROTINA PARA ENVIAR COMANDO
	
	MOVLW	'1'
	CALL	ENVIA_DADO	; ENVIA CARACTER ASCII	
	
	MOVLW	'0'
	CALL	ENVIA_DADO	; ENVIA CARACTER ASCII	
	
	MOVLW	'0'
	CALL	ENVIA_DADO	; ENVIA CARACTER ASCII	
	
	RETURN			; RETORNA DA ROTINA	

;*	*	*	*	*	*	*	*	*	*
;*	            ROTINA PARA ATUALIZAR O RPS E O RPM			*
;*	*	*	*	*	*	*	*	*	*

ATUALIZA_RPS_RPM
	
	BCF	MOSTRA_RPS_RPM	; LIMPA FLAG
	
	MOVF	CONTADOR_LSB,W
	MOVWF	ARG0
	MOVF	CONTADOR_MSB,W	; DIVIDE O RESULTADO DO CONTADOR PELO 
	MOVWF	ARG1		; NÚMERO DE ALETAS, NESSE CASO 7
	MOVLW	.7
	MOVWF	ARG2
	CALL	DIVIDE
	MOVF	ARG0,W
	MOVWF	LSB
	CLRF	MSB
	CALL	BIN_TO_DEC	; CONVERTE PARA DECIMAL
	CALL	ATUALIZA_TELA_RPS ; ATUALIZA A TELA DE RPS
	
	MOVF	ARG0,W		; MULTIPLICA O RESULTADO ANTERIOR	
	MOVWF	ARG1		; POR 60 PARA ACHAR O RPM
	MOVLW	.60
	MOVWF	ARG0
	CALL	MULTIPLICACAO
	MOVF	ARG1,W
	MOVWF	MSB
	MOVF	ARG0,W
	MOVWF	LSB
	CALL	BIN_TO_DEC	; CONVERTE RESULTADO PARA DECIMAL
	CALL	ATUALIZA_RPM	; CHAMA ROTINA PARA ATUALIZAR O DISPLAY
	
	RETURN			; RETORNA DA INTERRUPÇÃO

;*	*	*	*	*	*	*	*	*	*
;*	            ROTINA PARA ATUALIZAR A TELA DO RPS			*
;*	*	*	*	*	*	*	*	*	*

ATUALIZA_TELA_RPS
	
	MOVLW	0xC0		; POSICIONA INÍCIO DE ESCRITA NO DISPLAY
	CALL	ENVIA_COMANDO	; CHAMA ROTINA PARA ENVIAR O COMANDO
	
	MOVF	CONVERSAO_2,W	; MOVE RESULTADO DA CONVERSÃO PARA W
	ADDLW	0x30		; TRANSFORMA  O DADO EM PRINTÁVEL
	CALL	ENVIA_DADO	; ENVIA  O DADO PARA O DISPLAY

	MOVF	CONVERSAO_1,W	; MOVE RESULTADO DA CONVERSÃO PARA W
	ADDLW	0x30		; TRANSFORMA  O DADO EM PRINTÁVEL
	CALL	ENVIA_DADO	; ENVIA  O DADO PARA O DISPLAY
	
	MOVF	CONVERSAO_0,W	; MOVE RESULTADO DA CONVERSÃO PARA W
	ADDLW	0x30		; TRANSFORMA  O DADO EM PRINTÁVEL
	CALL	ENVIA_DADO	; ENVIA  O DADO PARA O DISPLAY
	
	RETURN			; RETORNA DA INTERRUPÇÃO
	
;*	*	*	*	*	*	*	*	*	*
;*	            ROTINA PARA ATUALIZAR A TELA DO RPM			*
;*	*	*	*	*	*	*	*	*	*

ATUALIZA_RPM

	MOVLW	0xC6		; POSICIONA A POSIÇÃO NO DISPLAY
	CALL	ENVIA_COMANDO	; ENVIA COMANDO PARA O DISPLAY
	
	MOVF	CONVERSAO_3,W	; MOVE RESULTADO DA CONVERSÃO PARA W
	ADDLW	0x30		; TRANSFORMA  O DADO EM PRINTÁVEL
	CALL	ENVIA_DADO	; ENVIA  O DADO PARA O DISPLAY
	
	MOVF	CONVERSAO_2,W	; MOVE RESULTADO DA CONVERSÃO PARA W
	ADDLW	0x30		; TRANSFORMA  O DADO EM PRINTÁVEL
	CALL	ENVIA_DADO	; ENVIA  O DADO PARA O DISPLAY
	
	MOVF	CONVERSAO_1,W	; MOVE RESULTADO DA CONVERSÃO PARA W
	ADDLW	0x30		; TRANSFORMA  O DADO EM PRINTÁVEL
	CALL	ENVIA_DADO	; ENVIA  O DADO PARA O DISPLAY
	
	MOVF	CONVERSAO_0,W	; MOVE RESULTADO DA CONVERSÃO PARA W
	ADDLW	0x30		; TRANSFORMA  O DADO EM PRINTÁVEL
	CALL	ENVIA_DADO	; ENVIA  O DADO PARA O DISPLAY
	
	RETURN			; RETORNA DA INTERRUPÇÃO

;*	*	*	*	*	*	*	*	*	*
;*	            ROTINA PARA ATUALIZAR A TEMPERATURA			*
;*	*	*	*	*	*	*	*	*	*

ATUALIZA_TEMPERATURA
	
	BCF	STATUS,C	; LIMPA O BIT DE STATUS		
	RLF	ADRESH,W	; MULTIPLICA O RESULTADO POR 2
	MOVWF	LSB		; MOVE RESULTADO PARA LSB
	CLRF	MSB
	CALL	BIN_TO_DEC	; CHAMA ROTINA DE CONVERSÃO PARA DECIMAL
	
	MOVLW	0xCD		; POSICIONA O DISPLAY
	CALL	ENVIA_COMANDO
		
	MOVF	CONVERSAO_1,W	; MOVE RESULTADO DA CONVERSÃO PARA W
	ADDLW	0x30		; ADICIONA VALOR PARA FICAR PRINTÁVEL
	CALL	ENVIA_DADO	; ESCREVE O DADO NO DISPLAY	
	
	MOVF	CONVERSAO_0,W	; MOVE RESULTADO DA CONVERSÃO PARA W
	ADDLW	0x30		; ADICIONA VALOR PARA FICAR PRINTÁVEL
	CALL	ENVIA_DADO	; ESCREVE O DADO NO DISPLAY	

	RETURN			; RETORNA DA ROTINA
	
;*	*	*	*	*	*	*	*	*	*
;*	          ROTINA DE CONVERSÃO BINÁRIO PARA DECIMAL 		*
;*		             ENTRADAS: MSB:LSB				*
;*  SAÍDA: CONVERSAO_4:CONVERSAO_3:CONVERSAO_2:CONVERSAO_1:CONVERSAO_0  *
;*	*	*	*	*	*	*	*	*	*

BIN_TO_DEC
	
	CLRF	CONVERSAO_0	; INICIALIZA VARIÁVEIS DE CONVERSÃO
	CLRF	CONVERSAO_1
	CLRF	CONVERSAO_2
	CLRF	CONVERSAO_3
	CLRF	CONVERSAO_4
		
	MOVF	LSB,F		; VERIFICA SE ALGUMA DAS VARIÁVEIS É NULA
	BTFSS	STATUS,Z
	GOTO	INC_MSB
	
	MOVF	MSB,F
	BTFSC	STATUS,Z
	RETURN
	
	MOVF	LSB,F
	BTFSC	STATUS,Z
	GOTO	CONVERSAO_A
	
INC_MSB	

	INCF	MSB,F
		
CONVERSAO_A

	CLRWDT	
	INCF	CONVERSAO_0,F		; FAZ A CONVERSÃO DO
	MOVLW	.10			; RESULTADO PASSADO COMO ARGUMENTO
	XORWF	CONVERSAO_0,W
	BTFSS	STATUS,Z
	GOTO	CONVERSAO_B
	
	CLRF	CONVERSAO_0
	INCF	CONVERSAO_1,F
	MOVLW	.10
	XORWF	CONVERSAO_1,W
	BTFSS	STATUS,Z
	GOTO	CONVERSAO_B
	
	CLRF	CONVERSAO_1
	INCF	CONVERSAO_2,F
	MOVLW	.10
	XORWF	CONVERSAO_2,W
	BTFSS	STATUS,Z
	GOTO	CONVERSAO_B
	
	CLRF	CONVERSAO_2
	INCF	CONVERSAO_3,F
	MOVLW	.10
	XORWF	CONVERSAO_3,W
	BTFSS	STATUS,Z
	GOTO	CONVERSAO_B
	
	CLRF	CONVERSAO_3
	INCF	CONVERSAO_4,F
	
CONVERSAO_B	

	DECFSZ	LSB,F
	GOTO	CONVERSAO_A
	
	DECFSZ	MSB,F
	GOTO	CONVERSAO_A
		
	RETURN	
			
;*	*	*	*	*	*	*	*	*	*
;*		          CONFIGURACOES INICIAIS			*
;*	*	*	*	*	*	*	*	*	*

CONFIG_

	CLRF	PORTA		; LIMPA O PORTA
	CLRF	PORTB		; LIMPA O PORTB
	CLRF	PORTC		; LIMPA O PORTC
	CLRF	PORTD		; LIMPA O PORTD
	CLRF	PORTE		; LIMPA O PORTE
	
	BANK1			; SELECIONA BANCO1 DE MEMÓRIA
	
	MOVLW	B'11111111'
	MOVWF	TRISA
	
	MOVLW	B'11000000'
	MOVWF	TRISB		; CONFIGURA I/O DO PORTB
	
	MOVLW	B'11011001'
	MOVWF	TRISC		; CONFIGURA I/O DO PORTB
	
	MOVLW	B'00000000'	; CONFIGURA TODOS OS PINOS DESTE
	MOVWF	TRISD		; PORTB COMO SAÍDA
	
	MOVLW	B'00000001'
	MOVWF	TRISE		; CONFIGURA I/O DO PORTE
	
	MOVLW	B'10001111'	; DESLIGA PULL-UPS
	MOVWF	OPTION_REG	; WDT 1:128
	
	MOVLW	B'00000010'
	MOVWF	PIE1		; HABILITA INTERRUPÇÃO DE TIMER2
	
	MOVLW	B'01000000'	
	MOVWF	INTCON		; HABILITA A INTERRUPÇÃO DOS PERIFÉRICOS
				; LIGA A CHAVE GERAL DE INTERRUPÇÃO
	
	MOVLW	B'00000100'	; RA0, RA1 E RA3 COMO ENTRADA
	MOVWF	ADCON1		; ANALÓGICA
	
	MOVLW	.249
	MOVWF	PR2		; CONFIGURA BASE DE TEMPO PARA 4kHz
	
	BANK0
	
	MOVLW	B'01011001'
	MOVWF	ADCON0		; LIGA O A/D
	
	CLRF	TMR1L
	CLRF	TMR1H
	MOVLW	B'00000111'
	MOVWF	T1CON		; PRESCALE 1:1
				; TIMER 1 COMO CONTADOR EXTERNO
	
	MOVLW	B'01001101'
	MOVWF	T2CON		; TIMER 2 ON
				; PRESCALER 1:4
				; POSTSCALE 1:10
	
	MOVLW	B'00001111'
	MOVWF	CCP1CON
	MOVWF	CCP2CON		; CONFIGURA CCP PARA MODO PWM
	
	CLRF	CCPR1L
	CLRF	CCPR2L		; INICIALIZA OS MÓDULOS	
	
	BTFSC	STATUS,NOT_TO	; ESTOURO POR WDT?
	GOTO	$		; NÃO, ENTÃO AGUARDA
		
LIMPEZA_DA_RAM
				; ROTINA DE LIMPEZA DA RAM
				
	MOVLW	0x20
	MOVWF	FSR
	CLRF	INDF
	INCF	FSR,F
	MOVLW	0x80
	XORWF	FSR,W
	BTFSS	STATUS,Z
	GOTO	$-5

	MOVLW	.100
	MOVWF	VEZES_TIMER2	; CARREGA VEZES_TIMER2
	
	BSF	INTCON,GIE	; LIGA AS INTERRUPÇÕES
	
;*	*	*	*	*	*	*	*	*	*
;*         	         INICIALIZAÇÃO DO DISPLAY			*
;*	*	*	*	*	*	*	*	*	*
	


	MOVLW	0x30			
	CALL	ENVIA_COMANDO		; COMANDO DE INICIALIZAÇÃO
	
	MOVLW	.3			
	CALL	DELAY_MS		; DELAY DE 3ms
	
	MOVLW	0x30			
	CALL	ENVIA_COMANDO		; COMANDO DE INICIALIZAÇÃO	
	
	MOVLW	0x30			
	CALL	ENVIA_COMANDO		; COMANDO DE INICIALIZAÇÃO
	
	MOVLW	0x38			
	CALL	ENVIA_COMANDO		; INTERFACE DE 8 VIAS
	
	MOVLW	0x01			
	CALL	ENVIA_COMANDO		; LIMPA O DISPLAY
	
	MOVLW	.1
	CALL	DELAY_MS		; CHAMA DELAY DE 3ms
	
	MOVLW	0x0C			
	CALL	ENVIA_COMANDO		; LIGAR O DISPLAY SEM CURSOR
	
	MOVLW	0x06			
	CALL	ENVIA_COMANDO		; LIGAR O DISPLAY SEM CURSOR
	
								
;*	*	*	*	*	*	*	*	*	*
;*         	         INICIALIZAÇÃO DAS VARIÁVEIS			*
;*	*	*	*	*	*	*	*	*	*
	
	CALL	ATUALIZA_TELA		; CHAMA ROTINA PARA ATUALIZAR
					; A TELA DA PLACA
		
;*	*	*	*	*	*	*	*	*	*
;*		            ROTINA PRINCIPAL				*
;*	*	*	*	*	*	*	*	*	*

LOOP
	CLRWDT			; LIMPA O WATCHDOG
	
	BTFSC	MOSTRA_RPS_RPM	; DEVE ATUALIZAR O DISPLAY?
	CALL	ATUALIZA_RPS_RPM ; SIM, ENTÃO CHAMA A ROTINA
	
	BSF	ADCON0,GO	; LIGA O AD
	
	BTFSC	ADCON0,GO	; AGUARDA O FIM DA CONVERSÃO
	GOTO	$-1
	
	CALL	ATUALIZA_TEMPERATURA ; CHAMA ROTINA PARA ATUALIZAR 
				     ; TEMPERATURA
			
AJUSTA_CCP1
	
	MOVLW	0x83		; MOVE POSIÇÃO INICIAL DA MENSAGEM
	BTFSC	TECLA_1		; A TECLA ESTÁ PRESSIONADA?
	CALL	ATUALIZA_0	; SIM, ENTÃO CHAMA A ROTINA DE ATUALIZAÇÃO
	
	MOVLW	0x83		; MOVE POSIÇÃO INICIAL DA MENSAGEM
	BTFSC	TECLA_2		; A TECLA ESTÁ PRESSIONADA?
	CALL	ATUALIZA_20	; SIM, ENTÃO CHAMA A ROTINA DE ATUALIZAÇÃO
	
	MOVLW	0x83		; MOVE POSIÇÃO INICIAL DA MENSAGEM
	BTFSC	TECLA_3		; A TECLA ESTÁ PRESSIONADA?
	CALL	ATUALIZA_40	; SIM, ENTÃO CHAMA A ROTINA DE ATUALIZAÇÃO
	
	MOVLW	0x83		; MOVE POSIÇÃO INICIAL DA MENSAGEM
	BTFSC	TECLA_4		; A TECLA ESTÁ PRESSIONADA?
	CALL	ATUALIZA_60	; SIM, ENTÃO CHAMA A ROTINA DE ATUALIZAÇÃO
	
	MOVLW	0x83		; MOVE POSIÇÃO INICIAL DA MENSAGEM
	BTFSC	TECLA_5		; A TECLA ESTÁ PRESSIONADA?
	CALL	ATUALIZA_80	; SIM, ENTÃO CHAMA A ROTINA DE ATUALIZAÇÃO
	
	MOVLW	0x83		; MOVE POSIÇÃO INICIAL DA MENSAGEM
	BTFSC	TECLA_6		; A TECLA ESTÁ PRESSIONADA?
	CALL	ATUALIZA_100	; SIM, ENTÃO CHAMA A ROTINA DE ATUALIZAÇÃO

AJUSTA_CCP2
	
	MOVLW	0x8C		; MOVE POSIÇÃO INICIAL DA MENSAGEM
	BTFSC	TECLA_7		; A TECLA ESTÁ PRESSIONADA?
	CALL	ATUALIZA_0	; SIM, ENTÃO CHAMA A ROTINA DE ATUALIZAÇÃO
	
	MOVLW	0x8C		; MOVE POSIÇÃO INICIAL DA MENSAGEM
	BTFSC	TECLA_8		; A TECLA ESTÁ PRESSIONADA?
	CALL	ATUALIZA_20	; SIM, ENTÃO CHAMA A ROTINA DE ATUALIZAÇÃO
	
	MOVLW	0x8C		; MOVE POSIÇÃO INICIAL DA MENSAGEM
	BTFSC	TECLA_9		; A TECLA ESTÁ PRESSIONADA?
	CALL	ATUALIZA_40	; SIM, ENTÃO CHAMA A ROTINA DE ATUALIZAÇÃO
	
	MOVLW	0x8C		; MOVE POSIÇÃO INICIAL DA MENSAGEM
	BTFSC	TECLA_C		; A TECLA ESTÁ PRESSIONADA?
  	CALL	ATUALIZA_60	; SIM, ENTÃO CHAMA A ROTINA DE ATUALIZAÇÃO
	
	MOVLW	0x8C		; MOVE POSIÇÃO INICIAL DA MENSAGEM
	BTFSC	TECLA_0		; A TECLA ESTÁ PRESSIONADA?
	CALL	ATUALIZA_80	; SIM, ENTÃO CHAMA A ROTINA DE ATUALIZAÇÃO
	
	MOVLW	0x8C		; MOVE POSIÇÃO INICIAL DA MENSAGEM
	BTFSC	TECLA_E		; A TECLA ESTÁ PRESSIONADA?
	CALL	ATUALIZA_100	; SIM, ENTÃO CHAMA A ROTINA DE ATUALIZAÇÃO
	
	GOTO	LOOP		; SALTA PARA O LOOP PRINCIPAL
		
;*	*	*	*	*	*	*	*	*	*
;*		             FIM DO PROGRAMA				*
;*	*	*	*	*	*	*	*	*	*


	END			; FIM DO PROGRAMA


