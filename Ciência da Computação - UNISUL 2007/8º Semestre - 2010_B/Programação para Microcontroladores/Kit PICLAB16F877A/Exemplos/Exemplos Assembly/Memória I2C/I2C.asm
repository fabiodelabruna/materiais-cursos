;*	*	*	*	*	*	*	*	*	*
;*			 Programação em Assembly			*
;* 	    EXEMPLO9: UTILIZAÇÃO DA MEMÓRIA DE PROGRAMA DO PIC		*
;*		     APOSTILA MÓDULO B  -  PIC16F877A			*
;*		      CERNE TECNOLOGIA E TREINAMENTO			*
;*	    VERSÃO 1.0				DATA:03/05/2005		*
;*									*
;*	*	*	*	*	*	*	*	*	*

;*	*	*	*	*	*	*	*	*	*
;*			 OBJETIVO DO ARQUIVO FONTE			*
;*									*
;*		DEMONSTRAR A UTILIZAÇÃO DA EEPROM DO PIC		*
;*									*
;*	*	*	*	*	*	*	*	*	*

 #INCLUDE <P16F877.INC> 	;ARQUIVO PADRÃO PARA PIC16F877A
 __CONFIG _CP_OFF & _XT_OSC & _PWRTE_ON & _LVP_OFF & _WDT_ON & _BODEN_OFF & _CPD_OFF & _DEBUG_OFF
 ERRORLEVEL 2 	
 	;NESTE PONTO É INFORMADO A CONFIGURAÇÃO DA MÁQUINA, OU SEJA, SE TERÁ
 	;CÓDIGO DE PROTEÇÃO OU O TIPO DE CRISTAL QUE SERÁ UTILIZADO	

 	;CONFIGURAÇÃO DA MÁQUINA
 	; CODE PROTECT		        -> DESLIGADO
 	; OSCILADOR    		        -> CRISTAL OU RESSONADOR
 	; POWER-UP     		        -> LIGADO
 	; DEBUF 		        -> DESLIGADO		
 	; PROGRAMAÇÃO EM BAIXA VOLTAGEM -> DESLIGADO
	; WATCH DOG			-> LIGADO
	; BROWN-OUT RESET		-> DESLIGADO
	; PROTEÇÃO DE EEPROM		-> DESLIGADO
	 	
;*	*	*	*	*	*	*	*	*	*
;*			   PAGINAÇÃO DE MEMÓRIA				*
;*	*	*	*	*	*	*	*	*	*

; AQUI CRIAREMOS UM PSEUDÔNIMO PARA UM COMANDO. POR EXEMPLO, O COMANDO
; "BCF STATUS,RP0" PODE SER SUBSTITUÍDO SEM PROBLEMAS POR "BANK0". O 
; COMPILADOR IRÁ SUBSTITUIR INTERNAMENTE "BANK0" POR "BCF STATUS,RP0".
; ESTA APLICAÇÃO É VÁLIDA PARA OUTROS TIPOS DE COMANDOS

#DEFINE	BANK0	BCF	STATUS,RP0	; ESCOLHE BANCO DE MEMÓRIA 0
#DEFINE	BANK1	BSF	STATUS,RP0	; ESCOLHE BANCO DE MEMÓRIA 1

;*	*	*	*	*	*	*	*	*	*
;*			     DEFINIÇÃO DE RAM				*
;*	*	*	*	*	*	*	*	*	*

; AQUI IREMOS CRIAR AS VARIÁVEIS DO NOSSO SISTEMA

	CBLOCK 0x20	 ; INÍCIO DO BLOCO DE RAM(GPR)
		TEMPO1   ; VARIÁVEL DA ROTINA DE TEMPO		
		TEMPO2   ; VARIÁVEL DA ROTINA DE TEMPO				
		TECLADO1 ; VARIÁVEL PARA MARCAR AS TECLAS  
		TECLADO2 ; VARIÁVEL PARA MARCAR AS TECLAS
		INDICE	 ; VARIÁVEL DE ÍNDICE
		TEMP	 ; VARIÁVEL TEMPORÁRIA		
		BUFFER0	 ; BUFFER PARA ARMAZENAR O BYTE
		BUFFER1  ; BUFFER PARA ARMAZENAR O BYTE
		BUFFER2  ; BUFFER PARA ARMAZENAR O BYTE
		BUFFER3  ; BUFFER PARA ARMAZENAR O BYTE
		BUFFER4	 ; BUFFER PARA ARMAZENAR O BYTE
		BUFFER5  ; BUFFER PARA ARMAZENAR O BYTE
		BUFFER6  ; BUFFER PARA ARMAZENAR O BYTE
		BUFFER7  ; BUFFER PARA ARMAZENAR O BYTE
		BUFFER8	 ; BUFFER PARA ARMAZENAR O BYTE
		BUFFER9  ; BUFFER PARA ARMAZENAR O BYTE
		BUFFER10 ; BUFFER PARA ARMAZENAR O BYTE
		BUFFER11 ; BUFFER PARA ARMAZENAR O BYTE
		BUFFER12 ; BUFFER PARA ARMAZENAR O BYTE
		BUFFER13 ; BUFFER PARA ARMAZENAR O BYTE
		BUFFER14 ; BUFFER PARA ARMAZENAR O BYTE
		BUFFER15 ; BUFFER PARA ARMAZENAR O BYTE
		INDICE_BUFFER ; INDICE PARA O BUFFER
		
		ENDERECO_HI ; VARIÁVEIS PARA CONTROLE DO	
		ENDERECO_LO ; ENDEREÇO DA EEPROM E FLASH
		BUFFER_I2C
		
	ENDC		 ; FIM DO BLOCO DE RAM(GPR)
	
	CBLOCK 0x70
		W_TEMP	 ; VARIÁVEIS TEMPORÁRIAS
		STATUS_TEMP	
		FSR_TEMP
		PCLATH_TEMP
	ENDC
		
;*	*	*	*	*	*	*	*	*	*
;*		          DEFINIÇÃO DE FLAGS				*
;*	*	*	*	*	*	*	*	*	*

; AQUI SÃO DEFINIDOS OS FLAGS QUE SERÃO UTILIZADOS PELO SISTEMA

#DEFINE  TECLA_0	TECLADO1,0  ; TECLA 0 DO TECLADO MATRICIAL
#DEFINE  TECLA_1	TECLADO1,1  ; TECLA 1 DO TECLADO MATRICIAL	
#DEFINE  TECLA_2	TECLADO1,2  ; TECLA 2 DO TECLADO MATRICIAL	
#DEFINE  TECLA_3	TECLADO1,3  ; TECLA 3 DO TECLADO MATRICIAL
#DEFINE  TECLA_4	TECLADO1,4  ; TECLA 4 DO TECLADO MATRICIAL
#DEFINE  TECLA_5	TECLADO1,5  ; TECLA 5 DO TECLADO MATRICIAL
#DEFINE  TECLA_6	TECLADO1,6  ; TECLA 6 DO TECLADO MATRICIAL
#DEFINE  TECLA_7	TECLADO1,7  ; TECLA 7 DO TECLADO MATRICIAL
#DEFINE  TECLA_8	TECLADO2,0  ; TECLA 8 DO TECLADO MATRICIAL
#DEFINE  TECLA_9	TECLADO2,1  ; TECLA 9 DO TECLADO MATRICIAL
#DEFINE  TECLA_C	TECLADO2,2  ; TECLA CORRIGE DO TECLADO MATRICIAL
#DEFINE  TECLA_E	TECLADO2,3  ; TECLA ENTER DO TECLADO MATRICIAL
	
;*	*	*	*	*	*	*	*	*	*
;*		        DEFINIÇÃO DE CONSTANTES				*
;*	*	*	*	*	*	*	*	*	*

; AQUI SÃO DEFINIDOS AS CONSTANTES QUE SERÃO UTILIZADOS PELO SISTEMA

#DEFINE LINHA_SUP	0x80	; CONSTANTE PARA LINHA SUPERIOR
#DEFINE LINHA_INF	0xC0	; CONSTANTE PARA LINHA INFERIOR
#DEFINE	TEMPO_BEEP	.10	; CONSTANTE PARA TOCAR BEEP(MULTIPLOS DE 1ms) 

#DEFINE SEL_LINHA1	B'00001110'  ; SELECIONA LINHA 1	
#DEFINE SEL_LINHA2	B'00001101'  ; SELECIONA LINHA 2		
#DEFINE SEL_LINHA3	B'00001011'  ; SELECIONA LINHA 3		
#DEFINE SEL_LINHA4	B'00000111'  ; SELECIONA LINHA 4	

;*	*	*	*	*	*	*	*	*	*
;*			  ENTRADAS DO SISTEMA				*
;*	*	*	*	*	*	*	*	*	*

#DEFINE COL1		PORTA,4	     ; PINO DE ENTRADA DA COLUNA1	
#DEFINE COL2		PORTA,5	     ; PINO DE ENTRADA DA COLUNA2		
#DEFINE COL3		PORTE,0	     ; PINO DE ENTRADA DA COLUNA3		

;*	*	*	*	*	*	*	*	*	*
;*			  SAÍDAS DO SISTEMA				*
;*	*	*	*	*	*	*	*	*	*

; AQUI SÃO DEFINIDAS AS SAÍDAS QUE SERÃO UTILIZADOS PELO SISTEMA

#DEFINE BUS		PORTD	; DEFINE O BARRAMENTO COMO O PORTD 
#DEFINE RS		PORTE,1	; RS DO DISPLAY
#DEFINE EN		PORTE,2 ; EN DO DISPLAY
#DEFINE BEEP		PORTC,5	; SAÍDA PARA LIGAR O BEEP

;*	*	*	*	*	*	*	*	*	*
;*		        INICIALIZAÇÃO DA EEPROM				*
;*	*	*	*	*	*	*	*	*	*

	ORG 	0x2100
	DE	"Apice Treinamen."

;*	*	*	*	*	*	*	*	*	*
;*			    VETOR DE RESET				*
;*	*	*	*	*	*	*	*	*	*

	ORG 	0x0000		; ENDEREÇO INICIAL DA MÁQUINA
	GOTO	CONFIG_		; SALTA PARA CONFIGURAR A MÁQUINA

;*	*	*	*	*	*	*	*	*	*
;*		         VETOR DE INTERRUPÇÃO				*
;*	*	*	*	*	*	*	*	*	*

	ORG 	0x0004		; ENDEREÇO INICIAL DO VETOR DE INTERRUPÇÃO
SALVA_CONTEXTO
	MOVWF	W_TEMP		; SALVA W
	SWAPF	STATUS,W	
	MOVWF	STATUS_TEMP	; SALVA STATUS
	MOVF	FSR,W
	MOVWF	FSR_TEMP	; SALVA FSR	
	MOVF	PCLATH,W	
	MOVWF	PCLATH_TEMP	; SALVA PCLATH
	
	CLRF	STATUS		; GARANTE BANCO 0
	CLRF	PCLATH		; GARANTE PÁGINA 0
	
	BTFSC	PIR1,RCIF	; INTERRUPÇÃO SERIAL?
	GOTO	TRATA_SERIAL	; SIM, ENTÃO TRATA
	
	BTFSC	INTCON,T0IF	; INTERRUPÇÃO DE TIMER0?
	GOTO	TRATA_TIMER0	; SIM, ENTÃO TRATA
	
SAI_INTERRUPCAO	
	MOVF	FSR_TEMP,W
	MOVWF	FSR		; RECUPERA FSR
	MOVF	PCLATH_TEMP,W	
	MOVWF	PCLATH		; RECUPERA PCLATH
	SWAPF	STATUS_TEMP,W
	MOVWF	STATUS		; RECUPERA STATUS
	SWAPF	W_TEMP,F
	SWAPF	W_TEMP,W	; RECUPERA W
	RETFIE			; RETORNA DA INTERRUPÇÃO

;*	*	*	*	*	*	*	*	*	*
;*     	            TRATATAMENTO DE INTERRUPÇÃO DE TIMER0		*
;*	*	*	*	*	*	*	*	*	*

TRATA_TIMER0
	
	BCF	INTCON,T0IF	 ; LIMPA FLAG DE INTERRUPÇÃO
	INCF	INDICE		 ; INCREMENTA INDICE 
	MOVLW	B'00000011'	 
	ANDWF	INDICE,W	 ; MASCARA OS BITS SUPERIORES	
	ADDWF	PCL,F	 	 ; SOMA CONTEÚDO COM PCL	
	GOTO	VERIFICA_LINHA1	 ; SALTA PARA TRATAR A LINHA 1
	GOTO	VERIFICA_LINHA2	 ; SALTA PARA TRATAR A LINHA 2
	GOTO	VERIFICA_LINHA3	 ; SALTA PARA TRATAR A LINHA 3
	GOTO	VERIFICA_LINHA4	 ; SALTA PARA TRATAR A LINHA 4
	

VERIFICA_LINHA1
	
	MOVLW	SEL_LINHA1	
	MOVWF	BUS		; SELECIONA A LINHA 1	
	
	BCF	TECLA_1		; LIMPA FLAG DA TECLA 1 PRESSIONADA
	BCF	TECLA_2		; LIMPA FLAG DA TECLA 2 PRESSIONADA
	BCF	TECLA_3		; LIMPA FLAG DA TECLA 3 PRESSIONADA
		
	BTFSS	COL1		; COLUNA1 ESTÁ PRESSIONADA?
	BSF	TECLA_1		; SIM, ENTÃO SETA TECLA_1
	
	BTFSS	COL2		; COLUNA2 ESTÁ PRESSIONADA?
	BSF	TECLA_2		; SIM, ENTÃO SETA TECLA_2
	
	BTFSS	COL3		; COLUNA3 ESTÁ PRESSIONADA?
	BSF	TECLA_3		; SIM, ENTÃO SETA TECLA_3
	
	GOTO	SAI_INTERRUPCAO	; SAI DA INTERRUPÇÃO
	
VERIFICA_LINHA2
	
	MOVLW	SEL_LINHA2
	MOVWF	BUS		; SELECIONA A LINHA 2	
	
	BCF	TECLA_4		; LIMPA FLAG DA TECLA 4 PRESSIONADA
	BCF	TECLA_5		; LIMPA FLAG DA TECLA 5 PRESSIONADA
	BCF	TECLA_6		; LIMPA FLAG DA TECLA 6 PRESSIONADA
		
	BTFSS	COL1		; COLUNA1 ESTÁ PRESSIONADA?
	BSF	TECLA_4		; SIM, ENTÃO SETA TECLA_4
	
	BTFSS	COL2		; COLUNA2 ESTÁ PRESSIONADA?
	BSF	TECLA_5		; SIM, ENTÃO SETA TECLA_5
	
	BTFSS	COL3		; COLUNA3 ESTÁ PRESSIONADA?
	BSF	TECLA_6		; SIM, ENTÃO SETA TECLA_6
	
	GOTO	SAI_INTERRUPCAO	; SAI DA INTERRUPÇÃO

VERIFICA_LINHA3
	
	MOVLW	SEL_LINHA3
	MOVWF	BUS		; SELECIONA A LINHA 3	
	
	BCF	TECLA_7		; LIMPA FLAG DA TECLA 7 PRESSIONADA
	BCF	TECLA_8		; LIMPA FLAG DA TECLA 8 PRESSIONADA
	BCF	TECLA_9		; LIMPA FLAG DA TECLA 9 PRESSIONADA
		
	BTFSS	COL1		; COLUNA1 ESTÁ PRESSIONADA?
	BSF	TECLA_7		; SIM, ENTÃO SETA TECLA_7
	
	BTFSS	COL2		; COLUNA2 ESTÁ PRESSIONADA?
	BSF	TECLA_8		; SIM, ENTÃO SETA TECLA_8
	
	BTFSS	COL3		; COLUNA3 ESTÁ PRESSIONADA?
	BSF	TECLA_9		; SIM, ENTÃO SETA TECLA_9
	
	GOTO	SAI_INTERRUPCAO	; SAI DA INTERRUPÇÃO

VERIFICA_LINHA4
	
	MOVLW	SEL_LINHA4	
	MOVWF	BUS		; SELECIONA A LINHA 4	
	
	BCF	TECLA_E		; LIMPA FLAG DA TECLA ENTER PRESSIONADA
	BCF	TECLA_C		; LIMPA FLAG DA TECLA CORRIGE PRESSIONADA
	BCF	TECLA_0		; LIMPA FLAG DA TECLA 0 PRESSIONADA
		
	BTFSS	COL1		; COLUNA1 ESTÁ PRESSIONADA?
	BSF	TECLA_C		; SIM, ENTÃO SETA TECLA_C
	
	BTFSS	COL2		; COLUNA2 ESTÁ PRESSIONADA?
	BSF	TECLA_0		; SIM, ENTÃO SETA TECLA_0
	
	BTFSS	COL3		; COLUNA3 ESTÁ PRESSIONADA?
	BSF	TECLA_E		; SIM, ENTÃO SETA TECLA_E
	
	GOTO	SAI_INTERRUPCAO	; SAI DA INTERRUPÇÃO

;*	*	*	*	*	*	*	*	*	*
;*     	            TRATATAMENTO DE INTERRUPÇÃO SERIAL			*
;*	*	*	*	*	*	*	*	*	*

TRATA_SERIAL
	
	MOVLW	.16		
	XORWF	INDICE_BUFFER,W 
	BTFSS	STATUS,Z	; INDICE_BUFFER CHEGOU A 16?
	GOTO	TRATA_SERIAL_A	; NÃO, ENTÃO SALTA PARA TRATA_SERIAL_A
	CLRF	INDICE_BUFFER	; SIM, ENTÃO LIMPA O ÍNDICE
	MOVLW	0x80		; MOVE O PONTEIRO DO DISPLAY PARA A 
	CALL	ENVIA_COMANDO_INT ; PRIMEIRA LINHA E PRIMEIRA COLUNA

TRATA_SERIAL_A
	
	MOVLW	BUFFER0		; PREPARA O PONTEIRO
	ADDWF	INDICE_BUFFER,W
	MOVWF	FSR
	INCF	INDICE_BUFFER
	
	MOVF	RCREG,W		
	MOVWF	INDF		; SALVA O DADO NO PONTEIRO
	CALL	ENVIA_DADO_INT	; CHAMA ROTINA PARA ENVIAR O DADO 
				; O DISPLAY
	GOTO	SAI_INTERRUPCAO	; SAI DA INTERRUPÇÃO

;*	*	*	*	*	*	*	*	*	*
;*	                  ROTINA PARA TOCAR O BEEP			*
;*	*	*	*	*	*	*	*	*	*

TOCA_BEEP
	
	BSF	BEEP		; LIGA O BEEP
	MOVLW	.200		
	CALL	DELAY_MS	; AGUARDA 200ms
	BCF	BEEP		; DESLIGA O BEEP
	RETURN			; RETORNA
				
;*	*	*	*	*	*	*	*	*	*
;*	              ROTINA DE DELAY DE 1ms A 256ms			*
;*	*	*	*	*	*	*	*	*	*
	
DELAY_MS
	
	CLRWDT
	
	MOVWF	TEMPO2		; SALVA O VALOR MULTIPLICADOR
	CLRF	TEMPO1		; LIMPA REGISTRADOR

DELAY_A
	
	NOP			; PERDE 1 CICLO DE MÁQUINA
	DECFSZ	TEMPO1,F	; DECREMENTA REGISTRADOR, ACABOU?
	GOTO	$-2		; NÃO, ENTÃO RETORNA DUAS POSIÇÕES 
	DECFSZ	TEMPO2,F
	GOTO	DELAY_A
	
	RETURN			; RETORNA DA INTERRUPÇÃO

;*	*	*	*	*	*	*	*	*	*
;*	          ROTINA PARA ESCREVER DADOS NO DISPLAY			*
;*	*	*	*	*	*	*	*	*	*

ENVIA_COMANDO
	
	BCF	RS		; PÕE EM MODO DE COMANDO
	
ENVIA_DADO
	
	BCF	INTCON,GIE	; DESLIGA A INTERRUPÇÃO
	
	MOVWF	BUS		; MOVE DADO PARA O PORTD
		
	GOTO	$+1		; DEÇAY PARA ACOMODAÇÃO
	GOTO	$+1		
	
	BSF	EN		; GERA PULSO DE CLOCK
	GOTO	$+1
	BCF	EN
	
	BSF	RS		; VOLTA PARA O MODO DADOS
	MOVLW	.1
	CALL	DELAY_MS
	BSF	INTCON,GIE	; LIGA A INTERRUPÇÃO
	RETURN			; RETORNA DA INTERRUPÇÃO

;*	*	*	*	*	*	*	*	*	*
;*         ROTINA PARA ESCREVER DADOS NO DISPLAY PELA INTERRUPÇÃO	*
;*	*	*	*	*	*	*	*	*	*

ENVIA_COMANDO_INT
	
	BCF	RS		; PÕE EM MODO DE COMANDO
	
ENVIA_DADO_INT
	
	MOVWF	BUS		; MOVE DADO PARA O PORTD
		
	GOTO	$+1		; DEÇAY PARA ACOMODAÇÃO
	GOTO	$+1		
	
	BSF	EN		; GERA PULSO DE CLOCK
	GOTO	$+1
	BCF	EN
	
	BSF	RS		; VOLTA PARA O MODO DADOS
	MOVLW	.1
	CALL	DELAY_MS
	RETURN			; RETORNA DA INTERRUPÇÃO

;*	*	*	*	*	*	*	*	*	*
;*		     ROTINA PARA SALVAR O BUFFER NA EEPROM 		*
;*	*	*	*	*	*	*	*	*	*

GUARDA_BUFFER
	
	CALL	TOCA_BEEP	; CHAMA ROTINA PARA TOCAR O BEEP	
	
	CLRF	ENDERECO_LO	; LIMPA O APONTADOR DE ENDEREÇOS
	
	MOVLW	BUFFER0
	MOVWF	FSR
	
GUARDA_A

	MOVF	INDF,W
	MOVWF	BUFFER_I2C
	CALL	ESCREVE_I2C
	INCF	FSR,F
	INCF	ENDERECO_LO,F
	MOVLW	.16
	XORWF	ENDERECO_LO,W
	BTFSS	STATUS,Z
	GOTO	GUARDA_A 
	 
	CLRWDT
	BTFSC	TECLA_E		; AGUARDA SOLTAR A TECLA
	GOTO	$-2
	
	CALL	TOCA_BEEP	; CHAMA ROTINA PARA TOCAR O BEEP	
	RETURN			; RETORNA DA ROTINA

;*	*	*	*	*	*	*	*	*	*
;*		     ROTINA PARA LER O BUFFER DA EEPROM			*
;*	*	*	*	*	*	*	*	*	*

LE_DADOS
	
	CALL	LE_I2C		; CHAMA ROTINA PARA LER A EEPROM	
	CALL	ENVIA_DADO	; ENVIA O DADO LIDO PARA O DISPLAY
	INCF	ENDERECO_LO	; INCREMENTA O APONTADOR DE ENDEREÇOS
	MOVLW	.16	
	XORWF	ENDERECO_LO,W	; VERIFICA SE ACABOU DE LER TUDO
	BTFSS	STATUS,Z
	GOTO	LE_DADOS		
	
	MOVLW	0x80		; POSICIONA O DISPLAY PARA A PRIMEIRA
	CALL	ENVIA_COMANDO	; LINHA E PRIMEIRA COLUNA
		
	RETURN			; RETORNA DA ROTINA	


;*	*	*	*	*	*	*	*	*	*
;*	           ROTINAS DE ACESSO AO BARRAMENTO I2C			*
;*	*	*	*	*	*	*	*	*	*

;*	*	*	*	*	*	*	*	*	*
;*         ROTINA PARA AGUARDAR PARA AGUARDAR O BARRAMENTO LIVRE	*
;*	*	*	*	*	*	*	*	*	*

AGUARDA_I2C

	BANK1
	BTFSC	SSPSTAT,R_W	; AGUARDA O BARRAMENTO FICAR LIVRE	
	GOTO	$-1
	MOVF	SSPCON2,W
	ANDLW	B'00011111'
	BTFSS	STATUS,Z
	GOTO	$-3
	BANK0
	RETURN			; RETORNA

;*	*	*	*	*	*	*	*	*	*
;*		          ROTINA PARA ENVIAR NACK			*
;*	*	*	*	*	*	*	*	*	*

ENVIA_NACK

	BANK1
	BSF	SSPCON2,ACKDT	; ENVIA NACK
	BSF	SSPCON2,ACKEN
	BANK0
	CALL	AGUARDA_I2C	; AGUARDA O BARRAMENTO FICAR LIVRE	
	RETURN			; RETORNA

;*	*	*	*	*	*	*	*	*	*
;*               ROTINA PARA ENVIAR O START-BIT PARA MEMÓRIA 		*
;*	*	*	*	*	*	*	*	*	*
	
ENVIA_START

	BANK1
	BSF	SSPCON2,SEN	; ENVIA START-BIT
	BANK0
	CALL	AGUARDA_I2C	; AGUARDA O BARRAMENTO FICAR LIVRE
	RETURN

;*	*	*	*	*	*	*	*	*	*
;*           ROTINA PARA ENVIAR O ENDEREÇO DE LEITURA DA EEPROM 	*
;*	*	*	*	*	*	*	*	*	*

ENVIA_ENDERECO

	BCF	STATUS,C
	RLF	ENDERECO_HI,W	; ENVIA ENDEREÇO
	IORLW	B'10100000'
	MOVWF	SSPBUF
	CALL	AGUARDA_I2C
	
 
;*	*	*	*	*	*	*	*	*	*
;*        ROTINA PARA ENVIAR RESTART PARA A MEMÓRIA EEPROM EXTERNA	*
;*	*	*	*	*	*	*	*	*	*

ENVIA_RESTART

	BANK1
	BSF	SSPCON2,RSEN	; ENVIA RESTART
	BANK0
	CALL	AGUARDA_I2C	; AGUARDA BARRAMENTO FICAR LIVRE
	RETURN

;*	*	*	*	*	*	*	*	*	*
;*    ROTINA PARA ENVIAR PEDIDO DE LEITURA A MEMÓRIA SERIAL EXTERNA	*
;*	*	*	*	*	*	*	*	*	*

ENVIA_LEITURA
	
	RLF	ENDERECO_HI,W	; ENVIA COMANDO DE LEITURA
	IORLW	B'10100001'
	MOVWF	SSPBUF
	CALL	AGUARDA_I2C	; AGUARDA O BARRAMENTO FICAR LIVRE
	RETURN			; RETORNA

;*	*	*	*	*	*	*	*	*	*
;*               ROTINA PARA LER 1 BYTE DA EEPROM EXTERNA		*
;*	*	*	*	*	*	*	*	*	*

LE_BYTE_I2C
	
	BANK1
	BSF	SSPCON2,RCEN	; INCIA LEITURA DE DADOS
	BANK0
	CALL	AGUARDA_I2C	; AGUARDA O BARRAMENTO FICAR LIVRE 
	MOVF	SSPBUF,W	; MOVE O DADO LIDO PARA W
	MOVWF	BUFFER_I2C	; MOVE W PARA BUFFER_I2C
	RETURN			; RETORNA

;*	*	*	*	*	*	*	*	*	*
;*          ROTINA PARA ENVIAR STOP-BIT PARADA EEPROM EXTERNA		*
;*	*	*	*	*	*	*	*	*	*

ENVIA_STOP
	
	BANK1
	BSF	SSPCON2,PEN	; ENVIA STOP-BIT
	BANK0
	CALL	AGUARDA_I2C	; AGUARDA O BARRAMENTO FICAR LIVRE
	RETURN			; RETORNA

;*	*	*	*	*	*	*	*	*	*
;*            ROTINA PARA ENVIAR DADOS PARA A EEPROM EXTERNA		*
;*	*	*	*	*	*	*	*	*	*

ENVIA_BYTE
	
	MOVF	BUFFER_I2C,W	; MOVE BYTE DE A SER
	MOVWF	SSPBUF		; ESCRITO PARA SSPBUF
	CALL	AGUARDA_I2C	; AGUARDA O BARRAMENTO FICAR LIVRE
	RETURN			; RETORNA
									
;*	*	*	*	*	*	*	*	*	*
;*               ROTINA PARA LER DADOS DA EEPROM EXTERNA		*
;*	*	*	*	*	*	*	*	*	*

LE_I2C

	CALL	ENVIA_START	; ENVIA START-BIT
	CALL	ENVIA_ENDERECO	; ENVIA CONTROLE + ENDEREÇO
	CALL	ENVIA_RESTART	; ENVIA RESTART
	CALL	ENVIA_LEITURA	; ENVIA COMANDO PARA LEITURA
	CALL	LE_BYTE_I2C	; LÊ O BYTE DA I2C
	CALL	ENVIA_NACK	; ENVIA NACK
	CALL	ENVIA_STOP	; ENVIA STOP-BIT
	MOVF	BUFFER_I2C,W	; MOVE O DADO LIDO PARA W
	RETURN			; RETORNA DA ROTINA

;*	*	*	*	*	*	*	*	*	*
;*               ROTINA PARA ESCREVER DADOS NA EEPROM EXTERNA		*
;*	*	*	*	*	*	*	*	*	*

ESCREVE_I2C

	CALL	ENVIA_START	; ENVIA START-BIT
	CALL	ENVIA_ENDERECO	; ENVIA CONTROLE + ENDEREÇO
	CALL	ENVIA_BYTE	; ENVIA BYTE PARA ESCRITA
	CALL	ENVIA_STOP	; ENVIA STOP-BIT
	MOVLW	.5		
	CALL	DELAY_MS	; TEMPO PRA GRAVAÇÃO
	RETURN			; RETORNA DA SUB-ROTINA

;*	*	*	*	*	*	*	*	*	*
;*	       ROTINA PARA RECUPERAR O DADO SALVO NA EEPROM		*
;*	*	*	*	*	*	*	*	*	*

RECUPERA_EEPROM

	CALL	TOCA_BEEP	; CHAMA ROTINA PARA TOCAR O BEEP
	MOVLW	0x80
	CALL	ENVIA_COMANDO	; POSICIONA INÍCIO DA LINHA
	CLRF	ENDERECO_LO	; ZERA O ENDEREÇO
	CALL	LE_DADOS	; LÊ DADOS DA I2C	
	
	CLRWDT
	BTFSC	TECLA_C		; AGUARDA SOLTAR A TECLA
	GOTO	$-2
	
	CALL	TOCA_BEEP	; CHAMA ROTINA PARA TOCAR O BEEP
	RETURN
			
;*	*	*	*	*	*	*	*	*	*
;*		          CONFIGURACOES INICIAIS			*
;*	*	*	*	*	*	*	*	*	*

CONFIG_

	CLRF	PORTA		; LIMPA O PORTA
	CLRF	PORTB		; LIMPA O PORTB
	CLRF	PORTC		; LIMPA O PORTC
	CLRF	PORTD		; LIMPA O PORTD
	CLRF	PORTE		; LIMPA O PORTE
	
	BANK1			; SELECIONA BANCO1 DE MEMÓRIA
	
	MOVLW	B'11111111'
	MOVWF	TRISA
	
	MOVLW	B'11000000'
	MOVWF	TRISB		; CONFIGURA I/O DO PORTB
	
	MOVLW	B'11010111'
	MOVWF	TRISC		; CONFIGURA I/O DO PORTB
	
	MOVLW	B'00000000'	; CONFIGURA TODOS OS PINOS DESTE
	MOVWF	TRISD		; PORTB COMO SAÍDA
	
	MOVLW	B'00000001'
	MOVWF	TRISE		; CONFIGURA I/O DO PORTE
	
	MOVLW	B'10001111'	; DESLIGA PULL-UPS
	MOVWF	OPTION_REG	; WDT 1:128
	
	MOVLW	B'00100000'
	MOVWF	PIE1		; HABILITA A INTERUPÇÃO SERIAL
	
	MOVLW	B'01100000'	
	MOVWF	INTCON		; HABILITA A INTERRUPÇÃO DE TIMER 0
				; LIGA A CHAVE GERAL DE INTERRUPÇÃO
	
	MOVLW	B'00000111'	; DESLIGA OS A/D´S
	MOVWF	ADCON1
	
	MOVLW	.25
	MOVWF	SPBRG		; PREPARA PARA FUNCIONAR A 9600bps
	
	MOVLW	B'00100100'
	MOVWF	TXSTA		; CONFIGURA USART
	
	MOVLW	B'00001001'
	MOVWF	SSPADD
	
	MOVLW	B'10000000'
	MOVWF	SSPSTAT
	
	BANK0
	
	MOVLW	B'00101000'
	MOVWF	SSPCON
	
	MOVLW	B'10010000'
	MOVWF	RCSTA		; CONFIGURA USART
	
	BTFSC	STATUS,NOT_TO	; ESTOURO POR WDT?
	GOTO	$		; NÃO, ENTÃO AGUARDA
		
LIMPEZA_DA_RAM
				; ROTINA DE LIMPEZA DA RAM
				
	MOVLW	0x20
	MOVWF	FSR
	CLRF	INDF
	INCF	FSR,F
	MOVLW	0x80
	XORWF	FSR,W
	BTFSS	STATUS,Z
	GOTO	$-5

	BSF	INTCON,GIE	; LIGA AS INTERRUPÇÕES
	
;*	*	*	*	*	*	*	*	*	*
;*         	         INICIALIZAÇÃO DO DISPLAY			*
;*	*	*	*	*	*	*	*	*	*
	
	MOVLW	0x30			
	CALL	ENVIA_COMANDO		; COMANDO DE INICIALIZAÇÃO
	
	MOVLW	.3			
	CALL	DELAY_MS		; DELAY DE 3ms
	
	MOVLW	0x30			
	CALL	ENVIA_COMANDO		; COMANDO DE INICIALIZAÇÃO	
	
	MOVLW	0x30			
	CALL	ENVIA_COMANDO		; COMANDO DE INICIALIZAÇÃO
	
	MOVLW	0x38			
	CALL	ENVIA_COMANDO		; INTERFACE DE 8 VIAS
	
	MOVLW	0x01			
	CALL	ENVIA_COMANDO		; LIMPA O DISPLAY
	
	MOVLW	.1
	CALL	DELAY_MS		; CHAMA DELAY DE 3ms
	
	MOVLW	0x0C			
	CALL	ENVIA_COMANDO		; LIGAR O DISPLAY SEM CURSOR
	
	MOVLW	0x06			
	CALL	ENVIA_COMANDO		; LIGAR O DISPLAY SEM CURSOR
	
								
;*	*	*	*	*	*	*	*	*	*
;*         	         INICIALIZAÇÃO DAS VARIÁVEIS			*
;*	*	*	*	*	*	*	*	*	*
	
	CALL	LE_DADOS		; CHAMA ROTINA PARA CARREGAR O
					; ÚLTIMO DADO SALVA NA EEPROM 
	
;*	*	*	*	*	*	*	*	*	*
;*		            ROTINA PRINCIPAL				*
;*	*	*	*	*	*	*	*	*	*

LOOP
	CLRWDT			; LIMPA O WATCHDOG
	
	BTFSC	TECLA_C		; A TECLA ESTÁ PRESSIONADA?
	CALL	RECUPERA_EEPROM	; SIM, ENTÃO RECUPERA OS DADOS DA EEPROM

	BTFSC	TECLA_E		; A TECLA ESTÁ PRESSIONADA?
	CALL	GUARDA_BUFFER	; SIM, ENTÃO SALVA DADOS DO BUFFER NA EEPROM
	GOTO	LOOP		; NÃO, ENTÃO VOLTA PARA LOOP
			
;*	*	*	*	*	*	*	*	*	*
;*		             FIM DO PROGRAMA				*
;*	*	*	*	*	*	*	*	*	*


	END			; FIM DO PROGRAMA


