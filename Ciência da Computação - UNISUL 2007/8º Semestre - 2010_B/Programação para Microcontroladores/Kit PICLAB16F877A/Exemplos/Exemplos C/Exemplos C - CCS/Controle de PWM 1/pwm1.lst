CCS PCM C Compiler, Version 3.245, 28193               11-fev-07 18:21

               Filename: C:\Cerne\CDs\kit PICLAB16f877A\Exemplos\Exemplos C\Controle de PWM 1\pwm1.lst

               ROM used: 705 words (9%)
                         Largest free fragment is 2048
               RAM used: 17 (10%) at main() level
                         21 (12%) worst case
               Stack:    5 worst case (3 in main + 2 for interrupts)

*
0000:  MOVLW  00
0001:  MOVWF  0A
0002:  GOTO   267
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  MOVF   7B,W
0016:  MOVWF  27
0017:  BCF    03.7
0018:  BCF    03.5
0019:  BTFSS  0B.5
001A:  GOTO   01D
001B:  BTFSC  0B.2
001C:  GOTO   030
001D:  MOVF   22,W
001E:  MOVWF  04
001F:  MOVF   23,W
0020:  MOVWF  77
0021:  MOVF   24,W
0022:  MOVWF  78
0023:  MOVF   25,W
0024:  MOVWF  79
0025:  MOVF   26,W
0026:  MOVWF  7A
0027:  MOVF   27,W
0028:  MOVWF  7B
0029:  MOVF   20,W
002A:  MOVWF  0A
002B:  SWAPF  21,W
002C:  MOVWF  03
002D:  SWAPF  7F,F
002E:  SWAPF  7F,W
002F:  RETFIE
0030:  BCF    0A.3
0031:  BCF    0A.4
0032:  GOTO   08D
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *  		         Programação em C - Módulo B PIC16F877A                 	* 
....................  *                               Exemplo 11                                * 
....................  *                                                                         * 
....................  *                CENTRO DE TREINAMENTO - Cerne Tecnologia	               * 
....................  *                          www.cerne-tec.com.br                           * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *   VERSÃO : 1.0                                                          * 
....................  *   DATA : 16/05/2005                                                     * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                             Descrição geral                           * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
.................... // Demonstrar a utilização dos dois módulos de PWM 
.................... // utilizando para isto o ventilador e resistor externo 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                		 	Definição de Cabeçalho						 * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... #include	<16F877A.h>				//microcontrolador utilizado 
.................... //////// Standard Header file for the PIC16F877A device //////////////// 
.................... #device PIC16F877A  
.................... #list 
....................  
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                         Configurações para gravação                   * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... #fuses xt,nolvp,wdt,nolvp,nobrownout,put,nodebug,noprotect,nowrt,nocpd 
....................  								   // Configurações da Máquina 
....................                            // Oscilador: XT, LVP: Off, WDT: On 
....................                            // Brown-out: Off, Power-up: Off, Debug: Off 
....................                            // CP: Off, CPD: Off 
....................  
.................... #use delay(clock=4000000)		   // Utiliza biblioteca de delay										 
0106:  MOVLW  2F
0107:  MOVWF  04
0108:  MOVF   00,W
0109:  BTFSC  03.2
010A:  GOTO   11A
010B:  MOVLW  01
010C:  MOVWF  78
010D:  CLRF   77
010E:  DECFSZ 77,F
010F:  GOTO   10E
0110:  DECFSZ 78,F
0111:  GOTO   10D
0112:  MOVLW  4A
0113:  MOVWF  77
0114:  DECFSZ 77,F
0115:  GOTO   114
0116:  NOP
0117:  NOP
0118:  DECFSZ 00,F
0119:  GOTO   10B
011A:  RETLW  00
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                 Definição e inicialização das variáveis               * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
.................... //Aqui iremos definir as variáveis globais do sistema 
....................  
.................... int1 tecla0=0, tecla1=0, tecla2=0, tecla3=0, tecla4=0, tecla5=0, tecla6=0, 
*
0271:  BCF    03.5
0272:  BCF    28.0
0273:  BCF    28.1
0274:  BCF    28.2
0275:  BCF    28.3
0276:  BCF    28.4
0277:  BCF    28.5
0278:  BCF    28.6
....................      tecla7=0, tecla8=0, tecla9=0, teclaE=0, teclaC=0; 
0279:  BCF    28.7
027A:  BCF    29.0
027B:  BCF    29.1
027C:  BCF    29.2
027D:  BCF    29.3
....................  
.................... int indice=0; 
027E:  CLRF   2A
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                           Constantes internas                         * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
.................... //Aqui iremos definir as constantes utilizadas pelo sistema 
....................  
.................... #define SEL_LINHA1	0b00001110	// Seleção da linha 1 
.................... #define SEL_LINHA2	0b00001101	// Seleção da linha 2 
.................... #define SEL_LINHA3	0b00001011	// Seleção da linha 3 
.................... #define SEL_LINHA4	0b00000111	// Seleção da linha 4 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                                Entradas                               * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
.................... //Aqui iremos definir as entradas do sistema 
....................  
.................... #define  COL1	      PIN_A4 
.................... #define  COL2	      PIN_A5 
.................... #define  COL3        PIN_E0 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                                Saídas                               * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
.................... //Aqui iremos definir as saídas do sistema 
....................  
.................... #define  RS			  PIN_E2		// Pino de seleção de modo do display 
.................... #define  EN			  PIN_E1		// Pino de habilitação do display 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                       Prototipagem das funções                      * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
.................... //Aqui iremos declarar todas as funções definidas pelo usuário 
....................  
.................... void Inicializa(void);				// Prototipagem da procedure 
.................... void Tela_Inicial(void);			// Prototipagem da procedure 
.................... void Atualiza_PWM_0(int dado);		// Prototipagem da procedure 
.................... void Atualiza_PWM_20(int dado);		// Prototipagem da procedure 
.................... void Atualiza_PWM_40(int dado);		// Prototipagem da procedure 
.................... void Atualiza_PWM_60(int dado);		// Prototipagem da procedure 
.................... void Atualiza_PWM_80(int dado);		// Prototipagem da procedure 
.................... void Atualiza_PWM_100(int dado);	// Prototipagem da procedure 
.................... void Lcd_Inst(char dado);		  	// Prototipagem da procedure 
.................... void Lcd_Dado(char dado);			// Prototipagem da procedure 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                           Rotina Principal                		   * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
.................... //Nessa parte ficará o loop principal do sistema 
....................  
.................... void main (void) 
.................... { 
*
0267:  CLRF   04
0268:  MOVLW  1F
0269:  ANDWF  03,F
026A:  BSF    03.5
026B:  BSF    1F.0
026C:  BSF    1F.1
026D:  BSF    1F.2
026E:  BCF    1F.3
026F:  MOVLW  07
0270:  MOVWF  1C
.................... 	Inicializa();				// Chama rotina para inicializar o sistema 
*
0281:  GOTO   159
....................  
.................... 	while(1)			   		// Entra em loop infinito 
.................... 		{ 
.................... 			restart_wdt();		// Limpa o wdt 
0282:  CLRWDT
....................  
.................... 			if (tecla1)	Atualiza_PWM_0(0x8B);   // Atualiza PWM e LCD 
0283:  BTFSS  28.1
0284:  GOTO   288
0285:  MOVLW  8B
0286:  MOVWF  2C
0287:  CALL   1DF
.................... 			if (tecla2) Atualiza_PWM_20(0x8B);  // Atualiza PWM e LCD 
0288:  BTFSS  28.2
0289:  GOTO   28D
028A:  MOVLW  8B
028B:  MOVWF  2C
028C:  CALL   1F4
.................... 			if (tecla3) Atualiza_PWM_40(0x8B);  // Atualiza PWM e LCD 
028D:  BTFSS  28.3
028E:  GOTO   292
028F:  MOVLW  8B
0290:  MOVWF  2C
0291:  CALL   20B
.................... 	 		if (tecla4) Atualiza_PWM_60(0x8B);  // Atualiza PWM e LCD 
0292:  BTFSS  28.4
0293:  GOTO   297
0294:  MOVLW  8B
0295:  MOVWF  2C
0296:  CALL   222
.................... 			if (tecla5) Atualiza_PWM_80(0x8B);  // Atualiza PWM e LCD 
0297:  BTFSS  28.5
0298:  GOTO   29C
0299:  MOVLW  8B
029A:  MOVWF  2C
029B:  CALL   239
.................... 	 		if (tecla6) Atualiza_PWM_100(0x8B); // Atualiza PWM e LCD 
029C:  BTFSS  28.6
029D:  GOTO   2A1
029E:  MOVLW  8B
029F:  MOVWF  2C
02A0:  CALL   250
....................  
.................... 			if (tecla7)	Atualiza_PWM_0(0xCB);   // Atualiza PWM e LCD 
02A1:  BTFSS  28.7
02A2:  GOTO   2A6
02A3:  MOVLW  CB
02A4:  MOVWF  2C
02A5:  CALL   1DF
.................... 			if (tecla8) Atualiza_PWM_20(0xCB);  // Atualiza PWM e LCD 
02A6:  BTFSS  29.0
02A7:  GOTO   2AB
02A8:  MOVLW  CB
02A9:  MOVWF  2C
02AA:  CALL   1F4
.................... 			if (tecla9) Atualiza_PWM_40(0xCB);  // Atualiza PWM e LCD 
02AB:  BTFSS  29.1
02AC:  GOTO   2B0
02AD:  MOVLW  CB
02AE:  MOVWF  2C
02AF:  CALL   20B
.................... 	 		if (teclaC) Atualiza_PWM_60(0xCB);  // Atualiza PWM e LCD 
02B0:  BTFSS  29.3
02B1:  GOTO   2B5
02B2:  MOVLW  CB
02B3:  MOVWF  2C
02B4:  CALL   222
.................... 			if (tecla0) Atualiza_PWM_80(0xCB);  // Atualiza PWM e LCD 
02B5:  BTFSS  28.0
02B6:  GOTO   2BA
02B7:  MOVLW  CB
02B8:  MOVWF  2C
02B9:  CALL   239
.................... 	 		if (teclaE) Atualiza_PWM_100(0xCB); // Atualiza PWM e LCD 
02BA:  BTFSS  29.2
02BB:  GOTO   2BF
02BC:  MOVLW  CB
02BD:  MOVWF  2C
02BE:  CALL   250
....................  
.................... 		} 
02BF:  GOTO   282
.................... } 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                       Inicialização do Sistema                 	   * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void Inicializa(void) 
.................... { 
02C0:  SLEEP
....................  
....................    delay_ms(2000); 
*
0159:  MOVLW  08
015A:  MOVWF  2C
015B:  MOVLW  FA
015C:  MOVWF  2F
015D:  CALL   106
015E:  DECFSZ 2C,F
015F:  GOTO   15B
....................  
....................    setup_adc_ports(no_analogs);   // Todos os AD´s desligados 
0160:  BSF    03.5
0161:  BSF    1F.0
0162:  BSF    1F.1
0163:  BSF    1F.2
0164:  BCF    1F.3
....................  
....................    setup_ccp1(CCP_PWM);			  // Confirura modo CCP para PWM 
0165:  BCF    03.5
0166:  BCF    2B.2
0167:  MOVF   2B,W
0168:  BSF    03.5
0169:  MOVWF  07
016A:  BCF    03.5
016B:  BCF    07.2
016C:  MOVLW  0C
016D:  MOVWF  17
*
027F:  MOVLW  FF
0280:  MOVWF  2B
....................    setup_ccp2(CCP_PWM); 
*
016E:  BCF    2B.1
016F:  MOVF   2B,W
0170:  BSF    03.5
0171:  MOVWF  07
0172:  BCF    03.5
0173:  BCF    07.1
0174:  MOVLW  0C
0175:  MOVWF  1D
....................  
....................    output_low(PIN_C1); 
0176:  BCF    2B.1
0177:  MOVF   2B,W
0178:  BSF    03.5
0179:  MOVWF  07
017A:  BCF    03.5
017B:  BCF    07.1
....................    output_low(PIN_C2);			  // Garante estado do port 
017C:  BCF    2B.2
017D:  MOVF   2B,W
017E:  BSF    03.5
017F:  MOVWF  07
0180:  BCF    03.5
0181:  BCF    07.2
....................  
....................    set_pwm1_duty(0); 
0182:  CLRF   15
....................    set_pwm2_duty(0);			  // Garante estado inicial do modo CCP 
0183:  CLRF   1B
....................  
....................    setup_timer_2(T2_DIV_BY_4,249,1); 
0184:  MOVLW  00
0185:  MOVWF  78
0186:  IORLW  05
0187:  MOVWF  12
0188:  MOVLW  F9
0189:  BSF    03.5
018A:  MOVWF  12
....................  
....................    set_timer0(0);                 // Inicializa timer 0 com 0 
018B:  BCF    03.5
018C:  CLRF   01
....................    setup_timer_0(RTCC_INTERNAL | RTCC_DIV_1); // Timer configurado para clock 
018D:  BSF    03.5
018E:  MOVF   01,W
018F:  ANDLW  C7
0190:  IORLW  08
0191:  MOVWF  01
....................                                               // Interno com prescaler de 1:4 
....................    setup_wdt(WDT_2304MS);         // Configura WDT para 2,304 s 
0192:  MOVLW  0F
0193:  MOVWF  77
0194:  MOVLW  07
0195:  BCF    03.5
0196:  CLRF   01
0197:  MOVLW  81
0198:  MOVWF  04
0199:  MOVF   00,W
019A:  ANDLW  F0
019B:  IORLW  07
019C:  MOVWF  00
019D:  CLRWDT
019E:  MOVF   00,W
019F:  ANDLW  F7
01A0:  BTFSC  77.3
01A1:  ANDLW  F0
01A2:  IORWF  77,W
01A3:  MOVWF  00
....................    enable_interrupts(INT_TIMER0); // Habilita interrupção de timer 0 
01A4:  BSF    0B.5
....................    enable_interrupts(GLOBAL);     // Habilita todas as interrupções 
01A5:  MOVLW  C0
01A6:  IORWF  0B,F
....................  
....................    Lcd_Inst(0x30);			      // Inicializa o display 
01A7:  MOVLW  30
01A8:  MOVWF  2D
01A9:  CALL   11B
....................    delay_ms(3); 
01AA:  MOVLW  03
01AB:  MOVWF  2F
01AC:  CALL   106
....................    Lcd_Inst(0x30); 
01AD:  MOVLW  30
01AE:  MOVWF  2D
01AF:  CALL   11B
....................    Lcd_Inst(0x30); 
01B0:  MOVLW  30
01B1:  MOVWF  2D
01B2:  CALL   11B
....................    Lcd_Inst(0x38); 
01B3:  MOVLW  38
01B4:  MOVWF  2D
01B5:  CALL   11B
....................    Lcd_Inst(0x01); 
01B6:  MOVLW  01
01B7:  MOVWF  2D
01B8:  CALL   11B
....................    delay_ms(1); 
01B9:  MOVLW  01
01BA:  MOVWF  2F
01BB:  CALL   106
....................    Lcd_Inst(0x0C); 
01BC:  MOVLW  0C
01BD:  MOVWF  2D
01BE:  CALL   11B
....................    Lcd_Inst(0x06); 
01BF:  MOVLW  06
01C0:  MOVWF  2D
01C1:  CALL   11B
....................    Tela_Inicial(); 
.................... } 
*
01DC:  BCF    0A.3
01DD:  BCF    0A.4
01DE:  GOTO   282 (RETURN)
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                 Rotina para Apresentar a Tela Inicial               * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void Tela_Inicial(void) 
.................... { 
....................  
.................... 	Lcd_Inst(0x80);			// Atualiza a tela do LCD 
*
01C2:  MOVLW  80
01C3:  MOVWF  2D
01C4:  CALL   11B
....................    printf(lcd_dado,"CCP1(Vent): 0  %"); 
01C5:  CLRF   2C
01C6:  MOVF   2C,W
01C7:  CALL   033
01C8:  IORLW  00
01C9:  BTFSC  03.2
01CA:  GOTO   1CF
01CB:  INCF   2C,F
01CC:  MOVWF  2E
01CD:  CALL   13A
01CE:  GOTO   1C6
....................  
.................... 	Lcd_Inst(0xC0);			// Atualiza a tela do LCD 
01CF:  MOVLW  C0
01D0:  MOVWF  2D
01D1:  CALL   11B
....................    printf(lcd_dado,"CCP2(Resi): 0  %");   
01D2:  CLRF   2C
01D3:  MOVF   2C,W
01D4:  CALL   048
01D5:  IORLW  00
01D6:  BTFSC  03.2
01D7:  GOTO   1DC
01D8:  INCF   2C,F
01D9:  MOVWF  2E
01DA:  CALL   13A
01DB:  GOTO   1D3
....................  
.................... } 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *           Rotina para Atualizar o Duty-Cycle do PWM para 0%         * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void Atualiza_PWM_0(int dado) 
.................... { 
....................    Lcd_Inst(dado); 
*
01DF:  MOVF   2C,W
01E0:  MOVWF  2D
01E1:  CALL   11B
....................    printf(lcd_dado," 0 "); 
01E2:  CLRF   2D
01E3:  MOVF   2D,W
01E4:  CALL   05D
01E5:  IORLW  00
01E6:  BTFSC  03.2
01E7:  GOTO   1EC
01E8:  INCF   2D,F
01E9:  MOVWF  2E
01EA:  CALL   13A
01EB:  GOTO   1E3
....................  
.................... 	if(dado==0x8B) 
01EC:  MOVF   2C,W
01ED:  SUBLW  8B
01EE:  BTFSS  03.2
01EF:  GOTO   1F2
.................... 	 { set_pwm1_duty(0);} 
01F0:  CLRF   15
.................... 	else 
01F1:  GOTO   1F3
.................... 	 { set_pwm2_duty(0);} 
01F2:  CLRF   1B
.................... } 
01F3:  RETLW  00
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *           Rotina para Atualizar o Duty-Cycle do PWM para 20%        * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void Atualiza_PWM_20(int dado) 
.................... { 
....................     Lcd_Inst(dado); 
01F4:  MOVF   2C,W
01F5:  MOVWF  2D
01F6:  CALL   11B
....................     printf(lcd_dado," 20"); 
01F7:  CLRF   2D
01F8:  MOVF   2D,W
01F9:  CALL   065
01FA:  IORLW  00
01FB:  BTFSC  03.2
01FC:  GOTO   201
01FD:  INCF   2D,F
01FE:  MOVWF  2E
01FF:  CALL   13A
0200:  GOTO   1F8
....................  
.................... 	if(dado==0x8B) 
0201:  MOVF   2C,W
0202:  SUBLW  8B
0203:  BTFSS  03.2
0204:  GOTO   208
.................... 	 { set_pwm1_duty(50);} 
0205:  MOVLW  32
0206:  MOVWF  15
.................... 	else 
0207:  GOTO   20A
.................... 	 { set_pwm2_duty(50);} 
0208:  MOVLW  32
0209:  MOVWF  1B
.................... } 
020A:  RETLW  00
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *           Rotina para Atualizar o Duty-Cycle do PWM para 40%        * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void Atualiza_PWM_40(int dado) 
.................... { 
....................     Lcd_Inst(dado); 
020B:  MOVF   2C,W
020C:  MOVWF  2D
020D:  CALL   11B
....................     printf(lcd_dado," 40"); 
020E:  CLRF   2D
020F:  MOVF   2D,W
0210:  CALL   06D
0211:  IORLW  00
0212:  BTFSC  03.2
0213:  GOTO   218
0214:  INCF   2D,F
0215:  MOVWF  2E
0216:  CALL   13A
0217:  GOTO   20F
....................  
.................... 	if(dado==0x8B) 
0218:  MOVF   2C,W
0219:  SUBLW  8B
021A:  BTFSS  03.2
021B:  GOTO   21F
.................... 	 { set_pwm1_duty(101);} 
021C:  MOVLW  65
021D:  MOVWF  15
.................... 	else 
021E:  GOTO   221
.................... 	 { set_pwm2_duty(101);} 
021F:  MOVLW  65
0220:  MOVWF  1B
.................... } 
0221:  RETLW  00
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *           Rotina para Atualizar o Duty-Cycle do PWM para 60%        * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void Atualiza_PWM_60(int dado) 
.................... { 
....................     Lcd_Inst(dado); 
0222:  MOVF   2C,W
0223:  MOVWF  2D
0224:  CALL   11B
....................     printf(lcd_dado," 60"); 
0225:  CLRF   2D
0226:  MOVF   2D,W
0227:  CALL   075
0228:  IORLW  00
0229:  BTFSC  03.2
022A:  GOTO   22F
022B:  INCF   2D,F
022C:  MOVWF  2E
022D:  CALL   13A
022E:  GOTO   226
....................     
.................... 	if(dado==0x8B) 
022F:  MOVF   2C,W
0230:  SUBLW  8B
0231:  BTFSS  03.2
0232:  GOTO   236
.................... 	 { set_pwm1_duty(152);} 
0233:  MOVLW  98
0234:  MOVWF  15
.................... 	else 
0235:  GOTO   238
.................... 	 { set_pwm2_duty(152);} 
0236:  MOVLW  98
0237:  MOVWF  1B
.................... } 
0238:  RETLW  00
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *           Rotina para Atualizar o Duty-Cycle do PWM para 80%        * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void Atualiza_PWM_80(int dado) 
.................... { 
....................     Lcd_Inst(dado); 
0239:  MOVF   2C,W
023A:  MOVWF  2D
023B:  CALL   11B
....................     printf(lcd_dado," 80"); 
023C:  CLRF   2D
023D:  MOVF   2D,W
023E:  CALL   07D
023F:  IORLW  00
0240:  BTFSC  03.2
0241:  GOTO   246
0242:  INCF   2D,F
0243:  MOVWF  2E
0244:  CALL   13A
0245:  GOTO   23D
....................      
.................... 	if(dado==0x8B) 
0246:  MOVF   2C,W
0247:  SUBLW  8B
0248:  BTFSS  03.2
0249:  GOTO   24D
.................... 	 { set_pwm1_duty(203);} 
024A:  MOVLW  CB
024B:  MOVWF  15
.................... 	else 
024C:  GOTO   24F
.................... 	 { set_pwm2_duty(203);} 
024D:  MOVLW  CB
024E:  MOVWF  1B
.................... } 
024F:  RETLW  00
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *          Rotina para Atualizar o Duty-Cycle do PWM para 100%        * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void Atualiza_PWM_100(int dado) 
.................... { 
....................     Lcd_Inst(dado); 
0250:  MOVF   2C,W
0251:  MOVWF  2D
0252:  CALL   11B
....................     printf(lcd_dado,"100"); 
0253:  CLRF   2D
0254:  MOVF   2D,W
0255:  CALL   085
0256:  IORLW  00
0257:  BTFSC  03.2
0258:  GOTO   25D
0259:  INCF   2D,F
025A:  MOVWF  2E
025B:  CALL   13A
025C:  GOTO   254
....................  
.................... 	if(dado==0x8B) 
025D:  MOVF   2C,W
025E:  SUBLW  8B
025F:  BTFSS  03.2
0260:  GOTO   264
.................... 	 { set_pwm1_duty(255);} 
0261:  MOVLW  FF
0262:  MOVWF  15
.................... 	else 
0263:  GOTO   266
.................... 	 { set_pwm2_duty(255);} 
0264:  MOVLW  FF
0265:  MOVWF  1B
.................... } 
0266:  RETLW  00
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *               Rotina para escrever comandos no display	 		   * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void Lcd_Inst(char dado) 
.................... { 
.................... 	disable_interrupts(GLOBAL);		// Desliga as interrupções 
*
011B:  BCF    0B.6
011C:  BCF    0B.7
011D:  BTFSC  0B.7
011E:  GOTO   11C
.................... 	output_low(RS);					// Põe pino de RS em baixo, modo comando 
011F:  BSF    03.5
0120:  BCF    09.2
0121:  BCF    03.5
0122:  BCF    09.2
.................... 	output_d(dado);					// Põe o dado no portd 
0123:  BSF    03.5
0124:  CLRF   08
0125:  BCF    03.5
0126:  MOVF   2D,W
0127:  MOVWF  08
.................... 	delay_cycles(2);				// Aguarda 2 us, acomodação 
0128:  NOP
0129:  NOP
.................... 	output_high(EN);				// Gera pulso de clock 
012A:  BSF    03.5
012B:  BCF    09.1
012C:  BCF    03.5
012D:  BSF    09.1
.................... 	delay_cycles(2); 
012E:  NOP
012F:  NOP
.................... 	output_low(EN); 
0130:  BSF    03.5
0131:  BCF    09.1
0132:  BCF    03.5
0133:  BCF    09.1
.................... 	delay_ms(1);					// Aguarda 1ms 
0134:  MOVLW  01
0135:  MOVWF  2F
0136:  CALL   106
.................... 	enable_interrupts(GLOBAL);		// Liga as interrupções 
0137:  MOVLW  C0
0138:  IORWF  0B,F
.................... } 
0139:  RETLW  00
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                 Rotina para escrever dados no display	 		   * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void Lcd_Dado(char dado) 
.................... { 
.................... 	disable_interrupts(GLOBAL);		// Desliga as interrupções 
013A:  BCF    0B.6
013B:  BCF    0B.7
013C:  BTFSC  0B.7
013D:  GOTO   13B
.................... 	output_high(RS);				// Seta o pino RS, modo dado 
013E:  BSF    03.5
013F:  BCF    09.2
0140:  BCF    03.5
0141:  BSF    09.2
.................... 	output_d(dado);					// Põe o dado no portd 
0142:  BSF    03.5
0143:  CLRF   08
0144:  BCF    03.5
0145:  MOVF   2E,W
0146:  MOVWF  08
.................... 	delay_cycles(2);				// Aguarda 2us, acomodação 
0147:  NOP
0148:  NOP
.................... 	output_high(EN);				// Gera pulso de clock 
0149:  BSF    03.5
014A:  BCF    09.1
014B:  BCF    03.5
014C:  BSF    09.1
.................... 	delay_cycles(2); 
014D:  NOP
014E:  NOP
.................... 	output_low(EN); 
014F:  BSF    03.5
0150:  BCF    09.1
0151:  BCF    03.5
0152:  BCF    09.1
.................... 	delay_ms(1);					// Aguarda 1ms 
0153:  MOVLW  01
0154:  MOVWF  2F
0155:  CALL   106
.................... 	enable_interrupts(GLOBAL);		// Liga as interrupções 
0156:  MOVLW  C0
0157:  IORWF  0B,F
.................... } 
0158:  RETLW  00
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                  Tratamento da Interrupção de Timer 0			   * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... #int_timer0 
.................... void Ist_Timer0(void) 
.................... { 
....................    indice++;                        // Incrementa indice 
*
008D:  INCF   2A,F
....................  
....................    switch(indice)                   // Seleção de casos com indice 
....................       { 
008E:  MOVLW  01
008F:  SUBWF  2A,W
0090:  ADDLW  FC
0091:  BTFSC  03.0
0092:  GOTO   0F6
0093:  ADDLW  04
0094:  GOTO   0FA
....................  
....................          case 1:                     // Caso seja 1... 
....................    			output_d(SEL_LINHA1);	// Seleciona no barramento a linha 1 
0095:  BSF    03.5
0096:  CLRF   08
0097:  MOVLW  0E
0098:  BCF    03.5
0099:  MOVWF  08
....................    			tecla1=0;			    // Limpa a tecla pressionada 
009A:  BCF    28.1
....................    			tecla2=0;				// Limpa a tecla pressionada 
009B:  BCF    28.2
....................    			tecla3=0;				// Limpa a tecla pressionada 
009C:  BCF    28.3
....................    			if (!input(COL1)) tecla1=1; // Verifica se tecla está pressionada 
009D:  BSF    03.5
009E:  BSF    05.4
009F:  BCF    03.5
00A0:  BTFSS  05.4
00A1:  BSF    28.1
....................    			if (!input(COL2)) tecla2=1; // Verifica se tecla está pressionada 
00A2:  BSF    03.5
00A3:  BSF    05.5
00A4:  BCF    03.5
00A5:  BTFSS  05.5
00A6:  BSF    28.2
....................    			if (!input(COL3)) tecla3=1; // Verifica se tecla está pressionada 
00A7:  BSF    03.5
00A8:  BSF    09.0
00A9:  BCF    03.5
00AA:  BTFSS  09.0
00AB:  BSF    28.3
....................             break; 
00AC:  GOTO   0F6
....................  
....................          case 2:                     // Caso seja 2... 
....................    			output_d(SEL_LINHA2);	 // Seleciona no barramento a linha 1 
00AD:  BSF    03.5
00AE:  CLRF   08
00AF:  MOVLW  0D
00B0:  BCF    03.5
00B1:  MOVWF  08
....................    			tecla4=0;				 // Limpa a tecla pressionada 
00B2:  BCF    28.4
....................    			tecla5=0;				 // Limpa a tecla pressionada 
00B3:  BCF    28.5
....................    			tecla6=0;				 // Limpa a tecla pressionada 
00B4:  BCF    28.6
....................    			if (!input(COL1)) tecla4=1; // Verifica se tecla está pressionada 
00B5:  BSF    03.5
00B6:  BSF    05.4
00B7:  BCF    03.5
00B8:  BTFSS  05.4
00B9:  BSF    28.4
....................    			if (!input(COL2)) tecla5=1; // Verifica se tecla está pressionada 
00BA:  BSF    03.5
00BB:  BSF    05.5
00BC:  BCF    03.5
00BD:  BTFSS  05.5
00BE:  BSF    28.5
....................    			if (!input(COL3)) tecla6=1; // Verifica se tecla está pressionada 
00BF:  BSF    03.5
00C0:  BSF    09.0
00C1:  BCF    03.5
00C2:  BTFSS  09.0
00C3:  BSF    28.6
....................             break; 
00C4:  GOTO   0F6
....................  
....................          case 3:                     // Caso seja 3... 
....................    			output_d(SEL_LINHA3);	  // Seleciona no barramento a linha 3 
00C5:  BSF    03.5
00C6:  CLRF   08
00C7:  MOVLW  0B
00C8:  BCF    03.5
00C9:  MOVWF  08
....................    			tecla7=0;				  // Limpa a tecla pressionada 
00CA:  BCF    28.7
....................    			tecla8=0;				  // Limpa a tecla pressionada 
00CB:  BCF    29.0
....................    			tecla9=0;				  // Limpa a tecla pressionada 
00CC:  BCF    29.1
....................    			if (!input(COL1)) tecla7=1; // Verifica se tecla está pressionada 
00CD:  BSF    03.5
00CE:  BSF    05.4
00CF:  BCF    03.5
00D0:  BTFSS  05.4
00D1:  BSF    28.7
....................    			if (!input(COL2)) tecla8=1; // Verifica se tecla está pressionada 
00D2:  BSF    03.5
00D3:  BSF    05.5
00D4:  BCF    03.5
00D5:  BTFSS  05.5
00D6:  BSF    29.0
....................    			if (!input(COL3)) tecla9=1; // Verifica se tecla está pressionada 
00D7:  BSF    03.5
00D8:  BSF    09.0
00D9:  BCF    03.5
00DA:  BTFSS  09.0
00DB:  BSF    29.1
....................             break; 
00DC:  GOTO   0F6
....................  
....................          case 4:                     // Caso seja 4... 
....................             indice=0;                // Reinicia indice 
00DD:  CLRF   2A
....................    			output_d(SEL_LINHA4);	   // Seleciona no barramento a linha 4 
00DE:  BSF    03.5
00DF:  CLRF   08
00E0:  MOVLW  07
00E1:  BCF    03.5
00E2:  MOVWF  08
....................    			teclaC=0;				   // Limpa a tecla pressionada 
00E3:  BCF    29.3
....................    			tecla0=0;				   // Limpa a tecla pressionada 
00E4:  BCF    28.0
....................    			teclaE=0;				   // Limpa a tecla pressionada 
00E5:  BCF    29.2
....................    			if (!input(COL1)) teclaC=1; // Verifica se tecla está pressionada 
00E6:  BSF    03.5
00E7:  BSF    05.4
00E8:  BCF    03.5
00E9:  BTFSS  05.4
00EA:  BSF    29.3
....................    			if (!input(COL2)) tecla0=1; // Verifica se tecla está pressionada 
00EB:  BSF    03.5
00EC:  BSF    05.5
00ED:  BCF    03.5
00EE:  BTFSS  05.5
00EF:  BSF    28.0
....................    			if (!input(COL3)) teclaE=1; // Verifica se tecla está pressionada 
00F0:  BSF    03.5
00F1:  BSF    09.0
00F2:  BCF    03.5
00F3:  BTFSS  09.0
00F4:  BSF    29.2
....................             break; 
00F5:  GOTO   0F6
....................       } 
.................... } 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                 		      Fim do Programa						   * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
....................  
00F6:  BCF    0B.2
00F7:  BCF    0A.3
00F8:  BCF    0A.4
00F9:  GOTO   01D

Configuration Fuses:
   Word  1: 3F35   XT WDT PUT NODEBUG NOPROTECT NOBROWNOUT NOLVP NOCPD NOWRT
