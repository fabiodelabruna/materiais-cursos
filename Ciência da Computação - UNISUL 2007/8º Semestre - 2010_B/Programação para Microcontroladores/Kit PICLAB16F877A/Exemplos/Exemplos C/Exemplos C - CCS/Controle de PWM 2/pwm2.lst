CCS PCM C Compiler, Version 3.245, 28193               11-fev-07 18:49

               Filename: C:\Cerne\CDs\kit PICLAB16f877A\Exemplos\Exemplos C\Controle de PWM 2\pwm2.lst

               ROM used: 1001 words (12%)
                         Largest free fragment is 2048
               RAM used: 22 (13%) at main() level
                         32 (18%) worst case
               Stack:    6 worst case (4 in main + 2 for interrupts)

*
0000:  MOVLW  00
0001:  MOVWF  0A
0002:  GOTO   356
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  MOVF   7B,W
0016:  MOVWF  27
0017:  BCF    03.7
0018:  BCF    03.5
0019:  MOVLW  8C
001A:  MOVWF  04
001B:  BTFSS  00.1
001C:  GOTO   01F
001D:  BTFSC  0C.1
001E:  GOTO   036
001F:  BTFSS  0B.5
0020:  GOTO   023
0021:  BTFSC  0B.2
0022:  GOTO   039
0023:  MOVF   22,W
0024:  MOVWF  04
0025:  MOVF   23,W
0026:  MOVWF  77
0027:  MOVF   24,W
0028:  MOVWF  78
0029:  MOVF   25,W
002A:  MOVWF  79
002B:  MOVF   26,W
002C:  MOVWF  7A
002D:  MOVF   27,W
002E:  MOVWF  7B
002F:  MOVF   20,W
0030:  MOVWF  0A
0031:  SWAPF  21,W
0032:  MOVWF  03
0033:  SWAPF  7F,F
0034:  SWAPF  7F,W
0035:  RETFIE
0036:  BCF    0A.3
0037:  BCF    0A.4
0038:  GOTO   066
0039:  BCF    0A.3
003A:  BCF    0A.4
003B:  GOTO   082
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *    	 	       Programação em C - Módulo B PIC16F877A            	   * 
....................  *                               Exemplo 12                                * 
....................  *                                                                         * 
....................  *                 CENTRO DE TREINAMENTO - Cerne Tecnologia	               * 
....................  *                          www.cerne-tec.com.br                           * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *   VERSÃO : 1.0                                                          * 
....................  *   DATA : 16/05/2005                                                     * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                             Descrição geral                           * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
.................... // Demonstrar a utilização dos dois módulos de PWM 
.................... // utilizando para isto o ventilador e resistor externo 
.................... // e além disso medir a temperatura e rotação em Hz e RPM do ventilador 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                		 	Definição de Cabeçalho						 * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... #include	<16F877A.h>				//microcontrolador utilizado 
.................... //////// Standard Header file for the PIC16F877A device //////////////// 
.................... #device PIC16F877A  
.................... #list 
....................  
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                         Configurações para gravação                   * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... #fuses xt,nolvp,wdt,nolvp,nobrownout,put,nodebug,noprotect,nowrt,nocpd 
....................  								   // Configurações da Máquina 
....................                            // Oscilador: XT, LVP: Off, WDT: On, Brown-out: Off 
....................                            // Power-up: Off, Debug: Off, CP: Off, CPD: Off 
....................  
.................... #use delay(clock=4000000)		   // Utiliza biblioteca de delay									 
*
00F7:  MOVLW  3A
00F8:  MOVWF  04
00F9:  MOVF   00,W
00FA:  BTFSC  03.2
00FB:  GOTO   10B
00FC:  MOVLW  01
00FD:  MOVWF  78
00FE:  CLRF   77
00FF:  DECFSZ 77,F
0100:  GOTO   0FF
0101:  DECFSZ 78,F
0102:  GOTO   0FE
0103:  MOVLW  4A
0104:  MOVWF  77
0105:  DECFSZ 77,F
0106:  GOTO   105
0107:  NOP
0108:  NOP
0109:  DECFSZ 00,F
010A:  GOTO   0FC
010B:  RETLW  00
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                 Definição e inicialização das variáveis               * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
.................... //Aqui iremos definir as variáveis globais do sistema 
....................  
.................... int1 pode_converter=0; 
*
0360:  BCF    03.5
0361:  BCF    28.0
.................... int1 tecla0=0, tecla1=0, tecla2=0, tecla3=0, tecla4=0, tecla5=0, tecla6=0, 
0362:  BCF    28.1
0363:  BCF    28.2
0364:  BCF    28.3
0365:  BCF    28.4
0366:  BCF    28.5
0367:  BCF    28.6
0368:  BCF    28.7
....................      tecla7=0, tecla8=0, tecla9=0, teclaE=0, teclaC=0; 
0369:  BCF    29.0
036A:  BCF    29.1
036B:  BCF    29.2
036C:  BCF    29.3
036D:  BCF    29.4
.................... int indice=0; 
036E:  CLRF   2A
.................... long pulsos; 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                           Constantes internas                         * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
.................... //Aqui iremos definir as constantes utilizadas pelo sistema 
....................  
.................... #define SEL_LINHA1	0b00001110	// Seleção da linha 1 
.................... #define SEL_LINHA2	0b00001101	// Seleção da linha 2 
.................... #define SEL_LINHA3	0b00001011	// Seleção da linha 3 
.................... #define SEL_LINHA4	0b00000111	// Seleção da linha 4 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                                Entradas                               * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
.................... //Aqui iremos definir as entradas do sistema 
....................  
.................... #define  COL1	      PIN_A4 
.................... #define  COL2	      PIN_A5 
.................... #define  COL3        PIN_E0 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                                Saídas                               * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
.................... //Aqui iremos definir as saídas do sistema 
....................  
.................... #define  RS			  PIN_E2		// Pino de seleção de modo do display 
.................... #define  EN			  PIN_E1		// Pino de habilitação do display 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                       Prototipagem das funções                      * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
.................... //Aqui iremos declarar todas as funções definidas pelo usuário 
....................  
.................... void Inicializa(void); 
.................... void Tela_Inicial(void); 
.................... void Atualiza_PWM_0(int dado); 
.................... void Atualiza_PWM_20(int dado); 
.................... void Atualiza_PWM_40(int dado); 
.................... void Atualiza_PWM_60(int dado); 
.................... void Atualiza_PWM_80(int dado); 
.................... void Atualiza_PWM_100(int dado); 
.................... void Lcd_Inst(char dado); 
.................... void Lcd_Dado(char dado); 
.................... void Atualiza_Temperatura(int dado); 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                           Rotina Principal                		   * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
.................... //Nessa parte ficará o loop principal do sistema 
....................  
.................... void main (void) 
.................... { 
*
0356:  CLRF   04
0357:  MOVLW  1F
0358:  ANDWF  03,F
0359:  BSF    03.5
035A:  BSF    1F.0
035B:  BSF    1F.1
035C:  BSF    1F.2
035D:  BCF    1F.3
035E:  MOVLW  07
035F:  MOVWF  1C
.................... 	Inicializa();				// Chama rotina para inicializar o sistema 
*
0373:  GOTO   14A
....................  
.................... 	while(1)					   // Entra em loop infinito 
.................... 		{ 
.................... 			restart_wdt();		// Limpa o wdt 
0374:  CLRWDT
....................  
.................... 			if (tecla1)	Atualiza_PWM_0(0x83);  // Atualiza PWM e LCD 
0375:  BTFSS  28.2
0376:  GOTO   37A
0377:  MOVLW  83
0378:  MOVWF  2F
0379:  CALL   1E4
.................... 			if (tecla2) Atualiza_PWM_20(0x83); // Atualiza PWM e LCD 
037A:  BTFSS  28.3
037B:  GOTO   37F
037C:  MOVLW  83
037D:  MOVWF  2F
037E:  CALL   1F8
.................... 			if (tecla3) Atualiza_PWM_40(0x83); // Atualiza PWM e LCD 
037F:  BTFSS  28.4
0380:  GOTO   384
0381:  MOVLW  83
0382:  MOVWF  2F
0383:  CALL   20E
.................... 	 		if (tecla4) Atualiza_PWM_60(0x83); // Atualiza PWM e LCD 
0384:  BTFSS  28.5
0385:  GOTO   389
0386:  MOVLW  83
0387:  MOVWF  2F
0388:  CALL   224
.................... 			if (tecla5) Atualiza_PWM_80(0x83); // Atualiza PWM e LCD 
0389:  BTFSS  28.6
038A:  GOTO   38E
038B:  MOVLW  83
038C:  MOVWF  2F
038D:  CALL   23A
.................... 	 		if (tecla6) Atualiza_PWM_100(0x83);// Atualiza PWM e LCD 
038E:  BTFSS  28.7
038F:  GOTO   393
0390:  MOVLW  83
0391:  MOVWF  2F
0392:  CALL   250
....................  
.................... 			if (tecla7)	Atualiza_PWM_0(0x8C);  // Atualiza PWM e LCD 
0393:  BTFSS  29.0
0394:  GOTO   398
0395:  MOVLW  8C
0396:  MOVWF  2F
0397:  CALL   1E4
.................... 			if (tecla8) Atualiza_PWM_20(0x8C); // Atualiza PWM e LCD 
0398:  BTFSS  29.1
0399:  GOTO   39D
039A:  MOVLW  8C
039B:  MOVWF  2F
039C:  CALL   1F8
.................... 			if (tecla9) Atualiza_PWM_40(0x8C); // Atualiza PWM e LCD 
039D:  BTFSS  29.2
039E:  GOTO   3A2
039F:  MOVLW  8C
03A0:  MOVWF  2F
03A1:  CALL   20E
.................... 	 		if (teclaC) Atualiza_PWM_60(0x8C); // Atualiza PWM e LCD 
03A2:  BTFSS  29.4
03A3:  GOTO   3A7
03A4:  MOVLW  8C
03A5:  MOVWF  2F
03A6:  CALL   224
.................... 			if (tecla0) Atualiza_PWM_80(0x8C); // Atualiza PWM e LCD 
03A7:  BTFSS  28.1
03A8:  GOTO   3AC
03A9:  MOVLW  8C
03AA:  MOVWF  2F
03AB:  CALL   23A
.................... 	 		if (teclaE) Atualiza_PWM_100(0x8C);// Atualiza PWM e LCD 
03AC:  BTFSS  29.3
03AD:  GOTO   3B1
03AE:  MOVLW  8C
03AF:  MOVWF  2F
03B0:  CALL   250
....................  
.................... 	 		Atualiza_Temperatura(read_adc()); 
03B1:  BSF    1F.2
03B2:  BTFSC  1F.2
03B3:  GOTO   3B2
03B4:  MOVF   1E,W
03B5:  MOVWF  2F
03B6:  MOVWF  30
03B7:  GOTO   2B2
....................  
.................... 			if (pode_converter) 
03B8:  BTFSS  28.0
03B9:  GOTO   3E7
.................... 			 { 
.................... 				 pode_converter=0; 
03BA:  BCF    28.0
.................... 				 pulsos=pulsos/9;		           // Acha o RPS 
03BB:  MOVF   2C,W
03BC:  MOVWF  30
03BD:  MOVF   2B,W
03BE:  MOVWF  2F
03BF:  CLRF   32
03C0:  MOVLW  09
03C1:  MOVWF  31
03C2:  GOTO   2BF
03C3:  MOVF   79,W
03C4:  MOVWF  2C
03C5:  MOVF   78,W
03C6:  MOVWF  2B
.................... 				 Lcd_Inst(0xC0); 
03C7:  MOVLW  C0
03C8:  MOVWF  31
03C9:  CALL   10C
....................              printf(lcd_dado,"%02lu",pulsos); 
03CA:  MOVLW  0B
03CB:  MOVWF  04
03CC:  MOVF   2C,W
03CD:  MOVWF  32
03CE:  MOVF   2B,W
03CF:  MOVWF  31
03D0:  CALL   2E7
....................  
.................... 				 Lcd_Inst(0xC6); 
03D1:  MOVLW  C6
03D2:  MOVWF  31
03D3:  CALL   10C
....................              printf(lcd_dado,"%04lu",pulsos*60); 
03D4:  MOVF   2C,W
03D5:  MOVWF  30
03D6:  MOVF   2B,W
03D7:  MOVWF  2F
03D8:  CLRF   32
03D9:  MOVLW  3C
03DA:  MOVWF  31
03DB:  GOTO   33F
03DC:  MOVF   79,W
03DD:  MOVWF  30
03DE:  MOVF   78,W
03DF:  MOVWF  2F
03E0:  MOVLW  09
03E1:  MOVWF  04
03E2:  MOVF   79,W
03E3:  MOVWF  32
03E4:  MOVF   78,W
03E5:  MOVWF  31
03E6:  CALL   2E7
....................  
.................... 			} 
....................  
.................... 		} 
03E7:  GOTO   374
.................... } 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                       Inicialização do Sistema                 	   * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void Inicializa(void) 
.................... { 
03E8:  SLEEP
....................  
....................    delay_ms(2000); 
*
014A:  MOVLW  08
014B:  MOVWF  2F
014C:  MOVLW  FA
014D:  MOVWF  3A
014E:  CALL   0F7
014F:  DECFSZ 2F,F
0150:  GOTO   14C
....................  
....................    setup_adc(ADC_CLOCK_DIV_8);  		      // Configura clock da conversão 
0151:  BSF    03.5
0152:  BCF    1F.6
0153:  BCF    03.5
0154:  BSF    1F.6
0155:  BCF    1F.7
0156:  BSF    03.5
0157:  BCF    1F.7
0158:  BCF    03.5
0159:  BSF    1F.0
....................    setup_adc_ports(RA0_RA1_RA3_ANALOG);   // Configura três entradas como AD 
015A:  BSF    03.5
015B:  BCF    1F.0
015C:  BCF    1F.1
015D:  BSF    1F.2
015E:  BCF    1F.3
....................    set_adc_channel(3);			   		   // Seleciona o canal 3(Temperatura) 
015F:  MOVLW  18
0160:  MOVWF  78
0161:  BCF    03.5
0162:  MOVF   1F,W
0163:  ANDLW  C7
0164:  IORWF  78,W
0165:  MOVWF  1F
....................  
....................    setup_ccp1(CCP_PWM);			            // Confirura modo CCP para PWM 
0166:  BCF    2D.2
0167:  MOVF   2D,W
0168:  BSF    03.5
0169:  MOVWF  07
016A:  BCF    03.5
016B:  BCF    07.2
016C:  MOVLW  0C
016D:  MOVWF  17
*
036F:  MOVLW  FF
0370:  MOVWF  2D
....................    setup_ccp2(CCP_PWM); 
*
016E:  BCF    2D.1
016F:  MOVF   2D,W
0170:  BSF    03.5
0171:  MOVWF  07
0172:  BCF    03.5
0173:  BCF    07.1
0174:  MOVLW  0C
0175:  MOVWF  1D
....................  
....................    output_low(PIN_C1); 
0176:  BCF    2D.1
0177:  MOVF   2D,W
0178:  BSF    03.5
0179:  MOVWF  07
017A:  BCF    03.5
017B:  BCF    07.1
....................    output_low(PIN_C2);			            // Garante estado do port 
017C:  BCF    2D.2
017D:  MOVF   2D,W
017E:  BSF    03.5
017F:  MOVWF  07
0180:  BCF    03.5
0181:  BCF    07.2
....................  
....................    setup_timer_1(T1_EXTERNAL | T1_DIV_BY_1); 
0182:  MOVLW  87
0183:  MOVWF  10
....................  
....................    set_pwm1_duty(0); 
0184:  CLRF   15
....................    set_pwm2_duty(0);			               // Garante estado inicial do modo CCP 
0185:  CLRF   1B
....................  
....................    setup_timer_2(T2_DIV_BY_4,249,10); 
0186:  MOVLW  48
0187:  MOVWF  78
0188:  IORLW  05
0189:  MOVWF  12
018A:  MOVLW  F9
018B:  BSF    03.5
018C:  MOVWF  12
....................  
....................    set_timer0(0);                         // Inicializa timer 0 com 0 
018D:  BCF    03.5
018E:  CLRF   01
....................    setup_timer_0(RTCC_INTERNAL | RTCC_DIV_1); // Timer configurado para clock 
018F:  BSF    03.5
0190:  MOVF   01,W
0191:  ANDLW  C7
0192:  IORLW  08
0193:  MOVWF  01
....................                                               // Interno com prescaler de 1:4 
....................    setup_wdt(WDT_2304MS);                  // Configura WDT para 2,304 s 
0194:  MOVLW  0F
0195:  MOVWF  77
0196:  MOVLW  07
0197:  BCF    03.5
0198:  CLRF   01
0199:  MOVLW  81
019A:  MOVWF  04
019B:  MOVF   00,W
019C:  ANDLW  F0
019D:  IORLW  07
019E:  MOVWF  00
019F:  CLRWDT
01A0:  MOVF   00,W
01A1:  ANDLW  F7
01A2:  BTFSC  77.3
01A3:  ANDLW  F0
01A4:  IORWF  77,W
01A5:  MOVWF  00
....................    enable_interrupts(INT_TIMER2);          // Habilita interrupção de timer 0 
01A6:  BSF    03.5
01A7:  BSF    0C.1
....................    enable_interrupts(INT_TIMER0);          // Habilita interrupção de timer 0 
01A8:  BCF    03.5
01A9:  BSF    0B.5
....................    enable_interrupts(GLOBAL);              // Habilita todas as interrupções 
01AA:  MOVLW  C0
01AB:  IORWF  0B,F
....................  
....................    Lcd_Inst(0x30);			                // Inicializa o display 
01AC:  MOVLW  30
01AD:  MOVWF  31
01AE:  CALL   10C
....................    delay_ms(3); 
01AF:  MOVLW  03
01B0:  MOVWF  3A
01B1:  CALL   0F7
....................    Lcd_Inst(0x30); 
01B2:  MOVLW  30
01B3:  MOVWF  31
01B4:  CALL   10C
....................    Lcd_Inst(0x30); 
01B5:  MOVLW  30
01B6:  MOVWF  31
01B7:  CALL   10C
....................    Lcd_Inst(0x38); 
01B8:  MOVLW  38
01B9:  MOVWF  31
01BA:  CALL   10C
....................    Lcd_Inst(0x01); 
01BB:  MOVLW  01
01BC:  MOVWF  31
01BD:  CALL   10C
....................    delay_ms(1); 
01BE:  MOVLW  01
01BF:  MOVWF  3A
01C0:  CALL   0F7
....................    Lcd_Inst(0x0C); 
01C1:  MOVLW  0C
01C2:  MOVWF  31
01C3:  CALL   10C
....................    Lcd_Inst(0x06); 
01C4:  MOVLW  06
01C5:  MOVWF  31
01C6:  CALL   10C
....................    Tela_Inicial(); 
.................... } 
*
01E1:  BCF    0A.3
01E2:  BCF    0A.4
01E3:  GOTO   374 (RETURN)
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                 Rotina para Apresentar a Tela Inicial               * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void Tela_Inicial(void) 
.................... { 
.................... 	Lcd_Inst(0x80);			// Atualiza a tela do LCD 
*
01C7:  MOVLW  80
01C8:  MOVWF  31
01C9:  CALL   10C
....................    printf(lcd_dado,"Vt: 0 % Res: 0 %"); 
01CA:  CLRF   2F
01CB:  MOVF   2F,W
01CC:  CALL   03C
01CD:  IORLW  00
01CE:  BTFSC  03.2
01CF:  GOTO   1D4
01D0:  INCF   2F,F
01D1:  MOVWF  39
01D2:  CALL   12B
01D3:  GOTO   1CB
....................     
.................... 	Lcd_Inst(0xC0);			// Atualiza a tela do LCD 
01D4:  MOVLW  C0
01D5:  MOVWF  31
01D6:  CALL   10C
....................    printf(lcd_dado," 0 Hz   0 RM   C"); 
01D7:  CLRF   2F
01D8:  MOVF   2F,W
01D9:  CALL   051
01DA:  IORLW  00
01DB:  BTFSC  03.2
01DC:  GOTO   1E1
01DD:  INCF   2F,F
01DE:  MOVWF  39
01DF:  CALL   12B
01E0:  GOTO   1D8
.................... } 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *           Rotina para Atualizar o Duty-Cycle do PWM para 0%         * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void Atualiza_PWM_0(int dado) 
.................... { 
....................     Lcd_Inst(dado); 
*
01E4:  MOVF   2F,W
01E5:  MOVWF  31
01E6:  CALL   10C
....................     Lcd_Dado('0'); 
01E7:  MOVLW  30
01E8:  MOVWF  39
01E9:  CALL   12B
....................     Lcd_Dado('0'); 
01EA:  MOVLW  30
01EB:  MOVWF  39
01EC:  CALL   12B
....................     Lcd_Dado('0'); 
01ED:  MOVLW  30
01EE:  MOVWF  39
01EF:  CALL   12B
....................  
.................... 	if(dado==0x83) 
01F0:  MOVF   2F,W
01F1:  SUBLW  83
01F2:  BTFSS  03.2
01F3:  GOTO   1F6
.................... 	 { set_pwm1_duty(0);} 
01F4:  CLRF   15
.................... 	else 
01F5:  GOTO   1F7
.................... 	 { set_pwm2_duty(0);} 
01F6:  CLRF   1B
.................... } 
01F7:  RETLW  00
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *           Rotina para Atualizar o Duty-Cycle do PWM para 20%        * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void Atualiza_PWM_20(int dado) 
.................... { 
....................     Lcd_Inst(dado); 
01F8:  MOVF   2F,W
01F9:  MOVWF  31
01FA:  CALL   10C
....................     Lcd_Dado(' '); 
01FB:  MOVLW  20
01FC:  MOVWF  39
01FD:  CALL   12B
....................     Lcd_Dado('2'); 
01FE:  MOVLW  32
01FF:  MOVWF  39
0200:  CALL   12B
....................     Lcd_Dado('0'); 
0201:  MOVLW  30
0202:  MOVWF  39
0203:  CALL   12B
....................  
.................... 	if(dado==0x83) 
0204:  MOVF   2F,W
0205:  SUBLW  83
0206:  BTFSS  03.2
0207:  GOTO   20B
.................... 	 { set_pwm1_duty(50);} 
0208:  MOVLW  32
0209:  MOVWF  15
.................... 	else 
020A:  GOTO   20D
.................... 	 { set_pwm2_duty(50);} 
020B:  MOVLW  32
020C:  MOVWF  1B
.................... } 
020D:  RETLW  00
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *           Rotina para Atualizar o Duty-Cycle do PWM para 40%        * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void Atualiza_PWM_40(int dado) 
.................... { 
....................     Lcd_Inst(dado); 
020E:  MOVF   2F,W
020F:  MOVWF  31
0210:  CALL   10C
....................     Lcd_Dado(' '); 
0211:  MOVLW  20
0212:  MOVWF  39
0213:  CALL   12B
....................     Lcd_Dado('4'); 
0214:  MOVLW  34
0215:  MOVWF  39
0216:  CALL   12B
....................     Lcd_Dado('0'); 
0217:  MOVLW  30
0218:  MOVWF  39
0219:  CALL   12B
....................  
.................... 	if(dado==0x83) 
021A:  MOVF   2F,W
021B:  SUBLW  83
021C:  BTFSS  03.2
021D:  GOTO   221
.................... 	 { set_pwm1_duty(101);} 
021E:  MOVLW  65
021F:  MOVWF  15
.................... 	else 
0220:  GOTO   223
.................... 	 { set_pwm2_duty(101);} 
0221:  MOVLW  65
0222:  MOVWF  1B
.................... } 
0223:  RETLW  00
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *           Rotina para Atualizar o Duty-Cycle do PWM para 60%        * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void Atualiza_PWM_60(int dado) 
.................... { 
....................     Lcd_Inst(dado); 
0224:  MOVF   2F,W
0225:  MOVWF  31
0226:  CALL   10C
....................     Lcd_Dado(' '); 
0227:  MOVLW  20
0228:  MOVWF  39
0229:  CALL   12B
....................     Lcd_Dado('6'); 
022A:  MOVLW  36
022B:  MOVWF  39
022C:  CALL   12B
....................     Lcd_Dado('0'); 
022D:  MOVLW  30
022E:  MOVWF  39
022F:  CALL   12B
....................  
.................... 	if(dado==0x83) 
0230:  MOVF   2F,W
0231:  SUBLW  83
0232:  BTFSS  03.2
0233:  GOTO   237
.................... 	 { set_pwm1_duty(152);} 
0234:  MOVLW  98
0235:  MOVWF  15
.................... 	else 
0236:  GOTO   239
.................... 	 { set_pwm2_duty(152);} 
0237:  MOVLW  98
0238:  MOVWF  1B
.................... } 
0239:  RETLW  00
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *           Rotina para Atualizar o Duty-Cycle do PWM para 80%        * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void Atualiza_PWM_80(int dado) 
.................... { 
....................     Lcd_Inst(dado); 
023A:  MOVF   2F,W
023B:  MOVWF  31
023C:  CALL   10C
....................     Lcd_Dado(' '); 
023D:  MOVLW  20
023E:  MOVWF  39
023F:  CALL   12B
....................     Lcd_Dado('8'); 
0240:  MOVLW  38
0241:  MOVWF  39
0242:  CALL   12B
....................     Lcd_Dado('0'); 
0243:  MOVLW  30
0244:  MOVWF  39
0245:  CALL   12B
....................  
.................... 	if(dado==0x83) 
0246:  MOVF   2F,W
0247:  SUBLW  83
0248:  BTFSS  03.2
0249:  GOTO   24D
.................... 	 { set_pwm1_duty(203);} 
024A:  MOVLW  CB
024B:  MOVWF  15
.................... 	else 
024C:  GOTO   24F
.................... 	 { set_pwm2_duty(203);} 
024D:  MOVLW  CB
024E:  MOVWF  1B
.................... } 
024F:  RETLW  00
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *          Rotina para Atualizar o Duty-Cycle do PWM para 100%        * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void Atualiza_PWM_100(int dado) 
.................... { 
....................     Lcd_Inst(dado); 
0250:  MOVF   2F,W
0251:  MOVWF  31
0252:  CALL   10C
....................     Lcd_Dado('1'); 
0253:  MOVLW  31
0254:  MOVWF  39
0255:  CALL   12B
....................     Lcd_Dado('0'); 
0256:  MOVLW  30
0257:  MOVWF  39
0258:  CALL   12B
....................     Lcd_Dado('0'); 
0259:  MOVLW  30
025A:  MOVWF  39
025B:  CALL   12B
....................  
.................... 	if(dado==0x83) 
025C:  MOVF   2F,W
025D:  SUBLW  83
025E:  BTFSS  03.2
025F:  GOTO   263
.................... 	 { set_pwm1_duty(255);} 
0260:  MOVLW  FF
0261:  MOVWF  15
.................... 	else 
0262:  GOTO   265
.................... 	 { set_pwm2_duty(255);} 
0263:  MOVLW  FF
0264:  MOVWF  1B
.................... } 
0265:  RETLW  00
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *               Rotina para escrever comandos no display	 		   * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void Lcd_Inst(char dado) 
.................... { 
.................... 	disable_interrupts(GLOBAL);		// Desliga as interrupções 
*
010C:  BCF    0B.6
010D:  BCF    0B.7
010E:  BTFSC  0B.7
010F:  GOTO   10D
.................... 	output_low(RS);					// Põe pino de RS em baixo, modo comando 
0110:  BSF    03.5
0111:  BCF    09.2
0112:  BCF    03.5
0113:  BCF    09.2
.................... 	output_d(dado);					// Põe o dado no portd 
0114:  BSF    03.5
0115:  CLRF   08
0116:  BCF    03.5
0117:  MOVF   31,W
0118:  MOVWF  08
.................... 	delay_cycles(2);				// Aguarda 2 us, acomodação 
0119:  NOP
011A:  NOP
.................... 	output_high(EN);				// Gera pulso de clock 
011B:  BSF    03.5
011C:  BCF    09.1
011D:  BCF    03.5
011E:  BSF    09.1
.................... 	delay_cycles(2); 
011F:  NOP
0120:  NOP
.................... 	output_low(EN); 
0121:  BSF    03.5
0122:  BCF    09.1
0123:  BCF    03.5
0124:  BCF    09.1
.................... 	delay_ms(1);					// Aguarda 1ms 
0125:  MOVLW  01
0126:  MOVWF  3A
0127:  CALL   0F7
.................... 	enable_interrupts(GLOBAL);		// Liga as interrupções 
0128:  MOVLW  C0
0129:  IORWF  0B,F
.................... } 
012A:  RETLW  00
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                 Rotina para escrever dados no display	 		   * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void Lcd_Dado(char dado) 
.................... { 
.................... 	disable_interrupts(GLOBAL);		// Desliga as interrupções 
012B:  BCF    0B.6
012C:  BCF    0B.7
012D:  BTFSC  0B.7
012E:  GOTO   12C
.................... 	output_high(RS);				// Seta o pino RS, modo dado 
012F:  BSF    03.5
0130:  BCF    09.2
0131:  BCF    03.5
0132:  BSF    09.2
.................... 	output_d(dado);					// Põe o dado no portd 
0133:  BSF    03.5
0134:  CLRF   08
0135:  BCF    03.5
0136:  MOVF   39,W
0137:  MOVWF  08
.................... 	delay_cycles(2);				// Aguarda 2us, acomodação 
0138:  NOP
0139:  NOP
.................... 	output_high(EN);				// Gera pulso de clock 
013A:  BSF    03.5
013B:  BCF    09.1
013C:  BCF    03.5
013D:  BSF    09.1
.................... 	delay_cycles(2); 
013E:  NOP
013F:  NOP
.................... 	output_low(EN); 
0140:  BSF    03.5
0141:  BCF    09.1
0142:  BCF    03.5
0143:  BCF    09.1
.................... 	delay_ms(1);					// Aguarda 1ms 
0144:  MOVLW  01
0145:  MOVWF  3A
0146:  CALL   0F7
.................... 	enable_interrupts(GLOBAL);		// Liga as interrupções 
0147:  MOVLW  C0
0148:  IORWF  0B,F
.................... } 
0149:  RETLW  00
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                  Tratamento da Interrupção de Timer 2			   * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... #int_timer2 
.................... void Isr_Timer2(void) 
.................... { 
.................... 	static int vezes_timer2=100; 
*
0371:  MOVLW  64
0372:  MOVWF  2E
....................  
.................... 	vezes_timer2--; 
*
0066:  DECF   2E,F
.................... 	if(vezes_timer2) return; 
0067:  MOVF   2E,F
0068:  BTFSS  03.2
0069:  GOTO   07E
.................... 	vezes_timer2=100; 
006A:  MOVLW  64
006B:  MOVWF  2E
.................... 	setup_timer_1(T1_DISABLED); 
006C:  CLRF   10
.................... 	pulsos=get_timer1(); 
006D:  MOVF   0F,W
006E:  MOVWF  7A
006F:  MOVF   0E,W
0070:  MOVWF  77
0071:  MOVF   0F,W
0072:  SUBWF  7A,W
0073:  BTFSS  03.2
0074:  GOTO   06D
0075:  MOVF   77,W
0076:  MOVWF  2B
0077:  MOVF   7A,W
0078:  MOVWF  2C
.................... 	set_timer1(0); 
0079:  CLRF   0F
007A:  CLRF   0E
.................... 	setup_timer_1(T1_EXTERNAL | T1_DIV_BY_1); 
007B:  MOVLW  87
007C:  MOVWF  10
.................... 	pode_converter=1; 
007D:  BSF    28.0
.................... } 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                  Tratamento da Interrupção de Timer 0			   * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
007E:  BCF    0C.1
007F:  BCF    0A.3
0080:  BCF    0A.4
0081:  GOTO   023
.................... #int_timer0 
.................... void Ist_Timer0(void) 
.................... { 
....................    indice++;                            // Incrementa indice 
0082:  INCF   2A,F
....................  
....................    switch(indice)                       // Seleção de casos com indice 
....................       { 
0083:  MOVLW  01
0084:  SUBWF  2A,W
0085:  ADDLW  FC
0086:  BTFSC  03.0
0087:  GOTO   0EB
0088:  ADDLW  04
0089:  GOTO   0EF
....................  
....................          case 1:                        // Caso seja 1... 
....................             output_d(SEL_LINHA1);	    // Seleciona no barramento a linha 1 
008A:  BSF    03.5
008B:  CLRF   08
008C:  MOVLW  0E
008D:  BCF    03.5
008E:  MOVWF  08
....................    			tecla1=0;			          // Limpa a tecla pressionada 
008F:  BCF    28.2
....................    			tecla2=0;				       // Limpa a tecla pressionada 
0090:  BCF    28.3
....................    			tecla3=0;			     	    // Limpa a tecla pressionada 
0091:  BCF    28.4
....................    			if (!input(COL1)) tecla1=1; // Verifica se tecla está pressionada 
0092:  BSF    03.5
0093:  BSF    05.4
0094:  BCF    03.5
0095:  BTFSS  05.4
0096:  BSF    28.2
....................    			if (!input(COL2)) tecla2=1; // Verifica se tecla está pressionada 
0097:  BSF    03.5
0098:  BSF    05.5
0099:  BCF    03.5
009A:  BTFSS  05.5
009B:  BSF    28.3
....................    			if (!input(COL3)) tecla3=1; // Verifica se tecla está pressionada 
009C:  BSF    03.5
009D:  BSF    09.0
009E:  BCF    03.5
009F:  BTFSS  09.0
00A0:  BSF    28.4
....................             break; 
00A1:  GOTO   0EB
....................  
....................          case 2:                        // Caso seja 2... 
....................    			output_d(SEL_LINHA2);	    // Seleciona no barramento a linha 1 
00A2:  BSF    03.5
00A3:  CLRF   08
00A4:  MOVLW  0D
00A5:  BCF    03.5
00A6:  MOVWF  08
....................    			tecla4=0;				       // Limpa a tecla pressionada 
00A7:  BCF    28.5
....................    			tecla5=0;				       // Limpa a tecla pressionada 
00A8:  BCF    28.6
....................    			tecla6=0;				       // Limpa a tecla pressionada 
00A9:  BCF    28.7
....................    			if (!input(COL1)) tecla4=1; // Verifica se tecla está pressionada 
00AA:  BSF    03.5
00AB:  BSF    05.4
00AC:  BCF    03.5
00AD:  BTFSS  05.4
00AE:  BSF    28.5
....................    			if (!input(COL2)) tecla5=1; // Verifica se tecla está pressionada 
00AF:  BSF    03.5
00B0:  BSF    05.5
00B1:  BCF    03.5
00B2:  BTFSS  05.5
00B3:  BSF    28.6
....................    			if (!input(COL3)) tecla6=1; // Verifica se tecla está pressionada 
00B4:  BSF    03.5
00B5:  BSF    09.0
00B6:  BCF    03.5
00B7:  BTFSS  09.0
00B8:  BSF    28.7
....................             break; 
00B9:  GOTO   0EB
....................  
....................          case 3:                         // Caso seja 3... 
....................    			output_d(SEL_LINHA3);	     // Seleciona no barramento a linha 3 
00BA:  BSF    03.5
00BB:  CLRF   08
00BC:  MOVLW  0B
00BD:  BCF    03.5
00BE:  MOVWF  08
....................    			tecla7=0;			      	  // Limpa a tecla pressionada 
00BF:  BCF    29.0
....................    			tecla8=0;				        // Limpa a tecla pressionada 
00C0:  BCF    29.1
....................    			tecla9=0;				        // Limpa a tecla pressionada 
00C1:  BCF    29.2
....................    			if (!input(COL1)) tecla7=1;  // Verifica se tecla está pressionada 
00C2:  BSF    03.5
00C3:  BSF    05.4
00C4:  BCF    03.5
00C5:  BTFSS  05.4
00C6:  BSF    29.0
....................    			if (!input(COL2)) tecla8=1;  // Verifica se tecla está pressionada 
00C7:  BSF    03.5
00C8:  BSF    05.5
00C9:  BCF    03.5
00CA:  BTFSS  05.5
00CB:  BSF    29.1
....................    			if (!input(COL3)) tecla9=1;  // Verifica se tecla está pressionada 
00CC:  BSF    03.5
00CD:  BSF    09.0
00CE:  BCF    03.5
00CF:  BTFSS  09.0
00D0:  BSF    29.2
....................             break; 
00D1:  GOTO   0EB
....................  
....................          case 4:                         // Caso seja 4... 
....................             indice=0;                    // Reinicia indice 
00D2:  CLRF   2A
....................    			output_d(SEL_LINHA4);        // Seleciona no barramento a linha 4 
00D3:  BSF    03.5
00D4:  CLRF   08
00D5:  MOVLW  07
00D6:  BCF    03.5
00D7:  MOVWF  08
....................    			teclaC=0;				        // Limpa a tecla pressionada 
00D8:  BCF    29.4
....................    			tecla0=0;				        // Limpa a tecla pressionada 
00D9:  BCF    28.1
....................    			teclaE=0;			           // Limpa a tecla pressionada 
00DA:  BCF    29.3
....................    			if (!input(COL1)) teclaC=1;  // Verifica se tecla está pressionada 
00DB:  BSF    03.5
00DC:  BSF    05.4
00DD:  BCF    03.5
00DE:  BTFSS  05.4
00DF:  BSF    29.4
....................    			if (!input(COL2)) tecla0=1;  // Verifica se tecla está pressionada 
00E0:  BSF    03.5
00E1:  BSF    05.5
00E2:  BCF    03.5
00E3:  BTFSS  05.5
00E4:  BSF    28.1
....................    			if (!input(COL3)) teclaE=1;  // Verifica se tecla está pressionada 
00E5:  BSF    03.5
00E6:  BSF    09.0
00E7:  BCF    03.5
00E8:  BTFSS  09.0
00E9:  BSF    29.3
....................             break; 
00EA:  GOTO   0EB
....................       } 
.................... } 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *         Rotina para Atualizar a Temperatura medida no Display	   * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
00EB:  BCF    0B.2
00EC:  BCF    0A.3
00ED:  BCF    0A.4
00EE:  GOTO   023
.................... void Atualiza_Temperatura(int dado) 
.................... { 
.................... 	Lcd_Inst(0xCD); 
*
02B2:  MOVLW  CD
02B3:  MOVWF  31
02B4:  CALL   10C
....................    printf(lcd_dado,"%02u",dado*2); 
02B5:  BCF    03.0
02B6:  RLF    30,W
02B7:  MOVWF  31
02B8:  MOVWF  32
02B9:  MOVLW  01
02BA:  MOVWF  33
02BB:  GOTO   27B
.................... } 
02BC:  BCF    0A.3
02BD:  BCF    0A.4
02BE:  GOTO   3B8 (RETURN)
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *        					 Fim do Programa						   * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  

Configuration Fuses:
   Word  1: 3F35   XT WDT PUT NODEBUG NOPROTECT NOBROWNOUT NOLVP NOCPD NOWRT
