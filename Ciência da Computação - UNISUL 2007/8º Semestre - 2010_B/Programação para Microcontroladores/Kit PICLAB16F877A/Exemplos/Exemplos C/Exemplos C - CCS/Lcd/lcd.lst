CCS PCM C Compiler, Version 3.245, 28193               11-fev-07 14:54

               Filename: C:\Cerne\CDs\kit PICLAB16f877A\Exemplos\Exemplos C\Lcd\lcd.lst

               ROM used: 499 words (6%)
                         Largest free fragment is 2048
               RAM used: 16 (9%) at main() level
                         21 (12%) worst case
               Stack:    5 worst case (3 in main + 2 for interrupts)

*
0000:  MOVLW  00
0001:  MOVWF  0A
0002:  GOTO   198
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  MOVF   7B,W
0016:  MOVWF  27
0017:  BCF    03.7
0018:  BCF    03.5
0019:  BTFSS  0B.5
001A:  GOTO   01D
001B:  BTFSC  0B.2
001C:  GOTO   030
001D:  MOVF   22,W
001E:  MOVWF  04
001F:  MOVF   23,W
0020:  MOVWF  77
0021:  MOVF   24,W
0022:  MOVWF  78
0023:  MOVF   25,W
0024:  MOVWF  79
0025:  MOVF   26,W
0026:  MOVWF  7A
0027:  MOVF   27,W
0028:  MOVWF  7B
0029:  MOVF   20,W
002A:  MOVWF  0A
002B:  SWAPF  21,W
002C:  MOVWF  03
002D:  SWAPF  7F,F
002E:  SWAPF  7F,W
002F:  RETFIE
0030:  BCF    0A.3
0031:  BCF    0A.4
0032:  GOTO   056
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *     			   Programação em C - Módulo B PIC16F877A            	      * 
....................  *                               Exemplo 4                                 * 
....................  *                                                                         * 
....................  *                CENTRO DE TREINAMENTO - Cerne Tecnologia	               * 
....................  *                          www.cerne-tec.com.br                           * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *   VERSÃO : 1.0                                                          * 
....................  *   DATA : 16/05/2005                                                     * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                             Descrição geral                           * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
.................... // Apresentar a tecla pressionada no display LCD 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                		 	Definição de Cabeçalho						 * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... #include	<16f877a.h>				//microcontrolador utilizado 
.................... //////// Standard Header file for the PIC16F877A device //////////////// 
.................... #device PIC16F877A 
.................... #list 
....................  
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                         Configurações para gravação                   * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... #fuses xt,nolvp,nowdt,nolvp,nobrownout,put,nodebug,noprotect,nowrt,nocpd 
....................          						        // Configurações da Máquina 
....................                                    // Oscilador: XT 
....................                                    // LVP: Off 
....................                                    // WDT: On 
....................                                    // Brown-out: Off 
....................                                    // Power-up: Off 
....................                                    // Debug: Off 
....................                                    // CP: Off 
....................                                    // CPD: Off 
....................  
.................... #use delay(clock=4000000)          // Define o clock do sistema 
00CB:  MOVLW  2F
00CC:  MOVWF  04
00CD:  MOVF   00,W
00CE:  BTFSC  03.2
00CF:  GOTO   0DF
00D0:  MOVLW  01
00D1:  MOVWF  78
00D2:  CLRF   77
00D3:  DECFSZ 77,F
00D4:  GOTO   0D3
00D5:  DECFSZ 78,F
00D6:  GOTO   0D2
00D7:  MOVLW  4A
00D8:  MOVWF  77
00D9:  DECFSZ 77,F
00DA:  GOTO   0D9
00DB:  NOP
00DC:  NOP
00DD:  DECFSZ 00,F
00DE:  GOTO   0D0
00DF:  RETLW  00
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                 Definição e inicialização das variáveis               * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
.................... //Aqui iremos definir as variáveis globais do sistema 
....................  
.................... int1 tecla0=0, tecla1=0, tecla2=0, tecla3=0, tecla4=0, tecla5=0, tecla6=0, tecla7=0, 
*
01A2:  BCF    03.5
01A3:  BCF    28.0
01A4:  BCF    28.1
01A5:  BCF    28.2
01A6:  BCF    28.3
01A7:  BCF    28.4
01A8:  BCF    28.5
01A9:  BCF    28.6
01AA:  BCF    28.7
....................      tecla8=0, tecla9=0, teclaA=0, teclaB=0, teclaC=0, teclaD=0, teclaE=0; 
01AB:  BCF    29.0
01AC:  BCF    29.1
01AD:  BCF    29.2
01AE:  BCF    29.3
01AF:  BCF    29.4
01B0:  BCF    29.5
01B1:  BCF    29.6
....................       
.................... int indice=0; 
01B2:  CLRF   2A
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                           Constantes internas                         * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
.................... //Aqui iremos definir as constantes utilizadas pelo sistema 
....................  
.................... #define SEL_LINHA1	0b00001110 
.................... #define SEL_LINHA2	0b00001101 
.................... #define SEL_LINHA3	0b00001011 
.................... #define SEL_LINHA4	0b00000111 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                                Entradas                               * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
.................... //Aqui iremos definir as entradas do sistema 
....................  
.................... #define  COL1	       PIN_A4 
.................... #define  COL2	       PIN_A5 
.................... #define  COL3         PIN_E0 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                                Saídas                               * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
.................... //Aqui iremos definir as saídas do sistema 
....................  
.................... #define  RS			  PIN_E2		// Pino de seleção de modo do display 
.................... #define  EN			  PIN_E1    // Pino de habilitação do display 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                       Prototipagem das funções                      * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
.................... //Aqui iremos declarar todas as funções definidas pelo usuário 
....................  
.................... void Inicializa(void); 
.................... void Atualiza_tela(char dado); 
.................... void Lcd_Inst(char dado); 
.................... void Lcd_Dado(char dado); 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                           Rotina Principal                		   * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
.................... //Nessa parte ficará o loop principal do sistema 
....................  
.................... void main (void) 
.................... { 
*
0198:  CLRF   04
0199:  MOVLW  1F
019A:  ANDWF  03,F
019B:  BSF    03.5
019C:  BSF    1F.0
019D:  BSF    1F.1
019E:  BSF    1F.2
019F:  BCF    1F.3
01A0:  MOVLW  07
01A1:  MOVWF  1C
....................  	Inicializa();				// Chama rotina para inicializar o sistema 
*
01B3:  GOTO   0FF
....................  
.................... 	while(1)			   		// Entra em loop infinito 
.................... 		{ 
.................... 			restart_wdt();		// Limpa o wdt 
01B4:  CLRWDT
....................  
.................... 			if (tecla1)	Atualiza_tela('1'); // Atualiza lcd 
01B5:  BTFSS  28.1
01B6:  GOTO   1BA
01B7:  MOVLW  31
01B8:  MOVWF  2B
01B9:  CALL   16D
.................... 			if (tecla2) Atualiza_tela('2'); // Atualiza lcd 
01BA:  BTFSS  28.2
01BB:  GOTO   1BF
01BC:  MOVLW  32
01BD:  MOVWF  2B
01BE:  CALL   16D
.................... 			if (tecla3) Atualiza_tela('3'); // Atualiza lcd 
01BF:  BTFSS  28.3
01C0:  GOTO   1C4
01C1:  MOVLW  33
01C2:  MOVWF  2B
01C3:  CALL   16D
....................  
.................... 			if (tecla4) Atualiza_tela('4'); // Atualiza lcd 
01C4:  BTFSS  28.4
01C5:  GOTO   1C9
01C6:  MOVLW  34
01C7:  MOVWF  2B
01C8:  CALL   16D
.................... 			if (tecla5) Atualiza_tela('5'); // Atualiza lcd 
01C9:  BTFSS  28.5
01CA:  GOTO   1CE
01CB:  MOVLW  35
01CC:  MOVWF  2B
01CD:  CALL   16D
.................... 	 		if (tecla6) Atualiza_tela('6'); // Atualiza lcd 
01CE:  BTFSS  28.6
01CF:  GOTO   1D3
01D0:  MOVLW  36
01D1:  MOVWF  2B
01D2:  CALL   16D
....................  
.................... 			if (tecla7) Atualiza_tela('7'); // Atualiza lcd 
01D3:  BTFSS  28.7
01D4:  GOTO   1D8
01D5:  MOVLW  37
01D6:  MOVWF  2B
01D7:  CALL   16D
.................... 			if (tecla8) Atualiza_tela('8'); // Atualiza lcd 
01D8:  BTFSS  29.0
01D9:  GOTO   1DD
01DA:  MOVLW  38
01DB:  MOVWF  2B
01DC:  CALL   16D
.................... 			if (tecla9) Atualiza_tela('9'); // Atualiza lcd 
01DD:  BTFSS  29.1
01DE:  GOTO   1E2
01DF:  MOVLW  39
01E0:  MOVWF  2B
01E1:  CALL   16D
....................  
.................... 			if (teclaC) Atualiza_tela('C'); // Atualiza lcd 
01E2:  BTFSS  29.4
01E3:  GOTO   1E7
01E4:  MOVLW  43
01E5:  MOVWF  2B
01E6:  CALL   16D
.................... 			if (tecla0) Atualiza_tela('0'); // Atualiza lcd 
01E7:  BTFSS  28.0
01E8:  GOTO   1EC
01E9:  MOVLW  30
01EA:  MOVWF  2B
01EB:  CALL   16D
.................... 			if (teclaE) Atualiza_tela('E'); // Atualiza lcd 
01EC:  BTFSS  29.6
01ED:  GOTO   1F1
01EE:  MOVLW  45
01EF:  MOVWF  2B
01F0:  CALL   16D
....................  
....................  
.................... 		} 
01F1:  GOTO   1B4
.................... } 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                       Inicialização do Sistema                 	   * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void Inicializa(void) 
.................... { 
01F2:  SLEEP
....................  
....................    delay_ms(2000);			    	        // Aguarda 2s 
*
00FF:  MOVLW  08
0100:  MOVWF  2B
0101:  MOVLW  FA
0102:  MOVWF  2F
0103:  CALL   0CB
0104:  DECFSZ 2B,F
0105:  GOTO   101
....................  
....................    setup_adc(ADC_CLOCK_DIV_8);  	        // Configura clock da conversão 
0106:  BSF    03.5
0107:  BCF    1F.6
0108:  BCF    03.5
0109:  BSF    1F.6
010A:  BCF    1F.7
010B:  BSF    03.5
010C:  BCF    1F.7
010D:  BCF    03.5
010E:  BSF    1F.0
....................    setup_adc_ports(RA0_RA1_RA3_ANALOG);  // Configura A/D 
010F:  BSF    03.5
0110:  BCF    1F.0
0111:  BCF    1F.1
0112:  BSF    1F.2
0113:  BCF    1F.3
....................    set_timer0(0);                        // Inicializa timer 0 com 0 
0114:  BCF    03.5
0115:  CLRF   01
....................    setup_timer_0(RTCC_INTERNAL | RTCC_DIV_1); 
0116:  BSF    03.5
0117:  MOVF   01,W
0118:  ANDLW  C7
0119:  IORLW  08
011A:  MOVWF  01
....................                				    			  // Timer configurado para clock 
....................                                          // Interno com prescaler de 1:4 
....................    setup_wdt(WDT_2304MS);                // Configura WDT para 2,304 s 
011B:  MOVLW  0F
011C:  MOVWF  77
011D:  MOVLW  07
011E:  BCF    03.5
011F:  CLRF   01
0120:  MOVLW  81
0121:  MOVWF  04
0122:  MOVF   00,W
0123:  ANDLW  F0
0124:  IORLW  07
0125:  MOVWF  00
0126:  CLRWDT
0127:  MOVF   00,W
0128:  ANDLW  F7
0129:  BTFSC  77.3
012A:  ANDLW  F0
012B:  IORWF  77,W
012C:  MOVWF  00
....................    enable_interrupts(INT_TIMER0);        // Habilita interrupção de timer 0 
012D:  BSF    0B.5
....................    enable_interrupts(GLOBAL);            // Habilita todas as interrupções 
012E:  MOVLW  C0
012F:  IORWF  0B,F
....................  
....................    Lcd_Inst(0x30);		                 // Rotina de Inicialização do Display 
0130:  MOVLW  30
0131:  MOVWF  2C
0132:  CALL   0E0
....................    delay_ms(3); 
0133:  MOVLW  03
0134:  MOVWF  2F
0135:  CALL   0CB
....................    Lcd_Inst(0x30); 
0136:  MOVLW  30
0137:  MOVWF  2C
0138:  CALL   0E0
....................    Lcd_Inst(0x30); 
0139:  MOVLW  30
013A:  MOVWF  2C
013B:  CALL   0E0
....................    Lcd_Inst(0x38); 
013C:  MOVLW  38
013D:  MOVWF  2C
013E:  CALL   0E0
....................    Lcd_Inst(0x01); 
013F:  MOVLW  01
0140:  MOVWF  2C
0141:  CALL   0E0
....................    delay_ms(1); 
0142:  MOVLW  01
0143:  MOVWF  2F
0144:  CALL   0CB
....................    Lcd_Inst(0x0C); 
0145:  MOVLW  0C
0146:  MOVWF  2C
0147:  CALL   0E0
....................    Lcd_Inst(0x06); 
0148:  MOVLW  06
0149:  MOVWF  2C
014A:  CALL   0E0
.................... } 
014B:  BCF    0A.3
014C:  BCF    0A.4
014D:  GOTO   1B4 (RETURN)
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                  Tratamento da Interrupção de Timer 0               * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... #int_timer0 
.................... void Ist_Timer0(void) 
.................... { 
....................    indice++;                        // Incrementa indice 
*
0056:  INCF   2A,F
....................  
....................    switch(indice)                   // Seleção de casos com indice 
....................       { 
0057:  MOVLW  01
0058:  SUBWF  2A,W
0059:  ADDLW  FC
005A:  BTFSC  03.0
005B:  GOTO   0BF
005C:  ADDLW  04
005D:  GOTO   0C3
....................  
....................          case 1:                    // Caso seja 1... 
....................    			output_d(SEL_LINHA1);	// Seleciona no barramento a linha 1 
005E:  BSF    03.5
005F:  CLRF   08
0060:  MOVLW  0E
0061:  BCF    03.5
0062:  MOVWF  08
....................             tecla1=0;			      // Limpa a tecla pressionada 
0063:  BCF    28.1
....................    			tecla2=0;			   	// Limpa a tecla pressionada 
0064:  BCF    28.2
....................    			tecla3=0;				   // Limpa a tecla pressionada 
0065:  BCF    28.3
....................    			if (!input(COL1)) tecla1=1; // Verifica se tecla está pressionada 
0066:  BSF    03.5
0067:  BSF    05.4
0068:  BCF    03.5
0069:  BTFSS  05.4
006A:  BSF    28.1
....................    			if (!input(COL2)) tecla2=1; // Verifica se tecla está pressionada 
006B:  BSF    03.5
006C:  BSF    05.5
006D:  BCF    03.5
006E:  BTFSS  05.5
006F:  BSF    28.2
....................    			if (!input(COL3)) tecla3=1; // Verifica se tecla está pressionada 
0070:  BSF    03.5
0071:  BSF    09.0
0072:  BCF    03.5
0073:  BTFSS  09.0
0074:  BSF    28.3
....................             break; 
0075:  GOTO   0BF
....................  
....................          case 2:                    // Caso seja 2... 
....................    			output_d(SEL_LINHA2);   // Seleciona no barramento a linha 1 
0076:  BSF    03.5
0077:  CLRF   08
0078:  MOVLW  0D
0079:  BCF    03.5
007A:  MOVWF  08
....................    			tecla4=0;			   	// Limpa a tecla pressionada 
007B:  BCF    28.4
....................    			tecla5=0;		    		// Limpa a tecla pressionada 
007C:  BCF    28.5
....................    			tecla6=0;				   // Limpa a tecla pressionada 
007D:  BCF    28.6
....................    			if (!input(COL1)) tecla4=1; // Verifica se tecla está pressionada 
007E:  BSF    03.5
007F:  BSF    05.4
0080:  BCF    03.5
0081:  BTFSS  05.4
0082:  BSF    28.4
....................    			if (!input(COL2)) tecla5=1; // Verifica se tecla está pressionada 
0083:  BSF    03.5
0084:  BSF    05.5
0085:  BCF    03.5
0086:  BTFSS  05.5
0087:  BSF    28.5
....................    			if (!input(COL3)) tecla6=1; // Verifica se tecla está pressionada 
0088:  BSF    03.5
0089:  BSF    09.0
008A:  BCF    03.5
008B:  BTFSS  09.0
008C:  BSF    28.6
....................             break; 
008D:  GOTO   0BF
....................  
....................          case 3:                    // Caso seja 3... 
....................    			output_d(SEL_LINHA3);	  // Seleciona no barramento a linha 3 
008E:  BSF    03.5
008F:  CLRF   08
0090:  MOVLW  0B
0091:  BCF    03.5
0092:  MOVWF  08
....................    			tecla7=0;				  // Limpa a tecla pressionada 
0093:  BCF    28.7
....................    			tecla8=0;				  // Limpa a tecla pressionada 
0094:  BCF    29.0
....................    			tecla9=0;				  // Limpa a tecla pressionada 
0095:  BCF    29.1
....................    			if (!input(COL1)) tecla7=1; // Verifica se tecla está pressionada 
0096:  BSF    03.5
0097:  BSF    05.4
0098:  BCF    03.5
0099:  BTFSS  05.4
009A:  BSF    28.7
....................    			if (!input(COL2)) tecla8=1; // Verifica se tecla está pressionada 
009B:  BSF    03.5
009C:  BSF    05.5
009D:  BCF    03.5
009E:  BTFSS  05.5
009F:  BSF    29.0
....................    			if (!input(COL3)) tecla9=1; // Verifica se tecla está pressionada 
00A0:  BSF    03.5
00A1:  BSF    09.0
00A2:  BCF    03.5
00A3:  BTFSS  09.0
00A4:  BSF    29.1
....................    			break; 
00A5:  GOTO   0BF
....................  
....................          case 4:                    // Caso seja 4... 
....................             indice=0;               // Reinicia indice 
00A6:  CLRF   2A
....................    			output_d(SEL_LINHA4);	   // Seleciona no barramento a linha 4 
00A7:  BSF    03.5
00A8:  CLRF   08
00A9:  MOVLW  07
00AA:  BCF    03.5
00AB:  MOVWF  08
....................    			teclaC=0;				   // Limpa a tecla pressionada 
00AC:  BCF    29.4
....................    			tecla0=0;				   // Limpa a tecla pressionada 
00AD:  BCF    28.0
....................    			teclaE=0;				   // Limpa a tecla pressionada 
00AE:  BCF    29.6
....................    			if (!input(COL1)) teclaC=1; // Verifica se tecla está pressionada 
00AF:  BSF    03.5
00B0:  BSF    05.4
00B1:  BCF    03.5
00B2:  BTFSS  05.4
00B3:  BSF    29.4
....................    			if (!input(COL2)) tecla0=1; // Verifica se tecla está pressionada 
00B4:  BSF    03.5
00B5:  BSF    05.5
00B6:  BCF    03.5
00B7:  BTFSS  05.5
00B8:  BSF    28.0
....................    			if (!input(COL3)) teclaE=1; // Verifica se tecla está pressionada 
00B9:  BSF    03.5
00BA:  BSF    09.0
00BB:  BCF    03.5
00BC:  BTFSS  09.0
00BD:  BSF    29.6
....................    			break; 
00BE:  GOTO   0BF
....................       } 
.................... } 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                  Rotina de Atualização de Tela do LCD               * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
00BF:  BCF    0B.2
00C0:  BCF    0A.3
00C1:  BCF    0A.4
00C2:  GOTO   01D
.................... void Atualiza_tela(char dado) 
.................... { 
.................... 	Lcd_Inst(0x82);				       // Posiciona o cursor 
*
016D:  MOVLW  82
016E:  MOVWF  2C
016F:  CALL   0E0
....................    printf(lcd_dado,"A tecla %c foi",dado); 
0170:  CLRF   2C
0171:  MOVF   2C,W
0172:  CALL   033
0173:  INCF   2C,F
0174:  MOVWF  77
0175:  MOVWF  2E
0176:  CALL   14E
0177:  MOVLW  08
0178:  SUBWF  2C,W
0179:  BTFSS  03.2
017A:  GOTO   171
017B:  MOVF   2B,W
017C:  MOVWF  2E
017D:  CALL   14E
017E:  MOVLW  0A
017F:  MOVWF  2D
0180:  MOVF   2D,W
0181:  CALL   033
0182:  INCF   2D,F
0183:  MOVWF  77
0184:  MOVWF  2E
0185:  CALL   14E
0186:  MOVLW  0E
0187:  SUBWF  2D,W
0188:  BTFSS  03.2
0189:  GOTO   180
....................   	Lcd_Inst(0xC3);				       // Posiciona o cursor 
018A:  MOVLW  C3
018B:  MOVWF  2C
018C:  CALL   0E0
....................    printf(lcd_dado,"Pressionada");	 
018D:  CLRF   2C
018E:  MOVF   2C,W
018F:  CALL   046
0190:  IORLW  00
0191:  BTFSC  03.2
0192:  GOTO   197
0193:  INCF   2C,F
0194:  MOVWF  2E
0195:  CALL   14E
0196:  GOTO   18E
.................... } 
0197:  RETLW  00
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                  Rotina de Envio de Comando para o LCD              * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void Lcd_Inst(char dado) 
.................... { 
.................... 	disable_interrupts(GLOBAL);	  // Desliga as interrupções 
*
00E0:  BCF    0B.6
00E1:  BCF    0B.7
00E2:  BTFSC  0B.7
00E3:  GOTO   0E1
.................... 	output_low(RS);					  // Põe pino de RS em baixo, modo comando 
00E4:  BSF    03.5
00E5:  BCF    09.2
00E6:  BCF    03.5
00E7:  BCF    09.2
.................... 	output_d(dado);					  // Põe o dado no portd 
00E8:  BSF    03.5
00E9:  CLRF   08
00EA:  BCF    03.5
00EB:  MOVF   2C,W
00EC:  MOVWF  08
.................... 	delay_cycles(2);	   			  // Aguarda 2 us, acomodação 
00ED:  NOP
00EE:  NOP
.................... 	output_high(EN);      		     // Gera pulso de clock 
00EF:  BSF    03.5
00F0:  BCF    09.1
00F1:  BCF    03.5
00F2:  BSF    09.1
.................... 	delay_cycles(2); 
00F3:  NOP
00F4:  NOP
.................... 	output_low(EN); 
00F5:  BSF    03.5
00F6:  BCF    09.1
00F7:  BCF    03.5
00F8:  BCF    09.1
.................... 	delay_ms(1);				    	  // Aguarda 1ms 
00F9:  MOVLW  01
00FA:  MOVWF  2F
00FB:  CALL   0CB
.................... 	enable_interrupts(GLOBAL);		  // Liga as interrupções 
00FC:  MOVLW  C0
00FD:  IORWF  0B,F
.................... } 
00FE:  RETLW  00
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                  Rotina de Envio de Dados para o LCD                * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void Lcd_Dado(char dado) 
.................... { 
.................... 	disable_interrupts(GLOBAL);		// Desliga as interrupções 
*
014E:  BCF    0B.6
014F:  BCF    0B.7
0150:  BTFSC  0B.7
0151:  GOTO   14F
.................... 	output_high(RS);       				// Seta o pino RS, modo dado 
0152:  BSF    03.5
0153:  BCF    09.2
0154:  BCF    03.5
0155:  BSF    09.2
.................... 	output_d(dado);		   			// Põe o dado no portd 
0156:  BSF    03.5
0157:  CLRF   08
0158:  BCF    03.5
0159:  MOVF   2E,W
015A:  MOVWF  08
.................... 	delay_cycles(2);			       	// Aguarda 2us, acomodação 
015B:  NOP
015C:  NOP
.................... 	output_high(EN);	      			// Gera pulso de clock 
015D:  BSF    03.5
015E:  BCF    09.1
015F:  BCF    03.5
0160:  BSF    09.1
.................... 	delay_cycles(2); 
0161:  NOP
0162:  NOP
.................... 	output_low(EN); 
0163:  BSF    03.5
0164:  BCF    09.1
0165:  BCF    03.5
0166:  BCF    09.1
.................... 	delay_ms(1);	       				// Aguarda 1ms 
0167:  MOVLW  01
0168:  MOVWF  2F
0169:  CALL   0CB
.................... 	enable_interrupts(GLOBAL);		   // Liga as interrupções 
016A:  MOVLW  C0
016B:  IORWF  0B,F
.................... } 
016C:  RETLW  00
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *     		                 Fim do Programa						   * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
....................  
....................  
....................  

Configuration Fuses:
   Word  1: 3F31   XT NOWDT PUT NODEBUG NOPROTECT NOBROWNOUT NOLVP NOCPD NOWRT
