CCS PCM C Compiler, Version 3.245, 28193               11-fev-07 18:01

               Filename: C:\Cerne\CDs\kit PICLAB16f877A\Exemplos\Exemplos C\Memória I2C\mem_I2C.lst

               ROM used: 664 words (8%)
                         Largest free fragment is 2048
               RAM used: 35 (20%) at main() level
                         43 (25%) worst case
               Stack:    6 worst case (4 in main + 2 for interrupts)

*
0000:  MOVLW  00
0001:  MOVWF  0A
0002:  GOTO   24D
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  MOVF   7B,W
0016:  MOVWF  27
0017:  BCF    03.7
0018:  BCF    03.5
0019:  MOVLW  8C
001A:  MOVWF  04
001B:  BTFSS  00.5
001C:  GOTO   01F
001D:  BTFSC  0C.5
001E:  GOTO   036
001F:  BTFSS  0B.5
0020:  GOTO   023
0021:  BTFSC  0B.2
0022:  GOTO   039
0023:  MOVF   22,W
0024:  MOVWF  04
0025:  MOVF   23,W
0026:  MOVWF  77
0027:  MOVF   24,W
0028:  MOVWF  78
0029:  MOVF   25,W
002A:  MOVWF  79
002B:  MOVF   26,W
002C:  MOVWF  7A
002D:  MOVF   27,W
002E:  MOVWF  7B
002F:  MOVF   20,W
0030:  MOVWF  0A
0031:  SWAPF  21,W
0032:  MOVWF  03
0033:  SWAPF  7F,F
0034:  SWAPF  7F,W
0035:  RETFIE
0036:  BCF    0A.3
0037:  BCF    0A.4
0038:  GOTO   051
0039:  BCF    0A.3
003A:  BCF    0A.4
003B:  GOTO   09B
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *  			     Programação em C - Módulo B PIC16F877A            	      * 
....................  *                               Exemplo 10                                * 
....................  *                                                                         * 
....................  *                CENTRO DE TREINAMENTO - Cerne Tecnologia	               * 
....................  *                           www.cerne-tec.com.br                          * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *   VERSÃO : 1.0                                                          * 
....................  *   DATA : 16/05/2005                                                     * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                             Descrição geral                           * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
.................... // Apresentar a comunicação com a memória I2C Externa 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                		 	Definição de Cabeçalho						 * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... #include	<16F877A.h>				//microcontrolador utilizado 
.................... //////// Standard Header file for the PIC16F877A device //////////////// 
.................... #device PIC16F877A  
.................... #list 
....................  
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                         Configurações para gravação                   * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... #fuses xt,nolvp,wdt,nolvp,nobrownout,put,nodebug,noprotect,nowrt,nocpd 
.................... 								   // Configurações da Máquina 
....................                            // Oscilador: XT, LVP: Off, WDT: On, Brown-out: Off, Power-up: Off 
....................                            // Debug: Off, CP: Off, CPD: Off 
....................  
.................... #use delay(clock=4000000)          // Define o clock do sistema 
*
003C:  MOVLW  45
003D:  MOVWF  04
003E:  MOVF   00,W
003F:  BTFSC  03.2
0040:  GOTO   050
0041:  MOVLW  01
0042:  MOVWF  78
0043:  CLRF   77
0044:  DECFSZ 77,F
0045:  GOTO   044
0046:  DECFSZ 78,F
0047:  GOTO   043
0048:  MOVLW  4A
0049:  MOVWF  77
004A:  DECFSZ 77,F
004B:  GOTO   04A
004C:  NOP
004D:  NOP
004E:  DECFSZ 00,F
004F:  GOTO   041
0050:  RETLW  00
.................... #use rs232(baud=9600,xmit=pin_c6,rcv=pin_c7) 
....................            							     // Configura Usart 
.................... #use i2c(master,sda=pin_c4, scl=pin_c3, SLOW, RESTART_WDT, FORCE_HW) 
*
0135:  BCF    14.7
0136:  BCF    0C.3
0137:  MOVF   42,W
0138:  MOVWF  13
0139:  MOVLW  02
013A:  BTFSC  14.7
013B:  GOTO   143
013C:  BTFSS  0C.3
013D:  GOTO   13C
013E:  MOVLW  00
013F:  BSF    03.5
0140:  BTFSC  11.6
0141:  MOVLW  01
0142:  BCF    03.5
0143:  MOVWF  78
0144:  RETLW  00
0145:  BSF    03.5
0146:  BSF    11.3
0147:  BTFSC  11.3
0148:  GOTO   147
0149:  BTFSC  77.0
014A:  BCF    11.5
014B:  BTFSS  77.0
014C:  BSF    11.5
014D:  BSF    11.4
014E:  BTFSC  11.4
014F:  GOTO   14E
0150:  BCF    03.5
0151:  MOVF   13,W
0152:  MOVWF  78
0153:  BCF    0A.3
0154:  BCF    0A.4
0155:  GOTO   178 (RETURN)
*
026F:  MOVLW  FF
0270:  BCF    03.5
0271:  MOVWF  29
....................         	   	 					     // Configura porta I2C 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                 Definição e inicialização das variáveis               * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
.................... //Aqui iremos definir as variáveis globais do sistema 
....................  
.................... int1 tecla0=0, tecla1=0, tecla2=0, tecla3=0, tecla4=0, tecla5=0, tecla6=0, 
0272:  BCF    2A.0
0273:  BCF    2A.1
0274:  BCF    2A.2
0275:  BCF    2A.3
0276:  BCF    2A.4
0277:  BCF    2A.5
0278:  BCF    2A.6
....................      tecla7=0, tecla8=0, tecla9=0, teclaE=0, teclaC=0;     
0279:  BCF    2A.7
027A:  BCF    2B.0
027B:  BCF    2B.1
027C:  BCF    2B.2
027D:  BCF    2B.3
.................... int indice=0,indice_buffer=0; 
027E:  CLRF   2C
027F:  CLRF   2D
.................... int buffer[16]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; 
0280:  CLRF   2E
0281:  CLRF   2F
0282:  CLRF   30
0283:  CLRF   31
0284:  CLRF   32
0285:  CLRF   33
0286:  CLRF   34
0287:  CLRF   35
0288:  CLRF   36
0289:  CLRF   37
028A:  CLRF   38
028B:  CLRF   39
028C:  CLRF   3A
028D:  CLRF   3B
028E:  CLRF   3C
028F:  CLRF   3D
.................... 									// Declara e inicializa o vetor 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                           Constantes internas                         * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
.................... //Aqui iremos definir as constantes utilizadas pelo sistema 
....................  
.................... #define SEL_LINHA1	0b00001110	   // Seleção da linha 1 
.................... #define SEL_LINHA2	0b00001101	   // Seleção da linha 2 
.................... #define SEL_LINHA3	0b00001011    	// Seleção da linha 3 
.................... #define SEL_LINHA4	0b00000111  	// Seleção da linha 4 
.................... #define CTRL_LE		0b10100001		// byte de controle da memória p/ leitura 
.................... #define CTRL_ESCREV	0b10100000		// byte de controle da memória p/ escrita 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                                Entradas                               * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
.................... //Aqui iremos definir as entradas do sistema 
....................  
.................... #define  COL1	      PIN_A4 
.................... #define  COL2	      PIN_A5 
.................... #define  COL3        PIN_E0 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                                Saídas                               * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
.................... //Aqui iremos definir as saídas do sistema 
....................  
.................... #define  RS			  PIN_E2		// Pino de seleção de modo do display 
.................... #define  EN			  PIN_E1		// Pino de habilitação do display 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                       Prototipagem das funções                      * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
.................... //Aqui iremos declarar todas as funções definidas pelo usuário 
....................  
.................... void Inicializa(void); 
.................... void Lcd_Inst(char dado); 
.................... void Lcd_Dado(char dado); 
.................... void Lcd_Inst_Int(char dado); 
.................... void Lcd_Dado_Int(char dado); 
.................... void Grava_Buffer(void); 
.................... void Restaura_EEPROM(void); 
.................... void Le_Dados(void); 
.................... char Read_I2c (int address); 
.................... void Write_I2C (int address,int dado); 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                Definição de Prioridade das Interrupções             * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
.................... //Aqui iremos definir as prioridades das interrupções 
....................  
.................... #priority	rda, timer0 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                           Rotina Principal                		   * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
.................... //Nessa parte ficará o loop principal do sistema 
....................  
.................... void main (void) 
.................... { 
*
024D:  CLRF   04
024E:  MOVLW  1F
024F:  ANDWF  03,F
0250:  MOVLW  19
0251:  BSF    03.5
0252:  MOVWF  19
0253:  MOVLW  26
0254:  MOVWF  18
0255:  MOVLW  90
0256:  BCF    03.5
0257:  MOVWF  18
0258:  BSF    29.3
0259:  MOVF   29,W
025A:  BSF    03.5
025B:  MOVWF  07
025C:  BCF    03.5
025D:  BSF    29.4
025E:  MOVF   29,W
025F:  BSF    03.5
0260:  MOVWF  07
0261:  MOVLW  09
0262:  MOVWF  13
0263:  MOVLW  28
0264:  BCF    03.5
0265:  MOVWF  14
0266:  BSF    03.5
0267:  BSF    14.7
0268:  BCF    14.6
0269:  BSF    1F.0
026A:  BSF    1F.1
026B:  BSF    1F.2
026C:  BCF    1F.3
026D:  MOVLW  07
026E:  MOVWF  1C
.................... 	Inicializa();				// Chama rotina para inicializar o sistema 
*
0290:  GOTO   1B6
....................  
.................... 	while(1)					   // Entra em loop infinito 
.................... 		{ 
.................... 			restart_wdt();		             // Limpa o wdt 
0291:  CLRWDT
....................    	   if (teclaE) Grava_Buffer();    // Chama rotina para salvar o buffer 
0292:  BTFSC  2B.2
0293:  GOTO   212
....................  	      if (teclaC) Restaura_EEPROM(); // Chama rotina para restaurar 
0294:  BTFSC  2B.3
0295:  GOTO   245
....................  		 					           	 	    // os dados armazenados na EEPROM 
....................  
.................... 		} 
0296:  GOTO   291
.................... } 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                       Inicialização do Sistema                 	   * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void Inicializa(void) 
.................... { 
0297:  SLEEP
....................  
....................    delay_ms(2000); 
*
01B6:  MOVLW  08
01B7:  MOVWF  3E
01B8:  CLRF   28
01B9:  BTFSC  0B.7
01BA:  BSF    28.7
01BB:  BCF    0B.7
01BC:  MOVLW  FA
01BD:  MOVWF  45
01BE:  CALL   03C
01BF:  BTFSC  28.7
01C0:  BSF    0B.7
01C1:  DECFSZ 3E,F
01C2:  GOTO   1B8
....................  
....................    setup_adc_ports(no_analogs);   // Todos os AD´s desligados 
01C3:  BSF    03.5
01C4:  BSF    1F.0
01C5:  BSF    1F.1
01C6:  BSF    1F.2
01C7:  BCF    1F.3
....................  
....................    set_timer0(0);                 // Inicializa timer 0 com 0 
01C8:  BCF    03.5
01C9:  CLRF   01
....................    setup_timer_0(RTCC_INTERNAL | RTCC_DIV_1); // Timer configurado para clock 
01CA:  BSF    03.5
01CB:  MOVF   01,W
01CC:  ANDLW  C7
01CD:  IORLW  08
01CE:  MOVWF  01
....................                                               // Interno com prescaler de 1:4 
....................    setup_wdt(WDT_2304MS);         // Configura WDT para 2,304 s 
01CF:  MOVLW  0F
01D0:  MOVWF  77
01D1:  MOVLW  07
01D2:  BCF    03.5
01D3:  CLRF   01
01D4:  MOVLW  81
01D5:  MOVWF  04
01D6:  MOVF   00,W
01D7:  ANDLW  F0
01D8:  IORLW  07
01D9:  MOVWF  00
01DA:  CLRWDT
01DB:  MOVF   00,W
01DC:  ANDLW  F7
01DD:  BTFSC  77.3
01DE:  ANDLW  F0
01DF:  IORWF  77,W
01E0:  MOVWF  00
....................    enable_interrupts(INT_TIMER0); // Habilita interrupção de timer 0 
01E1:  BSF    0B.5
....................    enable_interrupts(INT_RDA);    // Habilita interrupção serial 
01E2:  BSF    03.5
01E3:  BSF    0C.5
....................    enable_interrupts(GLOBAL);     // Habilita todas as interrupções 
01E4:  MOVLW  C0
01E5:  BCF    03.5
01E6:  IORWF  0B,F
....................  
....................    Lcd_Inst(0x30);			      // Inicializa o display 
01E7:  MOVLW  30
01E8:  MOVWF  3F
01E9:  CALL   110
01EA:  CLRF   28
01EB:  BTFSC  0B.7
01EC:  BSF    28.7
01ED:  BCF    0B.7
....................    delay_ms(3); 
01EE:  MOVLW  03
01EF:  MOVWF  45
01F0:  CALL   03C
01F1:  BTFSC  28.7
01F2:  BSF    0B.7
....................    Lcd_Inst(0x30); 
01F3:  MOVLW  30
01F4:  MOVWF  3F
01F5:  CALL   110
....................    Lcd_Inst(0x30); 
01F6:  MOVLW  30
01F7:  MOVWF  3F
01F8:  CALL   110
....................    Lcd_Inst(0x38); 
01F9:  MOVLW  38
01FA:  MOVWF  3F
01FB:  CALL   110
....................    Lcd_Inst(0x01); 
01FC:  MOVLW  01
01FD:  MOVWF  3F
01FE:  CALL   110
01FF:  CLRF   28
0200:  BTFSC  0B.7
0201:  BSF    28.7
0202:  BCF    0B.7
....................    delay_ms(1); 
0203:  MOVLW  01
0204:  MOVWF  45
0205:  CALL   03C
0206:  BTFSC  28.7
0207:  BSF    0B.7
....................    Lcd_Inst(0x0C); 
0208:  MOVLW  0C
0209:  MOVWF  3F
020A:  CALL   110
....................    Lcd_Inst(0x06); 
020B:  MOVLW  06
020C:  MOVWF  3F
020D:  CALL   110
....................    Le_Dados(); 
020E:  CALL   156
.................... } 
020F:  BCF    0A.3
0210:  BCF    0A.4
0211:  GOTO   291 (RETURN)
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                 Rotina de Escrita no Barramento I2C                 * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void Write_I2C (int address,int dado) 
.................... { 
.................... 	i2c_start();				// Condição de início 
*
0220:  BSF    03.5
0221:  BSF    11.0
0222:  BTFSC  11.0
0223:  GOTO   222
.................... 	i2c_write(ctrl_escrev);		// Envia o byte de controle de leitura 
0224:  MOVLW  A0
0225:  BCF    03.5
0226:  MOVWF  42
0227:  CALL   135
.................... 	i2c_write(address);			// Envia endereço baixo 
0228:  MOVF   40,W
0229:  MOVWF  42
022A:  CALL   135
.................... 	i2c_write(dado);			// Escreve dado na E²PROM 
022B:  MOVF   41,W
022C:  MOVWF  42
022D:  CALL   135
.................... 	i2c_stop();					// Condição de parada 
022E:  BSF    03.5
022F:  BSF    11.2
0230:  BTFSC  11.2
0231:  GOTO   230
0232:  BCF    03.5
0233:  CLRF   28
0234:  BTFSC  0B.7
0235:  BSF    28.7
0236:  BCF    0B.7
.................... 	delay_ms(5);				// espera a gravação estar completa 
0237:  MOVLW  05
0238:  MOVWF  45
0239:  CALL   03C
023A:  BTFSC  28.7
023B:  BSF    0B.7
.................... } 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                 Rotina de Leitura no Barramento I2C                 * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... char Read_I2C (int address) 
.................... { 
.................... 	char dado; 
.................... 	i2c_start();					// Condição de início 
*
0163:  BSF    03.5
0164:  BSF    11.0
0165:  BTFSC  11.0
0166:  GOTO   165
.................... 	i2c_write(ctrl_escrev);				// Envia o byte de controle de leitura 
0167:  MOVLW  A0
0168:  BCF    03.5
0169:  MOVWF  42
016A:  CALL   135
.................... 	i2c_write(address);				// Envia endereço baixo 
016B:  MOVF   40,W
016C:  MOVWF  42
016D:  CALL   135
.................... 	i2c_start();					// Nova condição de início 
016E:  BSF    03.5
016F:  BSF    11.1
0170:  BTFSC  11.1
0171:  GOTO   170
.................... 	i2c_write(ctrl_le);				// Envia o byte de controle de leitura 
0172:  MOVLW  A1
0173:  BCF    03.5
0174:  MOVWF  42
0175:  CALL   135
.................... 	dado = i2c_read(0);				// lê o dado armazenado na E²PROM 
0176:  CLRF   77
0177:  GOTO   145
0178:  MOVF   78,W
0179:  MOVWF  41
.................... 	i2c_stop();					// Condição de parada 
017A:  BSF    03.5
017B:  BSF    11.2
017C:  BTFSC  11.2
017D:  GOTO   17C
.................... 	return(dado); 
017E:  BCF    03.5
017F:  MOVF   41,W
0180:  MOVWF  78
.................... } 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *			Rotina para Led os Dados da EEPROM e tocar o beep	   	   * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void Restaura_EEPROM(void) 
.................... { 
.................... 	Le_Dados(); 
*
0245:  CALL   156
.................... 	while(teclaC){restart_wdt();} 
0246:  BTFSS  2B.3
0247:  GOTO   24A
0248:  CLRWDT
0249:  GOTO   246
.................... } 
024A:  BCF    0A.3
024B:  BCF    0A.4
024C:  GOTO   296 (RETURN)
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *      Rotina para Led os Dados da EEPROM e apresentar no display	   * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void Le_Dados(void) 
.................... { 
.................... 	int contador; 
.................... 	Lcd_Inst(0x80); 
*
0156:  MOVLW  80
0157:  MOVWF  3F
0158:  CALL   110
....................  
.................... 	for(contador=0;contador<=15;contador++) 
0159:  CLRF   3E
015A:  MOVF   3E,W
015B:  SUBLW  0F
015C:  BTFSS  03.0
015D:  GOTO   1B2
.................... 	 { 
.................... 		 buffer[contador]=Read_I2C(contador); 
015E:  MOVLW  2E
015F:  ADDWF  3E,W
0160:  MOVWF  3F
0161:  MOVF   3E,W
0162:  MOVWF  40
*
0181:  MOVF   3F,W
0182:  MOVWF  04
0183:  MOVF   78,W
0184:  MOVWF  00
.................... 		 Lcd_Dado(buffer[contador]); 
0185:  MOVLW  2E
0186:  ADDWF  3E,W
0187:  MOVWF  04
0188:  MOVF   00,W
0189:  MOVWF  3F
018A:  MOVF   3F,W
018B:  MOVWF  40
.................... 	 } 
*
01B0:  INCF   3E,F
01B1:  GOTO   15A
.................... 	Lcd_Inst(0x80); 
01B2:  MOVLW  80
01B3:  MOVWF  3F
01B4:  CALL   110
.................... } 
01B5:  RETLW  00
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *   		    Rotina para Gravar o Buffer na EEPROM				   * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void Grava_Buffer(void) 
.................... { 
.................... 	int contador; 
.................... 	for(contador=0;contador<=15;contador++) 
*
0212:  CLRF   3E
0213:  MOVF   3E,W
0214:  SUBLW  0F
0215:  BTFSS  03.0
0216:  GOTO   23E
.................... 	 { 
.................... 		 write_I2C(contador,buffer[contador]); 
0217:  MOVLW  2E
0218:  ADDWF  3E,W
0219:  MOVWF  04
021A:  MOVF   00,W
021B:  MOVWF  3F
021C:  MOVF   3E,W
021D:  MOVWF  40
021E:  MOVF   3F,W
021F:  MOVWF  41
.................... 	 } 
*
023C:  INCF   3E,F
023D:  GOTO   213
....................  
.................... 	 while(teclaE){restart_wdt();} 
023E:  BTFSS  2B.2
023F:  GOTO   242
0240:  CLRWDT
0241:  GOTO   23E
.................... } 
0242:  BCF    0A.3
0243:  BCF    0A.4
0244:  GOTO   294 (RETURN)
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *   		    Rotina para Enviar Comandos para o LCD				   * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void Lcd_Inst(char dado) 
.................... { 
.................... 	disable_interrupts(GLOBAL);		// Desliga as interrupções 
*
0110:  BCF    0B.6
0111:  BCF    0B.7
0112:  BTFSC  0B.7
0113:  GOTO   111
.................... 	output_low(RS);					// Põe pino de RS em baixo, modo comando 
0114:  BSF    03.5
0115:  BCF    09.2
0116:  BCF    03.5
0117:  BCF    09.2
.................... 	output_d(dado);					// Põe o dado no portd 
0118:  BSF    03.5
0119:  CLRF   08
011A:  BCF    03.5
011B:  MOVF   3F,W
011C:  MOVWF  08
.................... 	delay_cycles(2);				// Aguarda 2 us, acomodação 
011D:  NOP
011E:  NOP
.................... 	output_high(EN);				// Gera pulso de clock 
011F:  BSF    03.5
0120:  BCF    09.1
0121:  BCF    03.5
0122:  BSF    09.1
.................... 	delay_cycles(2); 
0123:  NOP
0124:  NOP
.................... 	output_low(EN); 
0125:  BSF    03.5
0126:  BCF    09.1
0127:  BCF    03.5
0128:  BCF    09.1
0129:  CLRF   28
012A:  BTFSC  0B.7
012B:  BSF    28.7
012C:  BCF    0B.7
.................... 	delay_ms(1);					// Aguarda 1ms 
012D:  MOVLW  01
012E:  MOVWF  45
012F:  CALL   03C
0130:  BTFSC  28.7
0131:  BSF    0B.7
.................... 	enable_interrupts(GLOBAL);		// Liga as interrupções 
0132:  MOVLW  C0
0133:  IORWF  0B,F
.................... } 
0134:  RETLW  00
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *   		        Rotina para Enviar Dados para o LCD				   * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void Lcd_Dado(char dado) 
.................... { 
.................... 	disable_interrupts(GLOBAL);		// Desliga as interrupções 
*
018C:  BCF    0B.6
018D:  BCF    0B.7
018E:  BTFSC  0B.7
018F:  GOTO   18D
.................... 	output_high(RS);				// Seta o pino RS, modo dado 
0190:  BSF    03.5
0191:  BCF    09.2
0192:  BCF    03.5
0193:  BSF    09.2
.................... 	output_d(dado);					// Põe o dado no portd 
0194:  BSF    03.5
0195:  CLRF   08
0196:  BCF    03.5
0197:  MOVF   40,W
0198:  MOVWF  08
.................... 	delay_cycles(2);				// Aguarda 2us, acomodação 
0199:  NOP
019A:  NOP
.................... 	output_high(EN);				// Gera pulso de clock 
019B:  BSF    03.5
019C:  BCF    09.1
019D:  BCF    03.5
019E:  BSF    09.1
.................... 	delay_cycles(2); 
019F:  NOP
01A0:  NOP
.................... 	output_low(EN); 
01A1:  BSF    03.5
01A2:  BCF    09.1
01A3:  BCF    03.5
01A4:  BCF    09.1
01A5:  CLRF   28
01A6:  BTFSC  0B.7
01A7:  BSF    28.7
01A8:  BCF    0B.7
.................... 	delay_ms(1);					// Aguarda 1ms 
01A9:  MOVLW  01
01AA:  MOVWF  45
01AB:  CALL   03C
01AC:  BTFSC  28.7
01AD:  BSF    0B.7
.................... 	enable_interrupts(GLOBAL);		// Liga as interrupções 
01AE:  MOVLW  C0
01AF:  IORWF  0B,F
.................... } 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *       Rotina para Enviar Comandos para o LCD pela Interrupção	   * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void Lcd_Inst_Int(char dado) 
.................... { 
.................... 	output_low(RS);					// Põe pino de RS em baixo, modo comando 
*
0058:  BSF    03.5
0059:  BCF    09.2
005A:  BCF    03.5
005B:  BCF    09.2
.................... 	output_d(dado);					// Põe o dado no portd 
005C:  BSF    03.5
005D:  CLRF   08
005E:  BCF    03.5
005F:  MOVF   43,W
0060:  MOVWF  08
.................... 	delay_cycles(2);				// Aguarda 2 us, acomodação 
0061:  NOP
0062:  NOP
.................... 	output_high(EN);				// Gera pulso de clock 
0063:  BSF    03.5
0064:  BCF    09.1
0065:  BCF    03.5
0066:  BSF    09.1
.................... 	delay_cycles(2); 
0067:  NOP
0068:  NOP
.................... 	output_low(EN); 
0069:  BSF    03.5
006A:  BCF    09.1
006B:  BCF    03.5
006C:  BCF    09.1
.................... 	delay_ms(1);					// Aguarda 1ms 
006D:  MOVLW  01
006E:  MOVWF  45
006F:  CALL   03C
.................... } 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *        Rotina para Enviar Dados para o LCD pela Interrupção		   * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void Lcd_Dado_Int(char dado) 
.................... { 
.................... 	output_high(RS);				// Seta o pino RS, modo dado 
*
007E:  BSF    03.5
007F:  BCF    09.2
0080:  BCF    03.5
0081:  BSF    09.2
.................... 	output_d(dado);					// Põe o dado no portd 
0082:  BSF    03.5
0083:  CLRF   08
0084:  BCF    03.5
0085:  MOVF   44,W
0086:  MOVWF  08
.................... 	delay_cycles(2);				// Aguarda 2us, acomodação 
0087:  NOP
0088:  NOP
.................... 	output_high(EN);				// Gera pulso de clock 
0089:  BSF    03.5
008A:  BCF    09.1
008B:  BCF    03.5
008C:  BSF    09.1
.................... 	delay_cycles(2); 
008D:  NOP
008E:  NOP
.................... 	output_low(EN); 
008F:  BSF    03.5
0090:  BCF    09.1
0091:  BCF    03.5
0092:  BCF    09.1
.................... 	delay_ms(1);					// Aguarda 1ms 
0093:  MOVLW  01
0094:  MOVWF  45
0095:  CALL   03C
.................... } 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *   		        Rotina de Tratamento de Recepção Serial			   * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... #int_rda 
.................... void Isr_Serial(void) 
.................... { 
.................... 	if (indice_buffer==16) 
*
0051:  MOVF   2D,W
0052:  SUBLW  10
0053:  BTFSS  03.2
0054:  GOTO   070
.................... 		{ 
.................... 			indice_buffer=0; 
0055:  CLRF   2D
.................... 			Lcd_Inst_Int(0x80); 
0056:  MOVLW  80
0057:  MOVWF  43
.................... 		} 
....................  
.................... 	buffer[indice_buffer]=getc(); 
*
0070:  MOVLW  2E
0071:  ADDWF  2D,W
0072:  MOVWF  04
0073:  BTFSS  0C.5
0074:  GOTO   073
0075:  MOVF   1A,W
0076:  MOVWF  00
.................... 	Lcd_Dado_Int(buffer[indice_buffer]); 
0077:  MOVLW  2E
0078:  ADDWF  2D,W
0079:  MOVWF  04
007A:  MOVF   00,W
007B:  MOVWF  43
007C:  MOVF   43,W
007D:  MOVWF  44
.................... 	indice_buffer++; 
*
0096:  INCF   2D,F
.................... } 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *   		        Rotina de Tratamento de Timer 0			   		   * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
0097:  BCF    0C.5
0098:  BCF    0A.3
0099:  BCF    0A.4
009A:  GOTO   023
.................... #int_timer0 
.................... void Ist_Timer0(void) 
.................... { 
....................    indice++;                            // Incrementa indice 
009B:  INCF   2C,F
....................  
....................    switch(indice)                       // Seleção de casos com indice 
....................       { 
009C:  MOVLW  01
009D:  SUBWF  2C,W
009E:  ADDLW  FC
009F:  BTFSC  03.0
00A0:  GOTO   104
00A1:  ADDLW  04
00A2:  GOTO   108
....................  
....................          case 1:                        // Caso seja 1... 
....................    			output_d(SEL_LINHA1);	    // Seleciona no barramento a linha 1 
00A3:  BSF    03.5
00A4:  CLRF   08
00A5:  MOVLW  0E
00A6:  BCF    03.5
00A7:  MOVWF  08
....................    			tecla1=0;			          // Limpa a tecla pressionada 
00A8:  BCF    2A.1
....................    			tecla2=0;			          // Limpa a tecla pressionada 
00A9:  BCF    2A.2
....................    			tecla3=0;			          // Limpa a tecla pressionada 
00AA:  BCF    2A.3
....................    			if (!input(COL1)) tecla1=1; // Verifica se tecla está pressionada 
00AB:  BSF    03.5
00AC:  BSF    05.4
00AD:  BCF    03.5
00AE:  BTFSS  05.4
00AF:  BSF    2A.1
....................    			if (!input(COL2)) tecla2=1; // Verifica se tecla está pressionada 
00B0:  BSF    03.5
00B1:  BSF    05.5
00B2:  BCF    03.5
00B3:  BTFSS  05.5
00B4:  BSF    2A.2
....................    			if (!input(COL3)) tecla3=1; // Verifica se tecla está pressionada 
00B5:  BSF    03.5
00B6:  BSF    09.0
00B7:  BCF    03.5
00B8:  BTFSS  09.0
00B9:  BSF    2A.3
....................             break; 
00BA:  GOTO   104
....................  
....................          case 2:                        // Caso seja 2... 
....................    			output_d(SEL_LINHA2);	    // Seleciona no barramento a linha 1 
00BB:  BSF    03.5
00BC:  CLRF   08
00BD:  MOVLW  0D
00BE:  BCF    03.5
00BF:  MOVWF  08
....................    			tecla4=0;				       // Limpa a tecla pressionada 
00C0:  BCF    2A.4
....................    			tecla5=0;				       // Limpa a tecla pressionada 
00C1:  BCF    2A.5
....................    			tecla6=0;		       		 // Limpa a tecla pressionada 
00C2:  BCF    2A.6
....................    			if (!input(COL1)) tecla4=1; // Verifica se tecla está pressionada 
00C3:  BSF    03.5
00C4:  BSF    05.4
00C5:  BCF    03.5
00C6:  BTFSS  05.4
00C7:  BSF    2A.4
....................    			if (!input(COL2)) tecla5=1; // Verifica se tecla está pressionada 
00C8:  BSF    03.5
00C9:  BSF    05.5
00CA:  BCF    03.5
00CB:  BTFSS  05.5
00CC:  BSF    2A.5
....................    			if (!input(COL3)) tecla6=1; // Verifica se tecla está pressionada 
00CD:  BSF    03.5
00CE:  BSF    09.0
00CF:  BCF    03.5
00D0:  BTFSS  09.0
00D1:  BSF    2A.6
....................             break; 
00D2:  GOTO   104
....................  
....................          case 3:                        // Caso seja 3... 
....................    			output_d(SEL_LINHA3);	    // Seleciona no barramento a linha 3 
00D3:  BSF    03.5
00D4:  CLRF   08
00D5:  MOVLW  0B
00D6:  BCF    03.5
00D7:  MOVWF  08
....................    			tecla7=0;				       // Limpa a tecla pressionada 
00D8:  BCF    2A.7
....................    			tecla8=0;				       // Limpa a tecla pressionada 
00D9:  BCF    2B.0
....................    			tecla9=0;		        	    // Limpa a tecla pressionada 
00DA:  BCF    2B.1
....................    			if (!input(COL1)) tecla7=1; // Verifica se tecla está pressionada 
00DB:  BSF    03.5
00DC:  BSF    05.4
00DD:  BCF    03.5
00DE:  BTFSS  05.4
00DF:  BSF    2A.7
....................    			if (!input(COL2)) tecla8=1; // Verifica se tecla está pressionada 
00E0:  BSF    03.5
00E1:  BSF    05.5
00E2:  BCF    03.5
00E3:  BTFSS  05.5
00E4:  BSF    2B.0
....................    			if (!input(COL3)) tecla9=1; // Verifica se tecla está pressionada 
00E5:  BSF    03.5
00E6:  BSF    09.0
00E7:  BCF    03.5
00E8:  BTFSS  09.0
00E9:  BSF    2B.1
....................             break; 
00EA:  GOTO   104
....................  
....................          case 4:                        // Caso seja 4... 
....................             indice=0;                   // Reinicia indice 
00EB:  CLRF   2C
....................    			output_d(SEL_LINHA4);	    // Seleciona no barramento a linha 4 
00EC:  BSF    03.5
00ED:  CLRF   08
00EE:  MOVLW  07
00EF:  BCF    03.5
00F0:  MOVWF  08
....................    			teclaC=0;				       // Limpa a tecla pressionada 
00F1:  BCF    2B.3
....................    			tecla0=0;				       // Limpa a tecla pressionada 
00F2:  BCF    2A.0
....................    			teclaE=0;		       	    // Limpa a tecla pressionada 
00F3:  BCF    2B.2
....................    			if (!input(COL1)) teclaC=1; // Verifica se tecla está pressionada 
00F4:  BSF    03.5
00F5:  BSF    05.4
00F6:  BCF    03.5
00F7:  BTFSS  05.4
00F8:  BSF    2B.3
....................    			if (!input(COL2)) tecla0=1; // Verifica se tecla está pressionada 
00F9:  BSF    03.5
00FA:  BSF    05.5
00FB:  BCF    03.5
00FC:  BTFSS  05.5
00FD:  BSF    2A.0
....................    			if (!input(COL3)) teclaE=1; // Verifica se tecla está pressionada 
00FE:  BSF    03.5
00FF:  BSF    09.0
0100:  BCF    03.5
0101:  BTFSS  09.0
0102:  BSF    2B.2
....................             break; 
0103:  GOTO   104
....................       } 
.................... } 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *   				        Fim do Programa							   * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
....................  
....................  
0104:  BCF    0B.2
0105:  BCF    0A.3
0106:  BCF    0A.4
0107:  GOTO   023

Configuration Fuses:
   Word  1: 3F35   XT WDT PUT NODEBUG NOPROTECT NOBROWNOUT NOLVP NOCPD NOWRT
