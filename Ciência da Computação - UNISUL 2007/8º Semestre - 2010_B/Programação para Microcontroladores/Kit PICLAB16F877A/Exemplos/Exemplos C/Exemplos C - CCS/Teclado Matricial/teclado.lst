CCS PCM C Compiler, Version 3.245, 28193               11-fev-07 14:05

               Filename: C:\Cerne\CDs\kit PICLAB16f877A\Exemplos\Exemplos C\Teclado Matricial\teclado.lst

               ROM used: 365 words (4%)
                         Largest free fragment is 2048
               RAM used: 20 (11%) at main() level
                         21 (12%) worst case
               Stack:    3 worst case (1 in main + 2 for interrupts)

*
0000:  MOVLW  00
0001:  MOVWF  0A
0002:  GOTO   11F
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  MOVF   7B,W
0016:  MOVWF  27
0017:  BCF    03.7
0018:  BCF    03.5
0019:  BTFSS  0B.5
001A:  GOTO   01D
001B:  BTFSC  0B.2
001C:  GOTO   030
001D:  MOVF   22,W
001E:  MOVWF  04
001F:  MOVF   23,W
0020:  MOVWF  77
0021:  MOVF   24,W
0022:  MOVWF  78
0023:  MOVF   25,W
0024:  MOVWF  79
0025:  MOVF   26,W
0026:  MOVWF  7A
0027:  MOVF   27,W
0028:  MOVWF  7B
0029:  MOVF   20,W
002A:  MOVWF  0A
002B:  SWAPF  21,W
002C:  MOVWF  03
002D:  SWAPF  7F,F
002E:  SWAPF  7F,W
002F:  RETFIE
0030:  BCF    0A.3
0031:  BCF    0A.4
0032:  GOTO   046
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *    			   Programação em C - Módulo B PIC16F877A            	      * 
....................  *                               Exemplo 3                                 * 
....................  *                                                                         * 
....................  *                CENTRO DE TREINAMENTO - Cerne Tecnologia	               * 
....................  *                           www.cerne-tec.com.br                          * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *   VERSÃO : 1.0                                                          * 
....................  *   DATA : 16/05/2005                                                     * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                             Descrição geral                           * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
.................... // Implementar uma rotina para ler o Teclado Matricial 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                		 	Definição de Cabeçalho						 * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... #include	<16F877A.h>				//microcontrolador utilizado 
.................... //////// Standard Header file for the PIC16F877A device //////////////// 
.................... #device PIC16F877A 
.................... #list 
....................  
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                         Configurações para gravação                   * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... #fuses xt,nolvp,wdt,nolvp,nobrownout,put,nodebug,noprotect,nowrt,nocpd 
....................          		 					     // Configurações da Máquina 
....................                                    // Oscilador: XT 
....................                                    // LVP: Off 
....................                                    // WDT: On 
....................                                    // Brown-out: Off 
....................                                    // Power-up: Off 
....................                                    // Debug: Off 
....................                                    // CP: Off 
....................                                    // CPD: Off 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                 Definição e inicialização das variáveis               * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
.................... //Aqui iremos definir as variáveis globais do sistema 
....................  
.................... int milhar=0,centena=0,dezena=0,unidade=0,indice=0; 
*
0129:  BCF    03.5
012A:  CLRF   28
012B:  CLRF   29
012C:  CLRF   2A
012D:  CLRF   2B
012E:  CLRF   2C
.................... int1 tecla0=0, tecla1=0, tecla2=0, tecla3=0, tecla4=0, tecla5=0; 
012F:  BCF    2D.0
0130:  BCF    2D.1
0131:  BCF    2D.2
0132:  BCF    2D.3
0133:  BCF    2D.4
0134:  BCF    2D.5
.................... int1 tecla6=0, tecla7=0, tecla8=0, tecla9=0, teclaE=0, teclaC=0; 
0135:  BCF    2D.6
0136:  BCF    2D.7
0137:  BCF    2E.0
0138:  BCF    2E.1
0139:  BCF    2E.2
013A:  BCF    2E.3
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                           Constantes internas                         * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
.................... //Aqui iremos definir as constantes utilizadas pelo sistema 
....................  
.................... #define CHR_0  		0b00111111 
.................... #define CHR_1  		0b00000110 
.................... #define CHR_2  		0b01011011 
.................... #define CHR_3  		0b01001111 
.................... #define CHR_4  		0b01100110 
.................... #define CHR_5  		0b01101101 
.................... #define CHR_6  		0b01111101 
.................... #define CHR_7  		0b00000111 
.................... #define CHR_8  		0b01111111 
.................... #define CHR_9  		0b01101111 
.................... #define CHR_A  		0b01110111 
.................... #define CHR_B  		0b01111100 
.................... #define CHR_C  		0b00111001 
.................... #define CHR_D  		0b01011110 
.................... #define CHR_E  		0b01111001 
.................... #define CHR_F  		0b01110001 
....................  
.................... const int converte_to_7seg[]={CHR_0,CHR_1,CHR_2,CHR_3,CHR_4,CHR_5,CHR_6, 
....................                               CHR_7,CHR_9,CHR_A,CHR_B,CHR_C,CHR_D,CHR_E,CHR_F}; 
....................                                     //Caracteres para o displayt de 7 segmentos 
....................  
.................... #define SEL_LINHA1	0b00001110 
.................... #define SEL_LINHA2	0b00001101 
.................... #define SEL_LINHA3	0b00001011 
.................... #define SEL_LINHA4	0b00000111 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                                Entradas                               * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
.................... //Aqui iremos definir as entradas do sistema 
....................  
.................... #define  COL1	      PIN_A4 
.................... #define  COL2	      PIN_A5 
.................... #define  COL3        PIN_E0 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                                Saídas                               * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
.................... //Aqui iremos definir as saídas do sistema 
....................  
.................... #define SEL_UNIDADE   PIN_B1 
.................... #define SEL_DEZENA    PIN_B2 
.................... #define SEL_CENTENA   PIN_B3 
.................... #define SEL_MILHAR    PIN_B4 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                       Prototipagem das funções                      * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
.................... //Aqui iremos declarar todas as funções definidas pelo usuário 
....................  
.................... void Inicializa(void); 
.................... void Verifica_Linha(int linha); 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                           Rotina Principal                		   * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
.................... //Nessa parte ficará o loop principal do sistema 
....................  
.................... void main (void) 
.................... { 
*
011F:  CLRF   04
0120:  MOVLW  1F
0121:  ANDWF  03,F
0122:  BSF    03.5
0123:  BSF    1F.0
0124:  BSF    1F.1
0125:  BSF    1F.2
0126:  BCF    1F.3
0127:  MOVLW  07
0128:  MOVWF  1C
.................... 	Inicializa();					// Chama rotina para inicializar o sistema 
*
013B:  GOTO   0FB
....................  
.................... 	while(1)						// Entra em loop infinito 
.................... 		{ 
.................... 			restart_wdt();			// Limpa o wdt 
013C:  CLRWDT
....................  
.................... 			if (tecla1)	milhar=1; 	// Atualiza valor da variável milhar 
013D:  BTFSS  2D.1
013E:  GOTO   141
013F:  MOVLW  01
0140:  MOVWF  28
.................... 			if (tecla2) milhar=2; 	// Atualiza valor da variável milhar 
0141:  BTFSS  2D.2
0142:  GOTO   145
0143:  MOVLW  02
0144:  MOVWF  28
.................... 			if (tecla3) milhar=3; 	// Atualiza valor da variável milhar 
0145:  BTFSS  2D.3
0146:  GOTO   149
0147:  MOVLW  03
0148:  MOVWF  28
....................  
.................... 			if (tecla4) centena=4; 	// Atualiza valor da variável centena 
0149:  BTFSS  2D.4
014A:  GOTO   14D
014B:  MOVLW  04
014C:  MOVWF  29
.................... 			if (tecla5) centena=5; 	// Atualiza valor da variável centena 
014D:  BTFSS  2D.5
014E:  GOTO   151
014F:  MOVLW  05
0150:  MOVWF  29
.................... 	 		if (tecla6) centena=6; 	// Atualiza valor da variável centena 
0151:  BTFSS  2D.6
0152:  GOTO   155
0153:  MOVLW  06
0154:  MOVWF  29
....................  
.................... 			if (tecla7) dezena=7;	// Atualiza valor da variável dezena 
0155:  BTFSS  2D.7
0156:  GOTO   159
0157:  MOVLW  07
0158:  MOVWF  2A
.................... 			if (tecla8) dezena=8; 	// Atualiza valor da variável dezena 
0159:  BTFSS  2E.0
015A:  GOTO   15D
015B:  MOVLW  08
015C:  MOVWF  2A
.................... 			if (tecla9) dezena=9; 	// Atualiza valor da variável dezena 
015D:  BTFSS  2E.1
015E:  GOTO   161
015F:  MOVLW  09
0160:  MOVWF  2A
....................  
.................... 			if (teclaC) unidade=12; // Atualiza valor da variável unidade 
0161:  BTFSS  2E.3
0162:  GOTO   165
0163:  MOVLW  0C
0164:  MOVWF  2B
.................... 			if (tecla0) unidade=0;  // Atualiza valor da variável unidade 
0165:  BTFSC  2D.0
0166:  CLRF   2B
.................... 			if (teclaE) unidade=14; // Atualiza valor da variável unidade 
0167:  BTFSS  2E.2
0168:  GOTO   16B
0169:  MOVLW  0E
016A:  MOVWF  2B
....................  
.................... 		} 
016B:  GOTO   13C
.................... } 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                       Inicialização do Sistema                 	   * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void Inicializa(void) 
.................... { 
016C:  SLEEP
....................    setup_wdt(WDT_2304MS);           // Configura WDT para 2,304 s 
*
00FB:  MOVLW  0F
00FC:  MOVWF  77
00FD:  MOVLW  07
00FE:  CLRF   01
00FF:  MOVLW  81
0100:  MOVWF  04
0101:  MOVF   00,W
0102:  ANDLW  F0
0103:  IORLW  07
0104:  MOVWF  00
0105:  CLRWDT
0106:  MOVF   00,W
0107:  ANDLW  F7
0108:  BTFSC  77.3
0109:  ANDLW  F0
010A:  IORWF  77,W
010B:  MOVWF  00
....................  
....................    setup_adc_ports(no_analogs);   	// Todos os AD´s desligados 
010C:  BSF    03.5
010D:  BSF    1F.0
010E:  BSF    1F.1
010F:  BSF    1F.2
0110:  BCF    1F.3
....................  
....................    set_timer0(0);                 	// Inicializa timer 0 com 0 
0111:  BCF    03.5
0112:  CLRF   01
....................    setup_timer_0(RTCC_INTERNAL | RTCC_DIV_16); 
0113:  BSF    03.5
0114:  MOVF   01,W
0115:  ANDLW  C0
0116:  IORLW  03
0117:  MOVWF  01
....................                                     // Timer configurado para clock 
....................                                     // Interno com prescaler de 1:4 
....................  
....................    enable_interrupts(INT_TIMER0);   // Habilita interrupção de timer 0 
0118:  BCF    03.5
0119:  BSF    0B.5
....................    enable_interrupts(GLOBAL);       // Habilita todas as interrupções 
011A:  MOVLW  C0
011B:  IORWF  0B,F
.................... } 
011C:  BCF    0A.3
011D:  BCF    0A.4
011E:  GOTO   13C (RETURN)
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                  Tratamento da Interrupção de Timer 0               * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... #int_timer0 
.................... void Ist_Timer0(void) 
.................... { 
....................    indice++;                        // Incrementa indice 
*
0046:  INCF   2C,F
....................  
....................    switch(indice)                   // Seleção de casos com indice 
....................       { 
0047:  MOVLW  01
0048:  SUBWF  2C,W
0049:  ADDLW  FC
004A:  BTFSC  03.0
004B:  GOTO   0EF
004C:  ADDLW  04
004D:  GOTO   0F3
....................  
....................          case 1:                     // Caso seja 1... 
....................             output_low(SEL_UNIDADE); // Retira a seleção do display anterior 
004E:  BSF    03.5
004F:  BCF    06.1
0050:  BCF    03.5
0051:  BCF    06.1
....................    			output_d(SEL_LINHA1);	 // Seleciona no barramento a linha 1 
0052:  BSF    03.5
0053:  CLRF   08
0054:  MOVLW  0E
0055:  BCF    03.5
0056:  MOVWF  08
.................... 	    		tecla1=0;			       // Limpa a tecla pressionada 
0057:  BCF    2D.1
.................... 	  	  	   tecla2=0;			       // Limpa a tecla pressionada 
0058:  BCF    2D.2
.................... 	     		tecla3=0;			     	 // Limpa a tecla pressionada 
0059:  BCF    2D.3
.................... 			   if (!input(COL1)) tecla1=1; // Verifica se tecla está pressionada 
005A:  BSF    03.5
005B:  BSF    05.4
005C:  BCF    03.5
005D:  BTFSS  05.4
005E:  BSF    2D.1
....................    			if (!input(COL2)) tecla2=1; // Verifica se tecla está pressionada 
005F:  BSF    03.5
0060:  BSF    05.5
0061:  BCF    03.5
0062:  BTFSS  05.5
0063:  BSF    2D.2
.................... 	     		if (!input(COL3)) tecla3=1; // Verifica se tecla está pressionada 
0064:  BSF    03.5
0065:  BSF    09.0
0066:  BCF    03.5
0067:  BTFSS  09.0
0068:  BSF    2D.3
....................             output_d(Converte_to_7seg[milhar]); 
0069:  MOVF   28,W
006A:  CALL   033
006B:  MOVWF  2F
006C:  BSF    03.5
006D:  CLRF   08
006E:  BCF    03.5
006F:  MOVF   2F,W
0070:  MOVWF  08
....................             output_high(SEL_MILHAR);    // Mostra o dado no barramento 
0071:  BSF    03.5
0072:  BCF    06.4
0073:  BCF    03.5
0074:  BSF    06.4
....................             break;				        	 // Liga display selecionado 
0075:  GOTO   0EF
....................  
....................          case 2:                     // Caso seja 2... 
....................             output_low(SEL_MILHAR);  // Retira a seleção do display anterior 
0076:  BSF    03.5
0077:  BCF    06.4
0078:  BCF    03.5
0079:  BCF    06.4
....................    			output_d(SEL_LINHA2);	 // Seleciona no barramento a linha 1 
007A:  BSF    03.5
007B:  CLRF   08
007C:  MOVLW  0D
007D:  BCF    03.5
007E:  MOVWF  08
....................    	  		tecla4=0;	   			 // Limpa a tecla pressionada 
007F:  BCF    2D.4
....................    	  		tecla5=0;		 		    // Limpa a tecla pressionada 
0080:  BCF    2D.5
....................    			tecla6=0;				    // Limpa a tecla pressionada 
0081:  BCF    2D.6
....................    			if (!input(COL1)) tecla4=1; // Verifica se tecla está pressionada 
0082:  BSF    03.5
0083:  BSF    05.4
0084:  BCF    03.5
0085:  BTFSS  05.4
0086:  BSF    2D.4
....................    			if (!input(COL2)) tecla5=1; // Verifica se tecla está pressionada 
0087:  BSF    03.5
0088:  BSF    05.5
0089:  BCF    03.5
008A:  BTFSS  05.5
008B:  BSF    2D.5
....................    			if (!input(COL3)) tecla6=1; // Verifica se tecla está pressionada 
008C:  BSF    03.5
008D:  BSF    09.0
008E:  BCF    03.5
008F:  BTFSS  09.0
0090:  BSF    2D.6
....................             output_d(Converte_to_7seg[centena]); 
0091:  MOVF   29,W
0092:  CALL   033
0093:  MOVWF  2F
0094:  BSF    03.5
0095:  CLRF   08
0096:  BCF    03.5
0097:  MOVF   2F,W
0098:  MOVWF  08
....................             output_high(SEL_CENTENA);   // Mostra o dado no barramento 
0099:  BSF    03.5
009A:  BCF    06.3
009B:  BCF    03.5
009C:  BSF    06.3
....................             break;					       // Liga display selecionado 
009D:  GOTO   0EF
....................  
....................          case 3:                     // Caso seja 3... 
....................             output_low(SEL_CENTENA); // Retira a seleção do display anterior 
009E:  BSF    03.5
009F:  BCF    06.3
00A0:  BCF    03.5
00A1:  BCF    06.3
....................    			output_d(SEL_LINHA3);	 // Seleciona no barramento a linha 3 
00A2:  BSF    03.5
00A3:  CLRF   08
00A4:  MOVLW  0B
00A5:  BCF    03.5
00A6:  MOVWF  08
....................    			tecla7=0;				       // Limpa a tecla pressionada 
00A7:  BCF    2D.7
....................    			tecla8=0;				       // Limpa a tecla pressionada 
00A8:  BCF    2E.0
....................    			tecla9=0;			          // Limpa a tecla pressionada 
00A9:  BCF    2E.1
....................    			if (!input(COL1)) tecla7=1; // Verifica se tecla está pressionada 
00AA:  BSF    03.5
00AB:  BSF    05.4
00AC:  BCF    03.5
00AD:  BTFSS  05.4
00AE:  BSF    2D.7
....................    			if (!input(COL2)) tecla8=1; // Verifica se tecla está pressionada 
00AF:  BSF    03.5
00B0:  BSF    05.5
00B1:  BCF    03.5
00B2:  BTFSS  05.5
00B3:  BSF    2E.0
....................    			if (!input(COL3)) tecla9=1; // Verifica se tecla está pressionada 
00B4:  BSF    03.5
00B5:  BSF    09.0
00B6:  BCF    03.5
00B7:  BTFSS  09.0
00B8:  BSF    2E.1
....................             output_d(Converte_to_7seg[dezena]); 
00B9:  MOVF   2A,W
00BA:  CALL   033
00BB:  MOVWF  2F
00BC:  BSF    03.5
00BD:  CLRF   08
00BE:  BCF    03.5
00BF:  MOVF   2F,W
00C0:  MOVWF  08
....................             output_high(SEL_DEZENA);    // Mostra o dado no barramento 
00C1:  BSF    03.5
00C2:  BCF    06.2
00C3:  BCF    03.5
00C4:  BSF    06.2
....................             break;					       // Liga display selecionado 
00C5:  GOTO   0EF
....................  
....................          case 4:                    // Caso seja 4... 
....................             indice=0;               // Reinicia indice 
00C6:  CLRF   2C
....................             output_low(SEL_DEZENA); // Retira a seleção do display anterior 
00C7:  BSF    03.5
00C8:  BCF    06.2
00C9:  BCF    03.5
00CA:  BCF    06.2
....................    			output_d(SEL_LINHA4);   // Seleciona no barramento a linha 4 
00CB:  BSF    03.5
00CC:  CLRF   08
00CD:  MOVLW  07
00CE:  BCF    03.5
00CF:  MOVWF  08
....................    			teclaC=0;				   // Limpa a tecla pressionada 
00D0:  BCF    2E.3
....................    			tecla0=0;				   // Limpa a tecla pressionada 
00D1:  BCF    2D.0
....................    			teclaE=0;				   // Limpa a tecla pressionada 
00D2:  BCF    2E.2
....................    			if (!input(COL1)) teclaC=1; // Verifica se tecla está pressionada 
00D3:  BSF    03.5
00D4:  BSF    05.4
00D5:  BCF    03.5
00D6:  BTFSS  05.4
00D7:  BSF    2E.3
....................    			if (!input(COL2)) tecla0=1; // Verifica se tecla está pressionada 
00D8:  BSF    03.5
00D9:  BSF    05.5
00DA:  BCF    03.5
00DB:  BTFSS  05.5
00DC:  BSF    2D.0
....................    			if (!input(COL3)) teclaE=1; // Verifica se tecla está pressionada 
00DD:  BSF    03.5
00DE:  BSF    09.0
00DF:  BCF    03.5
00E0:  BTFSS  09.0
00E1:  BSF    2E.2
....................             output_d(Converte_to_7seg[unidade]); 
00E2:  MOVF   2B,W
00E3:  CALL   033
00E4:  MOVWF  2F
00E5:  BSF    03.5
00E6:  CLRF   08
00E7:  BCF    03.5
00E8:  MOVF   2F,W
00E9:  MOVWF  08
....................             output_high(SEL_UNIDADE);// Mostra o dado no barramento 
00EA:  BSF    03.5
00EB:  BCF    06.1
00EC:  BCF    03.5
00ED:  BSF    06.1
....................             break;	     				 // Liga display selecionado 
00EE:  GOTO   0EF
....................       } 
.................... } 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                  		Fim do Programa              			   * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
....................  
00EF:  BCF    0B.2
00F0:  BCF    0A.3
00F1:  BCF    0A.4
00F2:  GOTO   01D

Configuration Fuses:
   Word  1: 3F35   XT WDT PUT NODEBUG NOPROTECT NOBROWNOUT NOLVP NOCPD NOWRT
